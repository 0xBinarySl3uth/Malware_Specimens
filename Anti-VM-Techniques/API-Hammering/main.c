/*
 * API Hammering is a sandbox bypass technique where random WinAPIs are rapidly called
 * to delay the execution of a program and to obfuscate the call stack of the running thread.
 */

#include <Windows.h>
#include <stdio.h>

 // Define temporary file name
#define TMPFile L"0xBinary.tmp"
// Define from Seconds to Cycles in the for loop.
#define ConvertoCycles(i) ((int)i * 198)

// Function to perform API hammering by creating, writing random data to, reading from, and deleting a temporary file in a loop
BOOL API_Hammering(DWORD Cycles) {
    // Buffer paths and file handles
    WCHAR       szPath[MAX_PATH * 2], szTmpPath[MAX_PATH];
    HANDLE      hRFile = INVALID_HANDLE_VALUE, hWFile = INVALID_HANDLE_VALUE;
    DWORD       dwNumberOfBytesRead = 0, dwNumberOfBytesWritten = 0;
    PBYTE       pRandBuffer = NULL;
    SIZE_T      sBufferSize = 0xFFFFF;    // 1048575 bytes
    INT         iRandom = 0;

    // Getting the tmp folder path
    if (!GetTempPathW(MAX_PATH, szTmpPath)) {
        printf("[!] GetTempPathW Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    // Constructing the file path
    wsprintfW(szPath, L"%s%s", szTmpPath, TMPFile);

    for (SIZE_T i = 0; i < Cycles; i++) {
        // Creating the file in write mode
        if ((hWFile = CreateFileW(szPath, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL)) == INVALID_HANDLE_VALUE) {
            printf("[!] CreateFileW Failed With Error : %d \n", GetLastError());
            return FALSE;
        }
        // Allocate buffer on the HEAP for random data
        pRandBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sBufferSize);

        // Fill buffer with random values
        srand(time(NULL)); // Seed the random number generator with the current time
        iRandom = rand() % 0xFF; // Generate a random integer between 0 and 255
        memset(pRandBuffer, iRandom, sBufferSize); // Fill the buffer with the random integer

        // Write random values to the file
        if (!WriteFile(hWFile, pRandBuffer, sBufferSize, &dwNumberOfBytesWritten, NULL) || dwNumberOfBytesWritten != sBufferSize) {
            printf("[!] WriteFile Failed With Error : %d \n", GetLastError());
            printf("[+] Written %d Bytes of %d \n", dwNumberOfBytesWritten, sBufferSize);
            return FALSE;
        }

        // Cleaning up
        RtlZeroMemory(pRandBuffer, sBufferSize);
        CloseHandle(hWFile);

        // Re-open handle with deleted permissions for reading
        if ((hRFile = CreateFileW(szPath, GENERIC_READ, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL)) == INVALID_HANDLE_VALUE) {
            printf("[!] CreateFileW Failed With Error : %d \n", GetLastError());
            return FALSE;
        }

        // Read the random values 	
        if (!ReadFile(hRFile, pRandBuffer, sBufferSize, &dwNumberOfBytesRead, NULL) || dwNumberOfBytesRead != sBufferSize) {
            printf("[!] ReadFile Failed With Error : %d \n", GetLastError());
            printf("[+] Read %d Bytes of %d \n", dwNumberOfBytesRead, sBufferSize);
            return FALSE;
        }

        // Cleaning up heap
        RtlZeroMemory(pRandBuffer, sBufferSize);
        HeapFree(GetProcessHeap(), NULL, pRandBuffer);

        // Close handle, results in deleting file
        CloseHandle(hRFile);
    }

    printf("[+] Allocated Buffer At: 0x%p \n", pRandBuffer);

    return TRUE;
}

int main() {
    DWORD Time1, Time2, dwThreadId = { 0 };

    // Prompt for delayed execution method
    printf("[+] API Hammering Delayed Execution Method, Press <Enter> To Execute\n");
    getchar();

    Time1 = GetTickCount64();

    // Perform API Hammering for 5 cycles
    if (!API_Hammering(ConvertoCycles(5))) {
        return -1;
    }

    Time2 = GetTickCount64();
    printf("\t[+] ApiHammering(1000) Took: %d MilliSeconds To Complete\n", (DWORD)(Time2 - Time1));

    // Prompt for API Hammering in thread method
    printf("[+] API Hammering In Thread Method, Press <Enter> To Execute\n");
    getchar();

    // Create a thread to perform API Hammering
    if (!CreateThread(NULL, NULL, API_Hammering, -1, NULL, &dwThreadId)) {
        printf("\t[+] CreateThread Failed With Error Code: %d \n", GetLastError());
        return -1;
    }
    printf("\t[+] Thread Created With API Hammering Under PID: %d \n", dwThreadId);

    // Prompt to exit
    printf("[#] Press <Enter> To Quit ...\n");
    getchar();

    return 0;
}
