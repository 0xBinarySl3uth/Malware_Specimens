#include <Windows.h>
#include <stdio.h>
#include <sysinfoapi.h>
#include <WinUser.h>
#include <Shlwapi.h>
#include <psapi.h>
#pragma comment(lib, "Shlwapi.lib")

// Function to check the number of CPUs present
BOOL CPUPresent() {
    SYSTEM_INFO sysInformation = { 0 };

    // Retrieve system information
    GetSystemInfo(&sysInformation);

    // Check for potential failure using GetLastError
    DWORD error = GetLastError();
    if (error != ERROR_SUCCESS) {
        // Print an error message with the error code
        printf("[!] GetSystemInfo Failed With Error Code: %d\n", error);
        return FALSE;
    }

    // If the number of processors is less than 2
    if (sysInformation.dwNumberOfProcessors < 2) {
        // Print a message indicating potential VM detection and the number of processors
        printf("[!] Probably VM Detected! Number Of Processors: %u\n", sysInformation.dwNumberOfProcessors);
        return TRUE;
    }

    // If the number of processors is 2 or more
    return FALSE;
}

// Function to check if the available RAM is less than or equal to 3 GB
BOOL RAMCheck() {
    // Structure that contains the current state of hardware-related information
    // We need to initialize the structure to use GlobalMemoryStatusEx
    MEMORYSTATUSEX MemStatus = { .dwLength = sizeof(MEMORYSTATUSEX) };

    // Retrieve system information and put the information in the MemStatus pointer
    if (!GlobalMemoryStatusEx(&MemStatus)) {
        printf("[!] GlobalMemoryStatusEx Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // If RAM is less than 3 GB
    if ((DWORD)MemStatus.ullTotalPhys <= (DWORD)(3221225472)) {
        printf("[!] VM Detected! Number of Physical Memory: %llu bytes\n", MemStatus.ullTotalPhys);
        return TRUE;
    }

    // If RAM > 3 GB
    return FALSE;
}

BOOL USBMounts() {
    HKEY hKey = NULL;       // Handle to the registry key
    DWORD dwUsbNum = 0;     // Number of USB devices mounted
    DWORD dwRegError = 0;   // Variable to store registry operation errors

    // Open the registry key with read permissions
    if ((dwRegError = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SYSTEM\\ControlSet001\\Enum\\USBSTOR\\", NULL, KEY_READ, &hKey)) != ERROR_SUCCESS) {
        printf("[!] RegOpenKeyExA Failed With Error Code: %d | 0x%0.10X\n", dwRegError, dwRegError);
    }

    // Retrieve information about the specified registry key (hKey)
    if ((dwRegError = RegQueryInfoKeyA(hKey, NULL, NULL, NULL, &dwUsbNum, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS) {
        printf("\n\t[!] RegQueryInfoKeyA Failed With Error : %d | 0x%0.8X\n", dwRegError, dwRegError);
    }

    // Less than 2 USB mounted
    if (dwUsbNum < 2) {
        printf("[!] VM Detected! Number of USB Mounted: %u\n", dwUsbNum);

        // Close the registry key before returning
        RegCloseKey(hKey);
        return TRUE;
    }
    RegCloseKey(hKey);
    // If 2 or more USB devices are mounted
    return FALSE;
}

// Callback function called by EnumDisplayMonitors for each monitor
// A callback function is a function passed as an argument to another function.
BOOL CALLBACK DisplayCallback(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARAM ldata) {
    // hMonitor: Handle to the display monitor
    // hdcMonitor: Handle to a device context for the display monitor
    // lpRect: Pointer to a RECT structure that specifies the display monitor's screen coordinates
    // ldata: User-defined data passed from the EnumDisplayMonitors function; in this case, a pointer to a BOOL variable

    // Declare variables for X and Y coordinates
    int x, y = { 0 };

    // Create a structure to hold monitor information, initialize the size of the structure
    MONITORINFO MI = { .cbSize = sizeof(MONITORINFO) };

    // Retrieve information about the display monitor
    if (!GetMonitorInfoW(hMonitor, &MI)) {
        // Display an error message if GetMonitorInfoW fails, including the error code
        printf("[!] GetMonitorInfoW Failed With Error Code: %d\n", GetLastError());
        return FALSE; // Return FALSE to stop the enumeration
    }

    // Calculate the width (X coordinate) of the display
    x = MI.rcMonitor.right - MI.rcMonitor.left;

    // Calculate the height (Y coordinate) of the display
    y = MI.rcMonitor.bottom - MI.rcMonitor.top;

    // When output is negative, reverse the value to ensure it's positive
    if (x < 0)
        x = -x;
    if (y < 0)
        y = -y;

    // Check if the display resolution is not one of the specified values
    if ((x != 1920 && x != 2560 && x != 1440) || (y != 1080 && y != 1200 && y != 1600 && y != 900))
        *((BOOL*)ldata) = TRUE; // Set the value at the specified address to TRUE, indicating VM detection

    // Continue enumeration
    return TRUE;
}

// Function to check if the display resolution indicates a virtual machine or sandbox
BOOL CheckDisplay() {
    // Initialize a boolean variable to indicate whether a sandbox or VM is detected
    BOOL SandBox = FALSE;

    // Enumerate through all display monitors, calling DisplayCallback for each
    EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)DisplayCallback, (LPARAM)(&SandBox));

    // Return the result of the detection (TRUE if a sandbox or VM is detected, FALSE otherwise)
    return SandBox;
}

BOOL RenameToDigits() {
    CHAR cPath[MAX_PATH * 3]; // Store the full path
    CHAR cName[MAX_PATH];     // Store the extracted file name
    DWORD dwNumofDigits = 0;  // Counter to keep track of the number of digits

    // Get the current fully qualified file name with its path
    if (!GetModuleFileNameA(NULL, cPath, MAX_PATH * 3)) {
        printf("[!] GetModuleFileNameA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Getting filename from full path (prevent BOF) by checking if the full filename is not bigger than max_path
    // Copy the filename to a separate buffer for further processing
    if (lstrlenA(PathFindFileNameA(cPath)) < MAX_PATH) {
        lstrcpyA(cName, PathFindFileNameA(cPath));
        printf("\t [+] Fullpath: %s\n", cPath);
        printf("\t [+] Filename: %s\n", cName);
    }

    // Counting the number of digits in the filename
    for (int i = 0; i < lstrlenA(cName); i++) {
        // Check if the current character is a digit
        if (isdigit(cName[i]))
            // Increment counter
            dwNumofDigits++;
    }
    if (dwNumofDigits > 3) {
        // Sandbox detected
        return TRUE;
    }
    // Return false if the number of digits is less than 3
    return FALSE;
}

// Function that checks the number of processes
BOOL VMProcesses() {
    DWORD dwProcesses[1024]; // Array to store PIDs
    DWORD dwProcessIDs = 0;  // Store the size of the array of PIDs
    DWORD dwNumProcess = 0;  // Store the processes that are running currently

    // Retrieve the current processes
    if (!EnumProcesses(dwProcesses, sizeof(dwProcesses), &dwProcessIDs)) {
        printf("[!] EnumProcesses Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Calculate the number of running processes based on the size of the process ID array
    // sizeof(DWORD) == 4
    dwNumProcess = dwProcessIDs / sizeof(DWORD);
    printf("[+] Number of Processes Running: %d\n", dwNumProcess);

    // Check if the number of running processes is below 50
    if (dwNumProcess < 50) {
        printf("[!] VM Detected\n");
        return TRUE;
    }
    return FALSE;
}

// Function that retrieves the computer name
BOOL GetComName() {
    // Variable to store the computer name
    CHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    // Specify the size of the buffer
    DWORD bufferSize = sizeof(ComputerName) / sizeof(ComputerName[0]);

    // Getting ComputerName
    if (!GetComputerNameA(ComputerName, &bufferSize)) {
        printf("[!] GetComputerNameA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }
    printf("\t[+] Computer Name: %s\n", ComputerName);

    if (strcmp(ComputerName, "Sandbox" || "Vmware") == 0) {
        printf("\t[!] VM Detected\n");
        return TRUE;
    }
    return FALSE;
}

int main() {
    printf("[(---)] Checking Presence of Virtual Machine\n");

    if (!CPUPresent()) {
        printf("\t[+] No Virtual Machine Detected\n");
    }

    if (!RAMCheck()) {
        printf("\t[+] No Virtual Machine Detected\n");
    }

    if (!USBMounts()) {
        printf("\t[+] No Virtual Machine Detected\n");
    }

    if (!CheckDisplay()) {
        printf("\t[+] No Virtual Machine Detected\n");
    }

    if (!RenameToDigits()) {
        printf("\t [+] No Virtual Machine Detected\n");
    }

    if (!VMProcesses()) {
        printf("\t [+] No Virtual Machine Detected\n");
    }

    if (!GetComName()) {
        printf("\t [+] No Virtual Machine Detected\n");
    }
    return 0;
}
