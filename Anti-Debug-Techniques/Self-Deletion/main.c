#include <Windows.h>
#include <stdio.h>

// Define constants for the main data stream and alternate data stream names
#define MainDataStream L":$DATA"
#define AlternateDataStream L":0xBinary"

// Function to delete the executable
BOOL DeleteFileAndStream(const wchar_t* streamName) {
    WCHAR                   szPath[MAX_PATH * 2] = { 0 };  // Buffer to store the file path
    FILE_DISPOSITION_INFO   Delete = { 0 };  // Structure to indicate file deletion
    HANDLE                  hFile = INVALID_HANDLE_VALUE;  // File handle
    PFILE_RENAME_INFO       pRename = NULL;  // Structure for renaming a data stream
    SIZE_T                  StreamLength = wcslen(streamName) * sizeof(wchar_t);  // Length of the stream name
    SIZE_T                  sRename = sizeof(FILE_RENAME_INFO) + StreamLength;  // Size of the rename structure

    // Allocating memory for FILE_RENAME_INFO structure
    pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
    if (!pRename) {
        wprintf(L"[!] HeapAlloc Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Cleaning up some structures
    ZeroMemory(szPath, sizeof(szPath));
    ZeroMemory(&Delete, sizeof(FILE_DISPOSITION_INFO));

    // Indicates that the file should be deleted
    Delete.DeleteFile = TRUE;

    // Setting data stream buffer and size in FILE_RENAME_INFO structure
    pRename->FileNameLength = StreamLength;
    RtlCopyMemory(pRename->FileName, streamName, StreamLength);

    // Get the current file name
    if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
        wprintf(L"[!] GetModuleFileNameW Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    /* <----- Rename ------> */

    // Open a handle to the current file
    hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"[!] CreateFileW Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    wprintf(L"[+] Renaming %s to %s\n", streamName, MainDataStream);

    // Rename the data stream
    if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
        wprintf(L"[!] SetFileInformationByHandle Failed With Error Code: %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    wprintf(L"[+] Renamed Stream!\n");
    CloseHandle(hFile);


    /* <----- Delete ------> */


    // Open a new handle to the current file
    hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE && GetLastError() == ERROR_FILE_NOT_FOUND) {
        // In case the file is already deleted
        return TRUE;
    }
    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"[!] CreateFileW [D] Failed With Error : %d\n", GetLastError());
        return FALSE;
    }

    // Marking for deletion after the file's handle is closed
    if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &Delete, sizeof(Delete))) {
        wprintf(L"[!] SetFileInformationByHandle [D] Failed With Error : %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    wprintf(L"[+] Successfully Deleted File and Stream!\n");
    CloseHandle(hFile);
    HeapFree(GetProcessHeap(), 0, pRename);

    return TRUE;
}

int main() {
    // Call the DeleteFileAndStream function to delete the specified alternate data stream
    if (!DeleteFileAndStream(AlternateDataStream)) {
        return -1;
    }

    wprintf(L"[+] Executable Should Be Deleted\n");

    // Wait for user input before exiting
    wprintf(L"[*] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}
