/*
Explanation:
    - The following script is going to show different information types inside a PE header of an executable.

RVA:
    - Relative Virtual Address
    - RVAs are addresses that are used to reference locations within a PE file

DOS Header:
    - DOS Header is located at the beginning of a PE file and contains information about the file, such as size, RVA to the NT header

ReadPeFile Function: 
    - This function is responsible for reading the specified PE file. It opens the file, retrieves its size, allocates memory, and reads the file into memory.

PeParse Function: 
    - This function parses and extracts information from the PE file's header. It does the following:
        It checks if the file starts with the "MZ" (magic bytes) that indicate it's a valid PE file.
        It extracts information from the IMAGE_NT_HEADERS, which contains details about the PE file's architecture, number of sections, size of the optional header, and characteristics.
        It provides information about the optional header, including the architecture, code and data sizes, entry point address, image size, and more.
        It lists the directories within the PE file, such as the Export Directory, Import Directory, Resource Directory, and others, along with their sizes and virtual addresses.
        It examines the sections in the PE file, extracting details like the section name, size, RVA (Relative Virtual Address), address, relocations, and permissions.
 */

#include <Windows.h>
#include <stdio.h>

BOOL ReadPeFile(LPCSTR lpFileName, PBYTE* pPe, SIZE_T* sPe) {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE pBuff = NULL;
    DWORD dwNumberOfBytesRead = 0;
    DWORD dwFileSize = 0;

    printf("[+] Reading %s\n", lpFileName);

    // Opens the specified user file
    hFile = CreateFileA(lpFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE) {
        printf("[!] GetFileSize Failed With Error Code: %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    // Allocate memory in the heap
    pBuff = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);
    if (pBuff == NULL) {
        printf("[!] HeapAlloc Failed With Error : %d\n", GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    if (!ReadFile(hFile, pBuff, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        printf("[!] ReadFile Failed With Error Code: %d\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, pBuff); // Free allocated memory
        CloseHandle(hFile);
        return FALSE;
    }
    CloseHandle(hFile);

    printf("[+] Successfully Opened File!\n");

    // Assign the output to the appropriate parameters
    *pPe = pBuff;
    *sPe = dwFileSize;

    return TRUE;
}

/*
typedef struct _IMAGE_DOS_HEADER
{
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
*/

VOID PeParse(PBYTE pPe) {
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pPe;

    // 0x5a4d == MZ (magic bytes of MZ)
    if (pImgDosHdr->e_magic != 0x5A4D) {
        return;
    }

    /*
    typedef struct _IMAGE_NT_HEADERS {
      DWORD                   Signature;
      IMAGE_FILE_HEADER       FileHeader;
      IMAGE_OPTIONAL_HEADER32 OptionalHeader;
    } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
    */

    // RVA to NT Headers structure
    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pPe + pImgDosHdr->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        return;
    }

    printf("\n---------------------[ File Headers ]---------------------\n");
    /*
    typedef struct _IMAGE_FILE_HEADER {
      WORD  Machine;
      WORD  NumberOfSections;
      DWORD TimeDateStamp;
      DWORD PointerToSymbolTable;
      DWORD NumberOfSymbols;
      WORD  SizeOfOptionalHeader;
      WORD  Characteristics;
    } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
    */

    // Accessing file header by accessing IMAGE_NT_HEADER structure
    IMAGE_FILE_HEADER ImgFileHdr = pImgNtHdrs->FileHeader;

    // Characteristics member represents attributes of PE file such as; DLL, EXE
    // Checks whether it is an executable image
    if (ImgFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        printf("[+] Executable File Is An: ");

        if (ImgFileHdr.Characteristics & IMAGE_FILE_DLL)
            printf("DLL\n");
        else if (ImgFileHdr.Characteristics & IMAGE_SUBSYSTEM_NATIVE)
            printf("SYS\n");
        else if (ImgFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)
            printf("EXE\n");
        else
            printf("[!] Could Not Determine Type of File\n");
    }

    printf("[+] File Architecture: %s\n", ImgFileHdr.Machine == IMAGE_FILE_MACHINE_I386 ? "x32" : "x64");
    printf("[+] Number of Sections Inside PE: %u\n", ImgFileHdr.NumberOfSections);
    printf("[+] Size Of The Optional Header: %u\n", ImgFileHdr.SizeOfOptionalHeader);
    printf("[+] Characteristics Of PE: %04X\n", ImgFileHdr.Characteristics);

    printf("\n\n\n--------------------- [ OPTIONAL HEADER ---------------------\n");

    IMAGE_OPTIONAL_HEADER	ImgOptHdr = pImgNtHdrs->OptionalHeader;

    // Check if the optional header has the expected magic value
    if (ImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        return;
    }

    printf("[+] File Arch (Second way) : %s \n", ImgOptHdr.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ? "x32" : "x64");
    printf("[+] Size Of Code Section : %d \n", ImgOptHdr.SizeOfCode);
    printf("[+] Address Of Code Section : 0x%p \n[RVA : 0x%0.8X]\n", (PVOID)(pPe + ImgOptHdr.BaseOfCode), ImgOptHdr.BaseOfCode);
    printf("[+] Size Of Initialized Data : %d \n", ImgOptHdr.SizeOfInitializedData);
    printf("[+] Size Of Unitialized Data : %d \n", ImgOptHdr.SizeOfUninitializedData);
    printf("[+] Preferable Mapping Address : 0x%p \n", (PVOID)ImgOptHdr.ImageBase);
    printf("[+] Required Version : %d.%d \n", ImgOptHdr.MajorOperatingSystemVersion, ImgOptHdr.MinorOperatingSystemVersion);
    printf("[+] Address Of The Entry Point : 0x%p \n\[RVA : 0x%0.8X]\n", (PVOID)(pPe + ImgOptHdr.AddressOfEntryPoint), ImgOptHdr.AddressOfEntryPoint);
    printf("[+] Size Of The Image : %d \n", ImgOptHdr.SizeOfImage);
    printf("[+] File CheckSum : 0x%0.8X \n", ImgOptHdr.CheckSum);
    printf("[+] Number of entries in the DataDirectory array : %d \n", ImgOptHdr.NumberOfRvaAndSizes);

    printf("\n\n\n--------------------- [ Directories ]---------------------\n");

    printf("[+] Export Directory at 0x%p Of Size: %d \n \t[RVA: 0%0.8X]\n", (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    printf("[+] Import Directory At 0x%p Of Size : %d \n \t[RVA : 0x%0.8X]\n", (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    printf("[*] Resource Directory At 0x%p Of Size : %d \n \t[RVA : 0x%0.8X]\n", (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
    printf("[*] Exception Directory At 0x%p Of Size : %d \n \t[RVA : 0x%0.8X]\n",  (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress);
    printf("[+] Base Relocation Table At 0x%p Of Size : %d \n \t[RVA : 0x%0.8X]\n", (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
    printf("[*] TLS Directory At 0x%p Of Size : %d \n \t[RVA : 0x%0.8X]\n",  (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
    printf("[+] Import Address Table At 0x%p Of Size : %d \n \t[RVA : 0x%0.8X]\n", (PVOID)(pPe + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress), ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress);

    /*
    typedef struct _IMAGE_SECTION_HEADER {
          BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
          union {
            DWORD PhysicalAddress;
            DWORD VirtualSize;
          } Misc;
          DWORD VirtualAddress;
          DWORD SizeOfRawData;
          DWORD PointerToRawData;
          DWORD PointerToRelocations;
          DWORD PointerToLinenumbers;
          WORD  NumberOfRelocations;
          WORD  NumberOfLinenumbers;
          DWORD Characteristics;
        } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
    */


    printf("\n\n\n--------------------- [ Sections ]---------------------\n");
    PIMAGE_SECTION_HEADER pImgSectionHdr = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdrs) + sizeof(IMAGE_NT_HEADERS));
    for (size_t i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        printf("[+] %s \n", (CHAR*)pImgSectionHdr->Name);
        printf("\tSize : %d \n", pImgSectionHdr->SizeOfRawData);
        printf("\tRVA : 0x%0.8X \n", pImgSectionHdr->VirtualAddress);
        printf("\tAddress : 0x%p \n", (PVOID)(pPe + pImgSectionHdr->VirtualAddress));
        printf("\tRelocations : %d \n", pImgSectionHdr->NumberOfRelocations);
        printf("\tPermissions : ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_READ)
            printf("PAGE_READONLY & ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_WRITE && pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_READ)
            printf("PAGE_READWRITE & ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_EXECUTE)
            printf("PAGE_EXECUTE & ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_EXECUTE && pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_READ)
            printf("PAGE_EXECUTE_READWRITE");
        printf("\n\n");

        pImgSectionHdr = (PIMAGE_SECTION_HEADER)((PBYTE)pImgSectionHdr + (DWORD)sizeof(IMAGE_SECTION_HEADER));
    }

}


int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("[!] Please Enter PE File To Parse ...\n");
        return -1;
    }

    PBYTE pPe = NULL;
    SIZE_T sPe = 0;

    if (!ReadPeFile(argv[1], &pPe, &sPe)) {
        return -1;
    }

    printf("[+] \"%s\" Read At: 0x%p Of Size: %zu\n", argv[1], pPe, sPe);

    PeParse(pPe);

    printf("[#] Press <Enter> To Quit ... \n");
    getchar();

    HeapFree(GetProcessHeap(), NULL, pPe);

    return 0;
}
