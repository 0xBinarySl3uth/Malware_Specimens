/*
Explaination:
	- GetModuleHandle retrieves a handle for a specified DLL.
	- The function returns a handle to the DLL or NULL of the DLL doesn't exist in the calling process.

	- The HMODULE data type is the base address of the loaded DLL which is where the DLL is located in the address space of the process.
	- The goal of the replacement function is to retrieve the base address of the specified DLL. 
*/

#include <Windows.h>
#include <stdio.h>
#include "Structs.h"

// ifndef checks if the identifier hasn't been defined or removed.
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives
// https://learn.microsoft.com/en-us/cpp/preprocessor/hash-ifdef-and-hash-ifndef-directives-c-cpp?view=msvc-170
#ifndef STRUCTS
#include <winternl.h>
#endif // !STRUCTS

// Define a macro for calculating the address of a structure based on a field address.
#define CONTAINING_RECORD(address, type, field) \  ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

// Define a function to convert two wide character strings to lowercase and compare them.
// (Helper Function for GetModuleHandleRep)
BOOL String2LowerCase(_In_ LPCWSTR String1, _In_ LPCWSTR String2) {
    // Declare local variables to hold the lowercase versions of the input strings.
    WCHAR lString1[MAX_PATH];
    WCHAR lString2[MAX_PATH];

    int LengthString1 = lstrlenW(String1);  // Get the length of String1.
    int LengthString2 = lstrlenW(String2);  // Get the length of String2.
    int i, j = 0;

    // Check if the lengths of both strings are greater than or equal to our buffer size (MAX_PATH).
    if (LengthString1 >= MAX_PATH || LengthString2 >= MAX_PATH) {
        return FALSE;  // Return FALSE to indicate an error.
    }

    // Convert String1 to a lowercase string (lString1).
    for (i = 0; i < LengthString1; i++) {
        lString1[i] = (WCHAR)tolower(String1[i]);
    }
    lString1[i++] = L'\0';  // Null-terminate the lowercase string.

    // Convert String2 to a lowercase string (lString2).
    for (j = 0; j < LengthString2; j++) {
        lString2[j] = (WCHAR)tolower(String2[j]);
    }
    lString2[j++] = L'\0';  // Null-terminate the lowercase string.

    // Compare 2 strings (that are now both lowercase)
    if (lstrcmp(lString1, lString2) == 0) {
        return TRUE;
    }

    return FALSE;
}

HMODULE GetModuleHandleRep(_In_ LPCWSTR szModuleName) {
    // Check the target architecture, if it's 64-bit, this code block will be used.
#ifdef _WIN64
    // On 64-bit Windows, we need to access the PEB using the GS segment register.
    // The __readgsqword function reads a 64-bit value from a specified offset (0x60).
    PPEB pPeb = (PEB*)(__readgsqword(0x60));

    // If the target architecture is 32-bit, this code block will be used.
#elif _WIN32
    // On 32-bit Windows, the PEB is accessed using the FS segment register.
    // The __readfsdword function reads a 32-bit value from a specified offset (0x30).
    PPEB pPeb = (PEB*)(__readfsdword(0x30));
#endif


    // Retrieve Ldr Member and cast it to PPEB_LDR_DATA
    // Ldr -> Contains information about the loaded modules for the target process
    // https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data
    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

    // https://learn.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry
    // LIST Entry Structure uses a doubly-linked list, it's the same array but easier to access adjacent elements
    // Flink points to the next node in the list 
    // Blink points to the previous node in the list

    /*
    typedef struct _LIST_ENTRY {
     struct _LIST_ENTRY *Flink;
     struct _LIST_ENTRY *Blink;
    } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
    */

    // Getting the first element (using Flink Member) in the linked lists, which contains information about the first module in the target process
    PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

    // Iterate through the linked list of loaded modules to find a specific DLL
    while (pDte) {
        // Checks whether DLL name is not empty (FullDllName.Length != 0)
        if (pDte->FullDllName.Length != NULL) {
            // Convert the DLL name to lowercase for case-insensitive comparison
            if (String2LowerCase(pDte->FullDllName.Buffer, szModuleName)) {
                // If a matching DLL is found:
                wprintf(L"[+] Found DLL: %s, InMemoryOrderLinks.Blink: 0x%p\n", pDte->FullDllName.Buffer, pDte->InMemoryOrderLinks.Blink);
#ifdef STRUCTS
                // On success, return the handle to the module (HMODULE) via the Initialization Order link
                return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
#else
                // On success, return the handle to the module (HMODULE) using Reserved2[0]
                return (HMODULE)pDte->Reserved2[0];
#endif // STRUCTS
            }
        }
        else {
            // If the DLL name is empty, break out of the loop
            break;
        }

        // Move to the next element in the linked list by following the forward link
        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
    }

    return NULL;
   
}

int main() {
    printf("[+] Origial Address: 0x%p \n", GetModuleHandleW(L"NTDLL.DLL"));
    printf("[+] Custom Address: 0x%p \n", GetModuleHandleRep(L"NTDLL.DLL"));

    getchar();
    return 0;
}