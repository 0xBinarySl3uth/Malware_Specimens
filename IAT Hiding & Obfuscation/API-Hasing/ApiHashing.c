#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <ctype.h> 

#define SEED 7


// JenkingOneAtAtime Hashinig Method (Module: 51)
// First function takes a ASCII String
// Second function takes a UNICODE String 
UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = lstrlenA(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash << SEED;
		Hash ^= Hash >> 6;
	}

	Hash += Hash << 3;
	Hash ^= Hash >> 11;
	Hash += Hash << 15;

	return Hash;
}


UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = lstrlenW(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash << SEED;
		Hash ^= Hash >> 6;
	}

	Hash += Hash << 3;
	Hash ^= Hash >> 11;
	Hash += Hash << 15;

	return Hash;
}

// Macro to hash an ASCII/UNISIDE string using Jenkins One-at-a-time hash function.
#define HashA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))
#define HashW(API) (HashStringJenkinsOneAtATime32BitW((PWCHAR) API))

// hModule - Handle to the loaded Dynamic Link Library (DLL)
// dwApiName2Hash - Hash of the function name to look up in the DLL
FARPROC GetProcAddressHash(HMODULE hModule, DWORD dwApiName2Hash) {

	DWORD exportDirectoryVA = NULL;

	if (hModule == NULL || dwApiName2Hash == NULL) {
		return NULL;
	}

	// Avoid casting when converting Relative Virtual Address (RVA) to Virtual Address (VA)
	PBYTE pBase = (PBYTE)hModule;

	// Cast the function address to the IMAGE_DOS_HEADER structure
	PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
	if (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
		return NULL;
	}

	// Casting to the IMAGE_NT_HEADERS structure to access the PE header
	PIMAGE_NT_HEADERS pImgNtHdr = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
	if (pImgNtHdr->Signature != IMAGE_NT_SIGNATURE) {
		return NULL;
	}

	// Casting the IMAGE_OPTIONAL_HEADER structure to pImgOptHdr
	IMAGE_OPTIONAL_HEADER pImgOptHdr = pImgNtHdr->OptionalHeader;
	if (pImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
		return 0;
	}

	// Getting Virtual Addresses of the export directory
	PIMAGE_EXPORT_DIRECTORY		pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + pImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	if (pImgExportDir == NULL) {
		return NULL;
	}
	// Obtain a pointer to the array of virtual addresses of function names.
	PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);

	// Obtain a pointer to the array of virtual addresses of function entry points.
	PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);

	// Obtain a pointer to the array of function ordinals.
	PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

	// Loop through the exported functions
	for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
		// Obtain pointer to the current function name
		CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

		// Pointer to function entry point address
		PVOID	pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);
		// if both hashes are equal, then we found the function we want 
		if (dwApiName2Hash == HashA(pFunctionName)) {
			return pFunctionAddress;
		}
	}

	return NULL;
}

// Function to get the module handle based on a hash of the module name.
HMODULE GetModuleHandleHash2(DWORD dwModuleNameHash) {
	// Check if the input hash is NULL, and if so, return NULL immediately.
	if (dwModuleNameHash == NULL)
		return NULL;

#ifdef _WIN64
	// On 64-bit Windows, obtain a pointer to the Process Environment Block (PEB)
	PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
	// On 32-bit Windows, obtain a pointer to the PEB
	PPEB pPeb = (PEB*)(__readfsdword(0x30));
#endif

	// Get a pointer to the Loader Data of the PEB.
	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

	// Get a pointer to the first entry in the list of loaded modules.
	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

	// Iterate through the list of loaded modules as long pDte is not 0.
	while (pDte) {
		if (pDte->FullDllName.Length != NULL && pDte->FullDllName.Length < MAX_PATH) {
			// Convert the FullDllName.Buffer to an upper-case string for consistent comparison.
			CHAR UpperCaseDllName[MAX_PATH];

			DWORD i = 0;
			while (pDte->FullDllName.Buffer[i]) {
				UpperCaseDllName[i] = (CHAR)toupper(pDte->FullDllName.Buffer[i]);
				i++;
			}
			UpperCaseDllName[i] = '\0';

			// Hash the UpperCaseDllName and compare the hash value to dwModuleNameHash.
			if (HashA(UpperCaseDllName) == dwModuleNameHash)
				return pDte->Reserved2[0]; // Return the module handle if a match is found.
		}
		else {
			// Break out of the loop if FullDllName.Length is NULL or exceeds MAX_PATH.
			break;
		}

		// Move to the next entry in the list of loaded modules.
		pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
	}

	// Return NULL if the module is not found.
	return NULL;
}

typedef int (WINAPI* fnMessageBoxA)(
	HWND hWnd,
	LPCSTR lpText,
	LPCSTR lpCaption,
	UINT uType
	);

int main() {
	// Calculate and print hash values
	UINT32 user32Hash = HashA("USER32.DLL");
	UINT32 messageBoxAHash = HashA("MessageBoxA");

	printf("[+] Hash of \"%s\" is: 0x%0.10X \n", "USER32.DLL", user32Hash);
	printf("[+] Hash of \"%s\" is: 0x%0.10X \n", "MessageBoxA", messageBoxAHash);

	// Load user32.dll to the current process
	if (LoadLibraryA("USER32.DLL") == NULL) {
		printf("[!] LoadLibraryA Failed With Error: %d\n", GetLastError());
		return 0;
	}

	HMODULE hUser32Mod = GetModuleHandleHash2(HashA("USER32.DLL"));

	if (hUser32Mod == NULL) {
		printf("[!] GetModuleHandleH Failed With Error: %d\n", GetLastError());
		return -1;
	}

	// Get the address of MessageBoxA function using GetProcAddressHash
	fnMessageBoxA pMessageBoxA = (fnMessageBoxA)GetProcAddressHash(hUser32Mod, messageBoxAHash);

	if (pMessageBoxA == NULL) {
		printf("[!] Failed To Find Address Of Specified Function, %d\n", GetLastError());
		return -1;
	}

	printf("[+] Address of MessageBoxA function: 0x%p \n", pMessageBoxA);

	// Call MessageBoxA
	MessageBoxA(NULL, "PoC API Hashing", "0xBinarySl3uth", MB_OK | MB_ICONEXCLAMATION);

	printf("Press <Enter> to exit\n");
	getchar();

	return 0;
}