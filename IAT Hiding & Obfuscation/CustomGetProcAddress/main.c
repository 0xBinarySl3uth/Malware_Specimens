/*
Explanation:
- The GetProcAddress WinAPI retrieves the address of an exported function from a specified module handle. It returns NULL if the function is not found in the specified module handle.
- The hModule parameter represents the base address of the loaded DLL. This is where the DLL module is located in the address space of the process.
- To retrieve a function's address, we loop through the exported functions inside the provided DLL and check if the target function's name exists.
    - If there is a valid match, we retrieve the address.
    - To access the exported functions, it's necessary to access the DLL's export table and loop through it in search of the target function name.
- FARPROC is a typedef used to represent a pointer to a function. It's commonly used for dynamic linking and loading of functions.
*/

// Export Table Structure
/*
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // Specifies the address of an array of addresses of the exported functions.
    DWORD   AddressOfNames;         // Specifies the address of an array of addresses of hte names of the exported functions.
    DWORD   AddressOfNameOrdinals;  // Specifies the address of an array of ordinal numbers for the exported functions.
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

*/

#include <Windows.h>
#include <stdio.h>
#include <winternl.h>

FARPROC GetProcessAddressRep(_In_ HMODULE hModule, _In_ LPCSTR lpApiName) {
    // Avoid casting when convertnig RVA -> VA
    PBYTE pBase = (PBYTE)hModule;

    /*
    typedef struct _IMAGE_DOS_HEADER {  // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
    */

    // Getting DOS Header 
    // Casting PIMAGE_DOS_HEADER to pBase
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
        return 1;
    }

    // Calculate the address of the NT headers:
    // 1. Start with the base address of the loaded PE file (pBase).
    // 2. Add the offset to the NT headers, which is stored in the e_lfanew field of the DOS header (pImgDosHdr).
    //    The e_lfanew field contains the file offset to the PE header.
    //    pImgDosHdr is a pointer to the DOS header, so we access its e_lfanew field using the "->" operator.
    //    This offset is used to locate the PE header.
    // 3. Cast the resulting address to a pointer to PIMAGE_NT_HEADERS, which represents the PE header.
    PIMAGE_NT_HEADERS pImgNtHdr = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
    if (pImgNtHdr->Signature != IMAGE_NT_SIGNATURE) {
        return 1;
    }

    // Retrieve Optional Header
    // Accessing the member of NT Header to get the OptionalHeader 
    // This member contains the Optional Header, which includes additional information about the PE file's format and characteristics.
    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdr->OptionalHeader;



    // Calculate the address of the Export Table:
    // 1. Start with the base address of the loaded PE file (pBase).
    // 2. Add the RVA of the export directory, which is stored in the DataDirectory array of the Optional Header (ImgOptHdr).
    //    The export directory's RVA is typically found in the IMAGE_DIRECTORY_ENTRY_EXPORT entry.
    //    We access this entry using the [] operator and access its VirtualAddress member.
    // 3. Cast the resulting address to a pointer of type PIMAGE_EXPORT_DIRECTORY.
    PIMAGE_EXPORT_DIRECTORY pImgExportD = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    /*
    typedef struct _IMAGE_EXPORT_DIRECTORY {
    <--SNIP-->
    DWORD   AddressOfFunctions;     // Specifies the address of an array of addresses of the exported functions.
    DWORD   AddressOfNames;         // Specifies the address of an array of addresses of hte names of the exported functions.
    DWORD   AddressOfNameOrdinals;  // Specifies the address of an array of ordinal numbers for the exported functions.
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
    */


    // Calculate the address of the array of function names:
    // 1. Start with the base address of the loaded PE file (pBase).
    // 2. Add the RVA of the function names array, which is accessed from the Export Directory structure (pImgExportD).
    //    The AddressOfNames member of the Export Directory points to an array of RVAs to function names.
    // 3. Cast the resulting address to a pointer to an array of DWORDs (PDWORD) to access the function names.
    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportD->AddressOfNames);

    // Cast the resulting address to a pointer to an array of DWORDs (PDWORD) to access the function addresses.
    PDWORD AddressOfFunctions = (PDWORD)(pBase + pImgExportD->AddressOfFunctions);

    // Cast the result address to a pointer to an array of DWORD to access the function ordinals
    PWORD FunctionOrdinals = (PWORD)(pBase + pImgExportD->AddressOfNameOrdinals);

    // Looping through all the exported functions
    for (DWORD i = 0; i < pImgExportD->NumberOfFunctions; i++) {

        // Getting Name Of Function
        CHAR* pFunctionN = (CHAR*)(pBase + FunctionNameArray[i]);

        // Getting Function Ordinal
        PVOID pFunctionAddr = (PVOID)(pBase + AddressOfFunctions[FunctionOrdinals[i]]);

        //printf("[ %0.4d ] NAME: %s - Ordinal: %d\n", i, pFunctionN, FunctionOrdinals);
        
        // Search for specified function
        if (strcmp(lpApiName, pFunctionN) == 0) {
            return pFunctionN;
        }
    }
}

int main() {
    FARPROC OriginalMethod = NULL;
    FARPROC OwnMethod = NULL;

    OriginalMethod = GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtAllocateVirtualMemory");
    OwnMethod = GetProcessAddressRep(GetModuleHandleA("NTDLL.DLL"), "NtAllocateVirtualMemory");

    printf("[+] Original GetProcAddress : 0x%p \n", OriginalMethod);
    printf("[+] GetProcAddress Replacement : 0x%p \n", OwnMethod);
    getchar();

    return 0;
}

