#include <Windows.h>
#include <stdio.h>
#include "Struct.h"
#include <ntstatus.h>

#define TARGET_PROCESS L"notepad.exe"

typedef NTSTATUS(NTAPI* fnNtQuerySystemInformation)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

BOOL GetRemoteProcessHandle(DWORD* pdwPid, HANDLE* phProcess) {
    // Initialize variables
    fnNtQuerySystemInformation pNtQuerySystemInformation = NULL;
    ULONG uReturnLen1 = 0;
    PSYSTEM_PROCESS_INFORMATION SystemProcInfo = NULL;
    NTSTATUS status = 0;
    LPCWSTR szProcName = TARGET_PROCESS;

    // Get the address of NtQuerySystemInformation function
    HMODULE ntdllModule = GetModuleHandleW(L"ntdll.dll");
    if (ntdllModule != NULL) {
        pNtQuerySystemInformation = (fnNtQuerySystemInformation)GetProcAddress(ntdllModule, "NtQuerySystemInformation");
    }

    // Check if NtQuerySystemInformation was found
    if (pNtQuerySystemInformation != NULL) {
        printf("[+] NtQuerySystemInformation Function Found At Address: 0x%p\n", pNtQuerySystemInformation);
    }
    else {
        printf("[-] NtQuerySystemInformation Function Not Found. Error code: %d\n", GetLastError());
        return FALSE;
    }

    // First NtQuerySystemInformation call to get buffer size
    status = pNtQuerySystemInformation(SystemProcessInformation, NULL, 0, &uReturnLen1);
    if (status != STATUS_INFO_LENGTH_MISMATCH) {
        printf("[-] First NtQuerySystemInformation Failed With Error Code: 0x%08X\n", status);
        return FALSE;
    }

    // Allocate buffer for the returned array
    SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, uReturnLen1);
    if (SystemProcInfo == NULL) {
        printf("[-] HeapAlloc Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }
    else {
        printf("[+] Allocated Buffer: 0x%p\n", SystemProcInfo);
    }

    // Save initial value before the while loop
    PSYSTEM_PROCESS_INFORMATION pValueToFree = SystemProcInfo;

    // Call NtQuerySystemInformation again to retrieve process info
    status = pNtQuerySystemInformation(SystemProcessInformation, SystemProcInfo, uReturnLen1, NULL);
    if (status != 0x0) {
        printf("[!] NtQuerySystemInformation Failed With Error: 0x%08X\n", status);
        HeapFree(GetProcessHeap(), 0, pValueToFree);
        return FALSE;
    }

    while (TRUE) {
        // Check the process's name size and comparing the enumerated process name to the intended target process.
        if (SystemProcInfo->ImageName.Length && wcsicmp(SystemProcInfo->ImageName.Buffer, szProcName) == 0) {
            // Opening a handle to the target process, saving it, and then breaking
            *pdwPid = (DWORD)(ULONG_PTR)SystemProcInfo->UniqueProcessId;
            *phProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, *pdwPid);
            break;
        }

        // If NextEntryOffset is 0, we reached the end of the array
        if (!SystemProcInfo->NextEntryOffset)
            break;

        // Move to the next element in the array
        SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo->NextEntryOffset);
    }

    // Free the allocated memory
    HeapFree(GetProcessHeap(), 0, pValueToFree);

    // Check if we successfully got the target process handle
    if (*pdwPid == 0 || *phProcess == NULL)
        return FALSE;
    else
        return TRUE;
}

int main() {
    DWORD dwPid = 0;
    HANDLE hProcess = NULL;

    if (GetRemoteProcessHandle(&dwPid, &hProcess)) {
        printf("[+] Got handle to process with PID: %d\n", dwPid);
        // Perform operations with hProcess as needed
        CloseHandle(hProcess);
    }
    else {
        printf("[-] Unable to get handle to target process. Received Error Code: %d\n", GetLastError());
    }

    return 0;
}
