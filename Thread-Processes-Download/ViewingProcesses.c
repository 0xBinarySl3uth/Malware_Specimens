#include <windows.h>
#include <TlHelp32.h>
#include <tchar.h>
#include <stdio.h>

BOOL GetRemoteProcessHandle(LPCWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {
    // Initialize the structure with the size for compatibility
    PROCESSENTRY32 Proc = {
        .dwSize = sizeof(PROCESSENTRY32)
    };
    // Declare the snapshot handle
    HANDLE hSnapShot = NULL;

    // Create a snapshot of the current processes and check for errors
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf("[+] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    // Access the first process information in the snapshot and check for errors
    if (!Process32First(hSnapShot, &Proc)) {
        printf("[+] Process32First Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    // Create a buffer to hold the lowercase process name
    WCHAR LowerName[MAX_PATH * 2];

    do {
        // Clear the buffer for each process
        RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

        // Check if szExeFile contains the name of the executable file associated with the current process.
        if (Proc.szExeFile) {
            // Convert the TCHAR array (Proc.szExeFile) to a wide string (LowerName)
            int compatible_length = MultiByteToWideChar(CP_ACP, 0, Proc.szExeFile, -1, LowerName, MAX_PATH * 2);
            if (compatible_length == 0) {
                // Error handling for conversion failure
                printf("[!] MultiByteToWideChar Failed With Error : %d \n", GetLastError());
                continue;
            }
        }

        // Compare the value of LowerName with the target process name (szProcessName).
        // If the two strings are the same, it means a match is found.
        if (wcscmp(LowerName, szProcessName) == 0) {
            *dwProcessId = Proc.th32ProcessID;
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL)
                printf("[+] OpenProcess Failed With Error : %d \n", GetLastError());

            break; // Exit the loop once the target process is found.
        }

        // Move to the next process in the snapshot until all processes have been checked.
    } while (Process32Next(hSnapShot, &Proc));

_EndOfFunction:
    // Clean up: close the snapshot handle and check if the function succeeded.
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);

    // Check if the target process was found and the process handle is valid.
    if (*dwProcessId == 0 || *hProcess == NULL)
        return FALSE;

    return TRUE; // Return TRUE if the target process is found and the handle is valid.
}

int main() {
    DWORD dwProcessId = 0;
    HANDLE hProcess = NULL;

    // Use the L prefix to indicate that "notepad.exe" is a wide string
    if (GetRemoteProcessHandle(L"notepad.exe", &dwProcessId, &hProcess)) {
        printf("[+] Found process with PID: %d\n", dwProcessId);
        // You can use the handle hProcess here to perform operations on the remote process
        CloseHandle(hProcess);
    } else {
        printf("[+] Process not found!\n");
    }

    return 0;
}
