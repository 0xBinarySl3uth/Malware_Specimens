#pragma once                                            // Ensure headers are only included once

#include <Windows.h>
#include <stdio.h>

#ifdef _M_X64
#define TRAMPOLINE_SIZE 13                              // Size trampoline shellcode
#endif

#ifdef _M_IX86
#define TRAMPOLINE_SIZE 7                               // Size trampoline shellcode
#endif

typedef unsigned long long uint64_t;                    // Ensure pAddress is in correct number of bytes (8) for 64 bit
typedef unsigned int uint32_t;                          // Ensure pAddress is in correct number of bytes (4) for 32 bit
typedef unsigned char uint8_t;                          // Unsigned integer with a width of 1 byte (8 bits) for both 32-bit and 64-bit

typedef struct _HookSt {
    PVOID pFunctionHook;                                // Pointer to the function to hook
    PVOID pFunctionRun;                                 // Pointer to the function to run instead
    BYTE pOriginalBytes[TRAMPOLINE_SIZE];               // Buffer to keep the original bytes of the hooked function
    DWORD dwOldProtect;                                 // Holds the old memory protection of the function to hook address
} HookSt, * PHookSt;

// Function that handles with error messages
void HandleError(const char* message) {
    printf("[!] Error: %s\n", message);
    exit(1);
}

// Function that initializes the structure (fills the structure)
// pFunctionHook -> Pointer to the address of the hook
// pFunctionRun -> Pointer to the address to run our messagebox
// Hook -> Variable that holds the data that will be used in the hook function.
BOOL InitHookStruct(_In_ PVOID pFunctionHook, _In_ PVOID pFunctionRun, _Out_ PHookSt Hook) {
    // Check if input parms are valid
    if (!pFunctionHook || !pFunctionRun || !Hook) {
        HandleError("Invalid parameters in InitHookStruct");
    }

    // Fill Hook structure with the needed memory addresses
    Hook->pFunctionHook = pFunctionHook;
    Hook->pFunctionRun = pFunctionRun;

    // copy  original bytes from the structure to be hooked to the structure
    memcpy(Hook->pOriginalBytes, pFunctionHook, TRAMPOLINE_SIZE);

    // Change memory permissions, which allows us to change the bytes
    if (!VirtualProtect(pFunctionHook, TRAMPOLINE_SIZE, PAGE_EXECUTE_READWRITE, &Hook->dwOldProtect)) {
        HandleError("VirtualProtect failed in InitHookStruct");
    }

    return TRUE;
}

// Function that installs a hook by overwriting the target function with a trampolin shellcode that redirects execution to a custom function.
// Hook -> A filled HookSt structure containing information about the hook and the original state of the hooked function.
BOOL InstallHook(_In_ PHookSt Hook) {
    // Checks if the values align with the filled structure
    if (!Hook || !Hook->dwOldProtect || !Hook->pFunctionHook || !Hook->pFunctionRun || !Hook->pOriginalBytes) {
        return FALSE;
    }

#ifdef _M_X64
    // Trampoline shellcode for 64-bit
    uint8_t uTrampoline[] = {
        0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x41, 0xFF, 0xE2
    };

    // Patching the shellcode with the address to jump to (pFunctionRun)
    uint64_t uPatch = (uint64_t)(Hook->pFunctionRun);

    // Copying the address of the function to jump to, to the offset '2' in uTrampoline
    memcpy(&uTrampoline[2], &uPatch, sizeof(uPatch));
#endif

#ifdef _M_IX86
    // Trampoline shellcode for 32-bit
    uint8_t uTrampoline[] = {
        0xB8, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xE0
    };

    // Patching the shellcode with the address to jump to (pFunctionRun)
    uint32_t uPatch = (uint32_t)(Hook->pFunctionRun);
    // Copying the address of the function to jump to, to the offset '1' in uTrampoline
    memcpy(&uTrampoline[1], &uPatch, sizeof(uPatch));
#endif

    // Copy the trampoline shellcode, effectively installing our hook
    memcpy(Hook->pFunctionHook, uTrampoline, sizeof(uTrampoline));

    return TRUE;
}


// Function that removes a hook by restoring the original bytes of the hooked function and cleaning up the associated resources.
// Hook -> A filled HookSt structure containing information about the hook and the original state of the hooked function.
BOOL RemoveHook(_In_ PHookSt Hook) {
    // Checks if the values align with the filled structure
    if (!Hook || !Hook->dwOldProtect || !Hook->pFunctionHook || !Hook->pFunctionRun || !Hook->pOriginalBytes) {
        return FALSE;
    }

    DWORD dwOldProtection = 0;

    // Copy the original bytes back over the function hook address
    memcpy(Hook->pFunctionHook, Hook->pOriginalBytes, TRAMPOLINE_SIZE);

    // Cleanup: Set the memory containing original bytes to zeros
    memset(Hook->pOriginalBytes, '\0', TRAMPOLINE_SIZE);

    // Set back the original memory permissions
    if (!VirtualProtect(Hook->pFunctionHook, TRAMPOLINE_SIZE, PAGE_READWRITE, &dwOldProtection)) {
        HandleError("VirtualProtect failed in RemoveHook");
    }

    // Initialize the structure with 0, effectively cleaning the structure
    Hook->pFunctionHook = 0;
    Hook->pFunctionRun = 0;
    Hook->dwOldProtect = 0;

    return TRUE;
}

// the function that will run instead MessageBoxA when hooked
INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    printf("[+] Original Parameters : \n");
    printf("\t - lpText	: %s\n", lpText);
    printf("\t - lpCaption	: %s\n", lpCaption);

    return MessageBoxW(hWnd, L"Hooking Test", L"Hooked MsgBox", uType);
}

int main() {
    // Initialize a HookSt structure
    HookSt st = { 0 };

    // Try to initialize the structure with information about MessageBoxA hooking
    if (!InitHookStruct(&MessageBoxA, &MyMessageBoxA, &st)) {
        HandleError("InitHookStruct failed in main");
    }

    // Display the original MessageBoxA
    MessageBoxA(NULL, "Original MessageBox", "Original", MB_OK);

    // Prompt the user to start API custom code hooking
    printf("[+] Press <Enter> To Start API Custom Code Hooking\n");
    getchar();

    // Attempt to install the hook
    if (!InstallHook(&st)) {
        HandleError("InstallHook failed in main");
    }

    // Display a MessageBoxA (this should show the hooked message)
    MessageBoxA(NULL, "0xBinary", "MessageBox", MB_OK);

    // Prompt the user to unhook
    printf("[+] Press <Enter> To Unhook \n");
    getchar();

    // Attempt to remove the hook
    if (!RemoveHook(&st)) {
        HandleError("RemoveHook failed in main");
    }

    // Display a MessageBoxA after unhooking (this should show the original message)
    MessageBoxA(NULL, "Unhooking - Done", "Unhook MessageBox", MB_OK);

    // Prompt the user to quit
    printf("[+] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}

