/*
 * Explanation:
  - FetchPayloadDisk - Reads payload from disk.
 */

#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <string.h>

// Function reads payload from disk

// Parameter: lstrFileName  -> String that hold the filename
// Parameter: ppBuffer      -> Pointer that will store the base address of the file that points to the payload
// Parameter: pdwFileSize   -> Pointer that will receive the file size in bytes
BOOL FetchPayloadDisk(_In_ LPCSTR lFilename, _Out_ PBYTE* ppBuffer, _Out_ PDWORD pdwFileSize) {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE		pBuffer					= NULL;
    DWORD		dwFileSize				= 0x00,
            dwNumberOfBytesRead		= 0x00;
    // CreateFileA -> Opens our payload file that is located on disk.

    // Parameter: lpFilename                -> Hold the filename that need to be opend
    // Parameter: GENERIC_READ              -> The type of privilege of the file in question
    // Parameter: 0x00                      -> Prevents other process from opening the file
    // Parameter: NULL                      -> Prevent hFile handle can be used in child process
    // Parameter: OPEN_EXISTING             -> Only opens the file, when it's present on disk
    // Parameter: FILE_ATTRIBUTE_NORMAL     -> The payload file does not have other attributes set. This attribute is valid only if used alone
    // Parameter: NULL                      -> This parameter will be skipped if the file exists on disk
    hFile = CreateFileA(lFilename, GENERIC_READ, 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileA Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Read: \"%s\"\n", lFilename);

    // Determine filesize in bytes

    // Parameter: hFile                     -> Handle to file that will be opend
    // Parameter: NULL                      -> No need for high order double word
    if ((dwFileSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        printf("[!] GetFileSize Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("[+] Successfully Read: \"%s\" -> Number of Bytes: %lu \n", lFilename, dwFileSize);

    // Allocate memory for reading the file

    // Function: GetProcessHeap()           -> Returns  heap of the current (calling) process
    // Parameter HEAP_ZERO_MEMORY           -> Allocated heap memory with 0's, (makes sure the allocated memory is empty and not filled with leftovers)
    if ((pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize)) == NULL) {
        printf("[!] HeapAlloc Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    // Reading file from disk

    // Parameter: pBuffer                   -> Handle to our payload file
    // Parameter: dwFileSize                -> Pointer to buffer that holds the filesize of our payload
    // Parameter: &dwNumberOfBytesRead      -> Specifies the maximum of the bytes that can be read
    // Parameter: NULL                      -> Since this operation is not sync'ed we can ignore this
    if (!ReadFile(hFile, pBuffer,dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        printf("[!] ReadFile Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("[+] Bytes Read: %lu from total number of bytes: %lu \n", dwNumberOfBytesRead, dwFileSize);

    // Cast Allocated Buffer to Output Buffer.
    *ppBuffer = pBuffer;

    // Set Filesize in Output Filesize.
    *pdwFileSize = dwFileSize;


    // Clean up.
    CloseHandle(hFile);
    if (!*ppBuffer) {
        HeapFree(GetProcessHeap(), 0x00, pBuffer);
    }
    return ((*ppBuffer != NULL) && (*pdwFileSize != 0x00)) ? TRUE : FALSE;
}

// Initialize PE Headers - Allows us to copy the data into PE_HDR struct. This struct hold data dirs required for lading the PE
typedef struct _PE_HDRS
{
    PBYTE					pFileBuffer;
    DWORD					dwFileSize;

    PIMAGE_NT_HEADERS		pImgNtHdrs;
    PIMAGE_SECTION_HEADER	pImgSecHdr;

    PIMAGE_DATA_DIRECTORY	pEntryImportDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryBaseRelocDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryTLSDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryExceptionDataDir;
    PIMAGE_DATA_DIRECTORY	pEntryExportDataDir;

    BOOL					bIsDLLFile;
}PE_HDRS, *PPE_HDRS;


// Function that will populate elements of PE HDRS Structure

// Parameter: pPeHdrs                       -> Point to PE_HDRS structure
// Parameter: pFileBuffer                   -> Hold base address of the file that will be read
// Parameter: dwFileSize                    -> Holds file size (bytes) of the read file
BOOL InitPEStruct(_Out_ PPE_HDRS pPeHdrs, _In_ PBYTE pFileBuffer, _In_ DWORD dwFilSize) {

    // Check if parameters hold value
    if (!pPeHdrs || !pFileBuffer || !dwFilSize)
        return FALSE;

    // Fill structure with data
    pPeHdrs->pFileBuffer = pFileBuffer;
    pPeHdrs->dwFileSize = dwFilSize;
    pPeHdrs->pImgNtHdrs = (PIMAGE_NT_HEADERS)(pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);

    // Verify that pPeHdrs has correctly initialized NT Header
    if (pPeHdrs->pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // Initialize other members of Pe_HDRS struct
    pPeHdrs->bIsDLLFile = (pPeHdrs->pImgNtHdrs->FileHeader.Characteristics & IMAGE_FILE_DLL) ? TRUE : FALSE;
    pPeHdrs->pImgSecHdr = IMAGE_FIRST_SECTION(pPeHdrs->pImgNtHdrs);
    pPeHdrs->pEntryImportDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    pPeHdrs->pEntryBaseRelocDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    pPeHdrs->pEntryTLSDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    pPeHdrs->pEntryExceptionDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
    pPeHdrs->pEntryExportDataDir = &pPeHdrs->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

    printf("[+] Successfully Initialized pPeHdrs!\n");

    return TRUE;
}

/*
 * IAT Reimplementation:
 *  - When the system loader handles a PE image, its duty includes resolved IAT table by loading the required DLLs into the process.
 *  - Since we load our own PE loader, it's required to pass the IAT addresses manually.
 */

// Parameter: pEntryImportDataDir           -> Pointer that holds data dir of PE file
// Parameter: pPeBaseAddress                -> Base address of PE payload
BOOL FixImportAddressTable(_In_ PIMAGE_DATA_DIRECTORY pEntryImportDataDir, _In_ PBYTE pPeBaseAddress) {

    // Pointer to an import descriptor for a DLL
    PIMAGE_IMPORT_DESCRIPTOR	pImgDescriptor		= NULL;
    // Iterate over the import descriptors
    for (SIZE_T i = 0; i < pEntryImportDataDir->Size; i += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {
        // Get the current import descriptor
        pImgDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(pPeBaseAddress + pEntryImportDataDir->VirtualAddress + i);
        // If both thunks are NULL, we've reached the end of the import descriptors list
        if (pImgDescriptor->OriginalFirstThunk == 0 && pImgDescriptor->FirstThunk == 0)
            break;

        // Retrieve information from the current import descriptor
        LPSTR		cDllName					= (LPSTR)(pPeBaseAddress + pImgDescriptor->Name);
        ULONG_PTR	uOriginalFirstThunkRVA		= pImgDescriptor->OriginalFirstThunk;
        ULONG_PTR	uFirstThunkRVA				= pImgDescriptor->FirstThunk;
        SIZE_T		ImgThunkSize				= 0x00;	// Used to move to the next function (iterating through the IAT and INT)
        HMODULE		hModule						= NULL;


        // Try to load the DLL referenced by the current import descriptor
        if (!(hModule = LoadLibraryA(cDllName))) {
           printf("[!] LoadLibraryA Failed With Error Code: %lu \n", GetLastError());
            return FALSE;
        }

        // Iterate over the imported functions for the current DLL
        while (TRUE) {

            // Get pointers to the first thunk and original first thunk data
            PIMAGE_THUNK_DATA			pOriginalFirstThunk			= (PIMAGE_THUNK_DATA)(pPeBaseAddress + uOriginalFirstThunkRVA + ImgThunkSize);
            PIMAGE_THUNK_DATA			pFirstThunk					= (PIMAGE_THUNK_DATA)(pPeBaseAddress + uFirstThunkRVA + ImgThunkSize);
            PIMAGE_IMPORT_BY_NAME		pImgImportByName			= NULL;
            ULONG_PTR					pFuncAddress				= 0;

            // At this point both 'pOriginalFirstThunk' & 'pFirstThunk' will have the same values
            // However, to populate the IAT (pFirstThunk), one should use the INT (pOriginalFirstThunk) to retrieve the
            // functions addresses and patch the IAT (pFirstThunk->u1.Function) with the calculated address.
            if (pOriginalFirstThunk->u1.Function == 0 && pFirstThunk->u1.Function == 0) {
                break;
            }

            // If the ordinal flag is set, import the function by its ordinal number
            if (IMAGE_SNAP_BY_ORDINAL(pOriginalFirstThunk->u1.Ordinal)) {
                char szOrdinal[20];  // Adjust the size based on the maximum length you expect
                sprintf(szOrdinal, "%lu", (unsigned long)pOriginalFirstThunk->u1.Ordinal);

                if (!(pFuncAddress = (ULONG_PTR)GetProcAddress(hModule, szOrdinal))) {
                    printf("[!] Could Not Import !%s#%s \n", cDllName, szOrdinal);
                    return FALSE;
                }
            }

            // Import function by name
            else {
                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pPeBaseAddress + pOriginalFirstThunk->u1.AddressOfData);
                if ( !(pFuncAddress = (ULONG_PTR)GetProcAddress(hModule, pImgImportByName->Name)) ) {
                    printf("[!] Could Not Import !%s.%s \n", cDllName, pImgImportByName->Name);
                    return FALSE;
                }
            }

            // Install the function address in the IAT
            pFirstThunk->u1.Function = (ULONGLONG)pFuncAddress;

            // Move to the next function in the IAT/INT array
            ImgThunkSize += sizeof(IMAGE_THUNK_DATA);
        }
    }

    printf("[+] IAT Successfully Modified!\n");
    return TRUE;
}

typedef struct BASE_RELOCATION_ENTRY {
    WORD Offset : 12;
    WORD Type : 4;
} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;

// FixRelocation function is responsible for adjusting the base addresses in the PE image based on relocation information.
// Parameters:
//   pEntryBaseRelocDataDir: Pointer to the IMAGE_DATA_DIRECTORY for the base relocation table.
//   pPeBaseAddress: The base address of the PE image in memory.
//   pPreferableAddress: The preferred base address to which the PE image should be relocated.

BOOL FixRelocation(_In_ PIMAGE_DATA_DIRECTORY pEntryBaseRelocDataDir, _In_ ULONG_PTR pPeBaseAddress, _In_ ULONG_PTR pPreferableAddress) {

    // Pointer to the start of the base relocation block
    PIMAGE_BASE_RELOCATION pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)(pPeBaseAddress + pEntryBaseRelocDataDir->VirtualAddress);

    // Determine the difference between the current PE image base address and its preferable base address
    ULONG_PTR uDeltaOffset = pPeBaseAddress - pPreferableAddress;

    // Pointer to base relocation entries within the current block
    PBASE_RELOCATION_ENTRY pBaseRelocationEntry = NULL;

    // Iterate through all the relocation blocks
    while (pImageBaseRelocation->VirtualAddress) {
        // Pointer to the first relocation entry in the current block
        pBaseRelocationEntry = (PBASE_RELOCATION_ENTRY)(pImageBaseRelocation + 1);

        // Iterate through all the relocation entries in the current block
        while ((PBYTE)pBaseRelocationEntry != (PBYTE)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock) {
            // Process relocation entry based on its type
            switch (pBaseRelocationEntry->Type) {
                case IMAGE_REL_BASED_DIR64:
                    // Adjust a 64-bit field by the delta offset.
                    *((ULONG_PTR*)(pPeBaseAddress + pImageBaseRelocation->VirtualAddress + pBaseRelocationEntry->Offset)) += uDeltaOffset;
                    break;
                case IMAGE_REL_BASED_HIGHLOW:
                    // Adjust a 32-bit field by the delta offset.
                    *((DWORD*)(pPeBaseAddress + pImageBaseRelocation->VirtualAddress + pBaseRelocationEntry->Offset)) += (DWORD)uDeltaOffset;
                    break;
                case IMAGE_REL_BASED_HIGH:
                    // Adjust the high 16 bits of a 32-bit field.
                    *((WORD*)(pPeBaseAddress + pImageBaseRelocation->VirtualAddress + pBaseRelocationEntry->Offset)) += HIWORD(uDeltaOffset);
                    break;
                case IMAGE_REL_BASED_LOW:
                    // Adjust the low 16 bits of a 32-bit field.
                    *((WORD*)(pPeBaseAddress + pImageBaseRelocation->VirtualAddress + pBaseRelocationEntry->Offset)) += LOWORD(uDeltaOffset);
                    break;
                case IMAGE_REL_BASED_ABSOLUTE:
                    // No relocation is required for this entry.
                    break;
                default:
                    // Handle unknown relocation types.
                    printf("[!] Unknown relocation type: %d | Offset: 0x%08X \n", pBaseRelocationEntry->Type, pBaseRelocationEntry->Offset);
                    return FALSE;
            }
            // Move to the next relocation entry
            pBaseRelocationEntry++;
        }
        // Move to the next relocation block
        pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)pBaseRelocationEntry;
    }

    // Print success message only if the operation is completed successfully
    if (pImageBaseRelocation->VirtualAddress == 0) {
        printf("[+] Fixed Relocation Successfully!\n");
        return TRUE;
    }

    return FALSE;
}



// After relocated the relocation blocks, we have to apply the correct permissions

// Parameter: pBaseAddress            -> Hold base address of PE payload image location
// Parameter: pImageNtHdr             -> Pointer to NT headers of PE payload
// Parameter: pImageSectionHdr        -> Point to Section headers of PE payload
BOOL MemoryPermissions(_In_ ULONG_PTR pPeBaseAddress, _In_ PIMAGE_NT_HEADERS pImageNtHdr, _In_ PIMAGE_SECTION_HEADER pImageSectionHdr) {

    // Loop through each section of the PE image
    for (DWORD i = 0; i < pImageNtHdr->FileHeader.NumberOfSections; i++) {
        DWORD dwProtect, dwOldProtect = 0x00;

        // Skip section if it's empty and no VA
        if (!pImageSectionHdr[i].SizeOfRawData || !pImageSectionHdr[i].VirtualAddress)
            continue;

        // Determine memory protection based on section characteristics
        if (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            dwProtect = PAGE_WRITECOPY;
        if (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_READ)
            dwProtect = PAGE_READONLY;

        if ((pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtect = PAGE_READWRITE;

        if (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
            dwProtect = PAGE_EXECUTE;

        if ((pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE))
            dwProtect = PAGE_EXECUTE_WRITECOPY;

        if ((pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtect = PAGE_EXECUTE_READ;

        if ((pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImageSectionHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtect = PAGE_EXECUTE_READWRITE;

        // Apply memory protection to the right section
        if (!VirtualProtect((PVOID)(pPeBaseAddress + pImageSectionHdr[i].VirtualAddress), pImageSectionHdr[i].SizeOfRawData, dwProtect, &dwOldProtect)) {
            printf("[!] VirtualProtect Failed With Error Code: %lu \n", GetLastError());
            return FALSE;
        }
    }
    printf("[+] Fixed Memory Permissions!\n");
    return TRUE;
}

// Function calculates function's addresses and return its address

// Parameter: pEntryExportDataDir -> Pointer to the export data directory of the PE payload
// Parameter: pPeBaseAddress -> Pointer to the memory address of the PE payload
// Parameter: cFunctionName -> String that will hold the exported function that needs to be loaded

PVOID FetchExportFuncAddr(_In_ PIMAGE_DATA_DIRECTORY pEntryExportDataDir, _In_ ULONG_PTR pPeBaseAddress, _In_ LPSTR cFunctionName) {

    // Retrieve Pointer to export directory
    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(pPeBaseAddress + pEntryExportDataDir->VirtualAddress);

    // Pointer that will hold the names of the functions to be iterated through
    PDWORD FunctionNameArray = (PDWORD)(pPeBaseAddress + pImageExportDirectory->AddressOfNames);

    // Pointer that will hold the function addresses to be iterated through
    PDWORD FunctionAddressArray = (PDWORD)(pPeBaseAddress + pImageExportDirectory->AddressOfFunctions);

    // Pointer that will hold ordinal numbers of the function names
    PDWORD FunctionOrdinalArray = (PDWORD)(pPeBaseAddress + pImageExportDirectory->AddressOfNameOrdinals);

    // Iterate through the function names
    for (DWORD i = 0; i < pImageExportDirectory->NumberOfFunctions; i++) {
        // Retrieve the current function name
        CHAR* pFunctionName = (CHAR*)(pPeBaseAddress + FunctionNameArray[i]);

        // Retrieve the current function address
        PVOID pFunctionAddress = (PVOID)(pPeBaseAddress + FunctionAddressArray[FunctionOrdinalArray[i]]);

        // If there is a match, return the function address
        if (strcmp(cFunctionName, pFunctionName) == 0)
            return pFunctionAddress;

        printf("[+] Fetched Export Function Addresses Successfully!\n");
    }
    return 0;
}

// Function pointer type for a DLL entry point.
// It takes a handle to the DLL module, the reason the DLL entry point is being called,
// and NULL (reserved).
typedef BOOL(WINAPI* DLLMAIN)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

// Function pointer type for a main function without parameters.
typedef BOOL(WINAPI* MAIN)();


VOID FixArguments(_In_ LPCSTR cArgumentsToPass);

BOOL LocalPeExec(_In_ PPE_HDRS pPeHdrs, _In_ OPTIONAL LPCSTR cExportFuncName, _In_ OPTIONAL LPCSTR cArg) {
    // If pPeHdrs == NULL
    if (!pPeHdrs)
    return FALSE;

    PBYTE           pPeBaseAddress           = NULL;
    PVOID			pEntryPoint				= NULL;
    PVOID			pExportedFuncAddress	= NULL;

    // Allocate memory for PE payload
    if ((pPeBaseAddress = VirtualAlloc(NULL, pPeHdrs->pImgNtHdrs->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL) {
        printf("[!] VirtualAlloc Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    // Iterate through each section in the PE file
    for (int i = 0; i < pPeHdrs->pImgNtHdrs->FileHeader.NumberOfSections; i++) {

        // Calculate the destination address in the process memory where the section will be loaded
        PVOID destinationAddress = (PVOID)(pPeBaseAddress + pPeHdrs->pImgSecHdr[i].VirtualAddress);

        // Calculate the source address in the file buffer where the section is stored
        PVOID sourceAddress = (PVOID)((ULONG_PTR)pPeHdrs->pFileBuffer + pPeHdrs->pImgSecHdr[i].PointerToRawData);

        // Copy the section data from the file buffer to the process memory
        // The size of the data to be copied is determined by the SizeOfRawData field in the section header
        memcpy(destinationAddress, sourceAddress, pPeHdrs->pImgSecHdr[i].SizeOfRawData);
    }

    // Fix Import Address Table (IAT)
    if (!FixImportAddressTable(pPeHdrs->pEntryExportDataDir, (PBYTE)pPeBaseAddress))
        return FALSE;

    // Apply new relocations
    if (!FixRelocation(pPeHdrs->pEntryExportDataDir, (ULONG_PTR) (PBYTE) pPeBaseAddress, pPeHdrs->pImgNtHdrs->OptionalHeader.ImageBase))
        return FALSE;

    // Fix memory permissions
    if (!MemoryPermissions((ULONG_PTR) pPeBaseAddress, pPeHdrs->pImgNtHdrs, pPeHdrs->pImgSecHdr))
        return FALSE;

    // Fetch exported function if 'cExportedFuncName' is passed
    if (pPeHdrs->pEntryExportDataDir->Size && pPeHdrs->pEntryExportDataDir->VirtualAddress && cExportFuncName)
        pExportedFuncAddress = FetchExportFuncAddr(pPeHdrs->pEntryExportDataDir, (ULONG_PTR) pPeBaseAddress, cExportFuncName);

    FixArguments(cArg);

    // Set exception handlers of the injected PE (if exists)
    if (pPeHdrs->pEntryExceptionDataDir->Size) {
        // Retrieve the function table entry
        PIMAGE_RUNTIME_FUNCTION_ENTRY pImgRuntimeFuncEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(pPeBaseAddress + pPeHdrs->pEntryExceptionDataDir->VirtualAddress);
        // Register the function table
        if (!RtlAddFunctionTable(pImgRuntimeFuncEntry, (pPeHdrs->pEntryExceptionDataDir->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)),(DWORD64) pPeBaseAddress)) {
            printf("[!] RtlAddFunctionTable Failed With Error Code: %lu \n", GetLastError());
        }
    }

    // Execute TLS callbacks (if exists)
    if (pPeHdrs->pEntryTLSDataDir->Size) {
        // Retrieve the address of the TLS Directory.
        PIMAGE_TLS_DIRECTORY	pImgTlsDirectory	= (PIMAGE_TLS_DIRECTORY)(pPeBaseAddress + pPeHdrs->pEntryTLSDataDir->VirtualAddress);
        // Get the address of the TLS Callbacks from the TLS Directory.
        PIMAGE_TLS_CALLBACK*	pImgTlsCallback		= (PIMAGE_TLS_CALLBACK*)(pImgTlsDirectory->AddressOfCallBacks);
        CONTEXT					pCtx				= { 0x00 };


        // Iterate through and invoke each TLS Callback until a NULL callback is encountered.
        for (int i = 0; pImgTlsCallback[i] != NULL; i++){
            pImgTlsCallback[i]((LPVOID)pPeBaseAddress, DLL_PROCESS_ATTACH, &pCtx);
        }

    }

    // Execute EP
    pEntryPoint = (PVOID)(pPeBaseAddress + pPeHdrs->pImgNtHdrs->OptionalHeader.AddressOfEntryPoint);

    // If DLL
    if (pPeHdrs->bIsDLLFile) {

        DLLMAIN		pDllMain	= (DLLMAIN)pEntryPoint;
        HANDLE		hThread		= NULL;

        // Execute DllMain:
        pDllMain((HINSTANCE)pPeBaseAddress, DLL_PROCESS_ATTACH, NULL);
        // Execute Exported Function (if exists):
        if (pExportedFuncAddress)
            hThread = CreateThread(NULL, 0x00, pExportedFuncAddress, NULL, 0x00, NULL);
        if (hThread)
            WaitForSingleObject(hThread, INFINITE);
    }
        // If EXE
    else {
        MAIN pMain = (MAIN)pEntryPoint;
        return pMain();
    }

    return TRUE;
}

VOID HandleCmdLineArgs(int argc, char* argv[], char** ppe_arg, char** pfptr_arg, char** pparm_arg) {


    char*	pe_arg					= NULL;
    char*	fptr_arg				= NULL;
    char*	parm_arg				= NULL;
    char	parm_buffer[1024 * 2]	= { 0 };


    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-pe") == 0 && i + 1 < argc) {
            pe_arg = argv[++i];
        }
        else if (strcmp(argv[i], "-fptr") == 0 && i + 1 < argc) {
            fptr_arg = argv[++i];
        }
        else if (strcmp(argv[i], "-parm") == 0 && i + 1 < argc) {
            parm_arg = parm_buffer;
            strcpy(parm_arg, argv[++i]);
            while (i + 1 < argc && argv[i + 1][0] != '-') {
                strcat(parm_arg, " ");
                strcat(parm_arg, argv[++i]);
            }
        }
    }

    *ppe_arg	= pe_arg;
    *pfptr_arg	= fptr_arg;
    *pparm_arg	= parm_arg;
}



SIZE_T CharStringToWCharString(_Inout_ PWCHAR Destination, _In_ PCHAR Source, SIZE_T _In_ MaximumAllowed)
{
    INT Length = (INT)MaximumAllowed;

    while (--Length >= 0)
    {
        if (!(*Destination++ = *Source++))
            return MaximumAllowed - Length - 1;
    }

    return MaximumAllowed - Length;
}


VOID FixArguments(IN OPTIONAL LPCSTR cArgumentsToPass) {

    PRTL_USER_PROCESS_PARAMETERS	pParam				= ((PPEB)__readgsqword(0x60))->ProcessParameters;

    RtlSecureZeroMemory(pParam->CommandLine.Buffer, pParam->CommandLine.Length * sizeof(WCHAR));

    if (cArgumentsToPass) {

        WCHAR*					wNewCommand				= NULL;
        WCHAR*					wArgumentsToPass		= NULL;
        INT						iWideCharSize			= 0x00;

        // char => wchar
        if (!(wArgumentsToPass = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (strlen(cArgumentsToPass) * sizeof(WCHAR) + sizeof(WCHAR))))) {
            printf("HeapAlloc Failed With Error Code: %lu\n", GetLastError());
            return;
        }

        CharStringToWCharString(wArgumentsToPass, cArgumentsToPass, (strlen(cArgumentsToPass) * sizeof(WCHAR) + sizeof(WCHAR)));

        // Construct the new commandline
        if (!(wNewCommand = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ((wcslen(wArgumentsToPass) + pParam->ImagePathName.Length) * sizeof(WCHAR) + sizeof(WCHAR))))) {
            printf("[!] HeapAlloc Failed With Er");
            return;
        }

        wsprintfW(wNewCommand, L"\"%s\" %s", pParam->ImagePathName.Buffer, wArgumentsToPass);

        // Overwrite the old one
        lstrcpyW(pParam->CommandLine.Buffer, wNewCommand);
        pParam->CommandLine.Length = pParam->CommandLine.MaximumLength = wcslen(pParam->CommandLine.Buffer) * sizeof(WCHAR) + sizeof(WCHAR);
        pParam->CommandLine.MaximumLength += sizeof(WCHAR);

        HeapFree(GetProcessHeap(), 0x00, wArgumentsToPass);
        HeapFree(GetProcessHeap(), 0x00, wNewCommand);

        return;
    }

    // No arguments: overwrite with image name only
    lstrcpyW(pParam->CommandLine.Buffer, pParam->ImagePathName.Buffer);
    pParam->CommandLine.Length = pParam->CommandLine.MaximumLength = wcslen(pParam->CommandLine.Buffer) * sizeof(WCHAR) + sizeof(WCHAR);
    pParam->CommandLine.MaximumLength += sizeof(WCHAR);
}



#define GET_FILENAME(path) (strrchr(path, '\\') ? strrchr(path, '\\') + 1 : path)

int main(int argc, char* argv[]) {


    char*	pe_arg					= NULL;
    char*	fptr_arg				= NULL;
    char*	parm_arg				= NULL;

    HandleCmdLineArgs(argc, argv, &pe_arg, &fptr_arg, &parm_arg);

    if (!pe_arg) {
        printf("[!] Usage: %s -pe <Input PE> -fptr <*optional*: Exported function> -parm <*optional*: Arguments to pass> \n", GET_FILENAME(argv[0]));
        printf("\t<i> e.g. %s -pe DllMsgBox.dll -fptr HelloWorld \n", GET_FILENAME(argv[0]));
        printf("\t<i> e.g. %s -pe DllMsgBox.dll \n", GET_FILENAME(argv[0]));
        printf("\t<i> e.g. %s -pe ExeMsgBox.exe \n", GET_FILENAME(argv[0]));
        printf("\t<i> e.g. %s -pe ExeArgs.exe -parm this is a command line arg\n", GET_FILENAME(argv[0]));
        printf("\n\n");
        return -1;
    }

    PBYTE		pFileBuffer		= NULL;
    DWORD		dwFileSize		= 0x00;
    PE_HDRS		PeHdrStruct		= { 0 };

    if (!FetchPayloadDisk(pe_arg, &pFileBuffer, &dwFileSize))
        return -1;

    if (!InitPEStruct(&PeHdrStruct, pFileBuffer, dwFileSize))
        return -1;

    LocalPeExec(&PeHdrStruct, fptr_arg, parm_arg);

    return 0;
}
