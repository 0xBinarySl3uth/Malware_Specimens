# Introduction
With Local PE Injection, where the payload, a PE file will be executed within the local process of the PE loader

# PE Injection Steps
1. Allocate enough memory to hold the injected PE file
2. Copy over the PEs sections to the allocated memory
3. Address the PEs relocations
4. Fix IAT
5. Set suitable memory permission for each of the PEs sections
6. Execute PE entry point


# IAT Reimplementation:
- When the system loader handles a PE image, its duty includes resolved IAT table by loading the required DLLs into the process.
- Since we load our own PE loader, it's required to pass the IAT addresses manually.

- The Import Name Table (ILT) can be accessed via the `OrginialFirstTrunk` RVA from the `IMAGE_EXPORT_DESCRITPROR` struct.
- INT serves as a table containing function names and ordinals that are intended to be imported into the PE from the DLL library specified by `IMAGE_IMPORT_DESCRIPTOR.Name`

```c
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // Used in the case of forwarded functions - not used.
        ULONGLONG Function;         // The address of the function to be populated
        ULONGLONG Ordinal;	    // Ordinal number of the function	
        ULONGLONG AddressOfData;    // RVA to PIMAGE_IMPORT_BY_NAME - used only if the function is imported by name rather by ordinal.
    } u1;
} IMAGE_THUNK_DATA64;

```

## Import Function by Ordinal
- We use use `IMAGE_SNAP_BY_ORDINAL` macro, which verifies whether an import entry references an ordinal rather then a name.
```c
pFunctionAddress = GetProcAddress(hModule, IMAGE_ORDINAL(PIMAGE_THUNK_DATA->u1.Ordinal));
```

## Import Function by Name
- We can use `IMAGE_IMPORT_BY_NAME` macro. This structure is accessed via it's RVA, `AddressOfData` found within `IMAGE_TRUNK_DATA` structure.

```c
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;	// Look-up number of the function in the function export table - not used.
    CHAR   Name[1];	// Function name
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
```

```c
PIMAGE_IMPORT_BY_NAME pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pPeBaseAddress + PIMAGE_THUNK_DATA->u1.AddressOfData);
pFunctionAddress = GetProcAddress(hModule, pImgImportByName->Name);
```

On disk, both the IAT and INT tables are identical. However, at runtime, the IAT is patched with the function addresses that the PE invokes. The IAT can be accessed using its RVA, `IMAGE_IMPORT_DESCRIPTOR`.
`FirstThunk`, and it also consists of an array of `IMAGE_THUNK_DATA` structures. To resolve the PE's IAT, you will need to work with two arrays of `IMAGE_THUNK_DATA` structures:

1. One represents the INT, responsible for retrieving the function's address.
2. The other represents the IAT, where the IMAGE_THUNK_DATA.u1.Function element is populated with the retrieved function address.
